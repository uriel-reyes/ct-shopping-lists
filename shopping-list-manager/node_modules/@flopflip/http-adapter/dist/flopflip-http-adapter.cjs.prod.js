'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _classPrivateFieldLooseBase = require('@babel/runtime/helpers/classPrivateFieldLooseBase');
var _classPrivateFieldLooseKey = require('@babel/runtime/helpers/classPrivateFieldLooseKey');
var adapterUtilities = require('@flopflip/adapter-utilities');
var types = require('@flopflip/types');
var isEqual = require('lodash/isEqual');
var mitt = require('mitt');
var warning = require('tiny-warning');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var isEqual__default = /*#__PURE__*/_interopDefault(isEqual);
var mitt__default = /*#__PURE__*/_interopDefault(mitt);
var warning__default = /*#__PURE__*/_interopDefault(warning);

const STORAGE_SLICE = '@flopflip';
const intialAdapterState = {
  subscriptionStatus: types.AdapterSubscriptionStatus.Subscribed,
  configurationStatus: types.AdapterConfigurationStatus.Unconfigured,
  flags: {},
  lockedFlags: new Set(),
  user: {},
  emitter: mitt__default["default"]()
};
var _internalConfiguredStatusChange__ = /*#__PURE__*/_classPrivateFieldLooseKey("__internalConfiguredStatusChange__");
var _adapterState = /*#__PURE__*/_classPrivateFieldLooseKey("adapterState");
var _defaultpollingIntervalMs = /*#__PURE__*/_classPrivateFieldLooseKey("defaultpollingIntervalMs");
var _getIsAdapterUnsubscribed = /*#__PURE__*/_classPrivateFieldLooseKey("getIsAdapterUnsubscribed");
var _getIsFlagLocked = /*#__PURE__*/_classPrivateFieldLooseKey("getIsFlagLocked");
var _getCache = /*#__PURE__*/_classPrivateFieldLooseKey("getCache");
var _didFlagsChange = /*#__PURE__*/_classPrivateFieldLooseKey("didFlagsChange");
var _fetchFlags = /*#__PURE__*/_classPrivateFieldLooseKey("fetchFlags");
var _subscribeToFlagsChanges = /*#__PURE__*/_classPrivateFieldLooseKey("subscribeToFlagsChanges");
class HttpAdapter {
  constructor() {
    this.id = void 0;
    // eslint-disable-next-line @typescript-eslint/prefer-readonly
    Object.defineProperty(this, _internalConfiguredStatusChange__, {
      writable: true,
      value: '__internalConfiguredStatusChange__'
    });
    Object.defineProperty(this, _adapterState, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _defaultpollingIntervalMs, {
      writable: true,
      value: 1000 * 60
    });
    Object.defineProperty(this, _getIsAdapterUnsubscribed, {
      writable: true,
      value: () => _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus === types.AdapterSubscriptionStatus.Unsubscribed
    });
    Object.defineProperty(this, _getIsFlagLocked, {
      writable: true,
      value: flagName => _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].lockedFlags.has(flagName)
    });
    Object.defineProperty(this, _getCache, {
      writable: true,
      value: async cacheIdentifier => {
        let cacheModule;
        switch (cacheIdentifier) {
          case types.cacheIdentifiers.local:
            {
              cacheModule = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@flopflip/localstorage-cache')); });
              break;
            }
          case types.cacheIdentifiers.session:
            {
              cacheModule = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@flopflip/sessionstorage-cache')); });
              break;
            }
        }
        const createCache = cacheModule.default;
        const cache = createCache({
          prefix: STORAGE_SLICE
        });
        return {
          set(flags) {
            return cache.set('flags', flags);
          },
          get() {
            return cache.get('flags');
          },
          unset() {
            return cache.unset('flags');
          }
        };
      }
    });
    Object.defineProperty(this, _didFlagsChange, {
      writable: true,
      value: nextFlags => {
        const previousFlags = _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags;
        if (previousFlags === undefined) return true;
        return !isEqual__default["default"](nextFlags, previousFlags);
      }
    });
    Object.defineProperty(this, _fetchFlags, {
      writable: true,
      value: async adapterArgs => {
        const flags = await adapterArgs.execute();
        return flags;
      }
    });
    Object.defineProperty(this, _subscribeToFlagsChanges, {
      writable: true,
      value: adapterArgs => {
        var _adapterArgs$pollingI;
        const pollingIntervalMs = (_adapterArgs$pollingI = adapterArgs.pollingIntervalMs) !== null && _adapterArgs$pollingI !== void 0 ? _adapterArgs$pollingI : _classPrivateFieldLooseBase(this, _defaultpollingIntervalMs)[_defaultpollingIntervalMs];
        setInterval(async () => {
          if (!_classPrivateFieldLooseBase(this, _getIsAdapterUnsubscribed)[_getIsAdapterUnsubscribed]()) {
            const nextFlags = adapterUtilities.normalizeFlags(await _classPrivateFieldLooseBase(this, _fetchFlags)[_fetchFlags](adapterArgs));
            if (_classPrivateFieldLooseBase(this, _didFlagsChange)[_didFlagsChange](nextFlags)) {
              if (adapterArgs.cacheIdentifier) {
                const cache = await _classPrivateFieldLooseBase(this, _getCache)[_getCache](adapterArgs.cacheIdentifier);
                cache.set(nextFlags);
              }
              _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags = nextFlags;
              _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', nextFlags);
            }
          }
        }, pollingIntervalMs);
      }
    });
    this.getUser = () => _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user;
    this.updateFlags = (flags, options) => {
      const isAdapterConfigured = this.getIsConfigurationStatus(types.AdapterConfigurationStatus.Configured);
      warning__default["default"](isAdapterConfigured, '@flopflip/http-adapter: adapter not configured. Flags can not be updated before.');
      if (!isAdapterConfigured) return;
      const previousFlags = _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags;
      const updatedFlags = Object.entries(flags).reduce((updatedFlags, _ref) => {
        let _ref2 = _slicedToArray(_ref, 2),
          flagName = _ref2[0],
          flagValue = _ref2[1];
        const _normalizeFlag = adapterUtilities.normalizeFlag(flagName, flagValue),
          _normalizeFlag2 = _slicedToArray(_normalizeFlag, 2),
          normalizedFlagName = _normalizeFlag2[0],
          normalizedFlagValue = _normalizeFlag2[1];
        if (_classPrivateFieldLooseBase(this, _getIsFlagLocked)[_getIsFlagLocked](normalizedFlagName)) return updatedFlags;
        if (options !== null && options !== void 0 && options.lockFlags) {
          _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].lockedFlags.add(normalizedFlagName);
        }
        updatedFlags = _objectSpread(_objectSpread({}, updatedFlags), {}, {
          [normalizedFlagName]: normalizedFlagValue
        });
        return updatedFlags;
      }, {});
      const nextFlags = _objectSpread(_objectSpread({}, previousFlags), updatedFlags);
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags = nextFlags;
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', nextFlags);
    };
    this.reset = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState] = _objectSpread({}, intialAdapterState);
    };
    this.unsubscribe = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus = types.AdapterSubscriptionStatus.Unsubscribed;
    };
    this.subscribe = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus = types.AdapterSubscriptionStatus.Subscribed;
    };
    this.id = types.adapterIdentifiers.http;
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState] = _objectSpread({}, intialAdapterState);
  }
  async configure(adapterArgs, adapterEventHandlers) {
    const handleFlagsChange = nextFlags => {
      if (_classPrivateFieldLooseBase(this, _getIsAdapterUnsubscribed)[_getIsAdapterUnsubscribed]()) return;
      adapterEventHandlers.onFlagsStateChange({
        flags: nextFlags,
        id: this.id
      });
    };
    const handleStatusChange = nextStatus => {
      if (_classPrivateFieldLooseBase(this, _getIsAdapterUnsubscribed)[_getIsAdapterUnsubscribed]()) return;
      adapterEventHandlers.onStatusStateChange({
        status: nextStatus,
        id: this.id
      });
    };
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on('flagsStateChange', handleFlagsChange);
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on('statusStateChange', handleStatusChange);
    this.setConfigurationStatus(types.AdapterConfigurationStatus.Configuring);
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user = adapterArgs.user;
    return Promise.resolve().then(async () => {
      let cachedFlags;
      if (adapterArgs.cacheIdentifier) {
        const cache = await _classPrivateFieldLooseBase(this, _getCache)[_getCache](adapterArgs.cacheIdentifier);
        cachedFlags = cache.get();
        if (cachedFlags) {
          _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags = cachedFlags;
          _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', cachedFlags);
        }
      }
      const flags = adapterUtilities.normalizeFlags(await _classPrivateFieldLooseBase(this, _fetchFlags)[_fetchFlags](adapterArgs));
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags = flags;
      this.setConfigurationStatus(types.AdapterConfigurationStatus.Configured);
      if (adapterArgs.cacheIdentifier) {
        const cache = await _classPrivateFieldLooseBase(this, _getCache)[_getCache](adapterArgs.cacheIdentifier);
        cache.set(flags);
      }
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', flags);
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit(_classPrivateFieldLooseBase(this, _internalConfiguredStatusChange__)[_internalConfiguredStatusChange__]);
      _classPrivateFieldLooseBase(this, _subscribeToFlagsChanges)[_subscribeToFlagsChanges](adapterArgs);
      return {
        initializationStatus: types.AdapterInitializationStatus.Succeeded
      };
    });
  }
  async reconfigure(adapterArgs, _adapterEventHandlers) {
    if (!this.getIsConfigurationStatus(types.AdapterConfigurationStatus.Configured)) return Promise.reject(new Error('@flopflip/http-adapter: please configure adapter before reconfiguring.'));
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags = {};
    if (adapterArgs.cacheIdentifier) {
      const cache = await _classPrivateFieldLooseBase(this, _getCache)[_getCache](adapterArgs.cacheIdentifier);
      cache.unset();
    }
    const nextUser = adapterArgs.user;
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user = nextUser;
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', {});
    return Promise.resolve({
      initializationStatus: types.AdapterInitializationStatus.Succeeded
    });
  }
  async waitUntilConfigured() {
    return new Promise(resolve => {
      if (this.getIsConfigurationStatus(types.AdapterConfigurationStatus.Configured)) resolve();else _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on(_classPrivateFieldLooseBase(this, _internalConfiguredStatusChange__)[_internalConfiguredStatusChange__], resolve);
    });
  }
  getIsConfigurationStatus(configurationStatus) {
    return _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus === configurationStatus;
  }
  getFlag(flagName) {
    var _classPrivateFieldLoo;
    return (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _adapterState)[_adapterState]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.flags[flagName];
  }
  setConfigurationStatus(nextConfigurationStatus) {
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus = nextConfigurationStatus;
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('statusStateChange', {
      configurationStatus: _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus
    });
  }
}
const adapter = new HttpAdapter();
adapterUtilities.exposeGlobally(adapter);

const version = "13.1.7";

exports["default"] = adapter;
exports.version = version;
