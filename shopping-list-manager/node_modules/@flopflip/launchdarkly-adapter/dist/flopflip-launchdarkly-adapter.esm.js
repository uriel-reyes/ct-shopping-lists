import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import _classPrivateFieldLooseBase from '@babel/runtime/helpers/esm/classPrivateFieldLooseBase';
import _classPrivateFieldLooseKey from '@babel/runtime/helpers/esm/classPrivateFieldLooseKey';
import { exposeGlobally, denormalizeFlagName, normalizeFlags, normalizeFlag } from '@flopflip/adapter-utilities';
import { AdapterSubscriptionStatus, AdapterConfigurationStatus, AdapterInitializationStatus, adapterIdentifiers } from '@flopflip/types';
import debounce from 'debounce-fn';
import { initialize } from 'launchdarkly-js-client-sdk';
import isEqual from 'lodash/isEqual';
import mitt from 'mitt';
import warning from 'tiny-warning';
import merge from 'ts-deepmerge';

var _adapterState = /*#__PURE__*/_classPrivateFieldLooseKey("adapterState");
var _updateFlagsInAdapterState = /*#__PURE__*/_classPrivateFieldLooseKey("updateFlagsInAdapterState");
var _getIsAdapterUnsubscribed = /*#__PURE__*/_classPrivateFieldLooseKey("getIsAdapterUnsubscribed");
var _getIsFlagUnsubcribed = /*#__PURE__*/_classPrivateFieldLooseKey("getIsFlagUnsubcribed");
var _getIsFlagLocked = /*#__PURE__*/_classPrivateFieldLooseKey("getIsFlagLocked");
var _withoutUnsubscribedOrLockedFlags = /*#__PURE__*/_classPrivateFieldLooseKey("withoutUnsubscribedOrLockedFlags");
var _getIsAnonymousContext = /*#__PURE__*/_classPrivateFieldLooseKey("getIsAnonymousContext");
var _ensureContext = /*#__PURE__*/_classPrivateFieldLooseKey("ensureContext");
var _initializeClient = /*#__PURE__*/_classPrivateFieldLooseKey("initializeClient");
var _changeClientContext = /*#__PURE__*/_classPrivateFieldLooseKey("changeClientContext");
var _getInitialFlags = /*#__PURE__*/_classPrivateFieldLooseKey("getInitialFlags");
var _didFlagChange = /*#__PURE__*/_classPrivateFieldLooseKey("didFlagChange");
var _setupFlagSubcription = /*#__PURE__*/_classPrivateFieldLooseKey("setupFlagSubcription");
class LaunchDarklyAdapter {
  constructor() {
    this.id = void 0;
    Object.defineProperty(this, _adapterState, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _updateFlagsInAdapterState, {
      writable: true,
      value: (flags, options) => {
        const updatedFlags = Object.entries(flags).reduce((updatedFlags, _ref) => {
          let _ref2 = _slicedToArray(_ref, 2),
            flagName = _ref2[0],
            flagValue = _ref2[1];
          if (_classPrivateFieldLooseBase(this, _getIsFlagLocked)[_getIsFlagLocked](flagName)) return updatedFlags;
          if (options !== null && options !== void 0 && options.lockFlags) {
            _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].lockedFlags.add(flagName);
          }
          if (options !== null && options !== void 0 && options.unsubscribeFlags) {
            _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].unsubscribedFlags.add(flagName);
          }
          updatedFlags = _objectSpread(_objectSpread({}, updatedFlags), {}, {
            [flagName]: flagValue
          });
          return updatedFlags;
        }, {});
        _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags = _objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags), updatedFlags);
      }
    });
    Object.defineProperty(this, _getIsAdapterUnsubscribed, {
      writable: true,
      value: () => _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus === AdapterSubscriptionStatus.Unsubscribed
    });
    Object.defineProperty(this, _getIsFlagUnsubcribed, {
      writable: true,
      value: flagName => _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].unsubscribedFlags.has(flagName)
    });
    Object.defineProperty(this, _getIsFlagLocked, {
      writable: true,
      value: flagName => _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].lockedFlags.has(flagName)
    });
    Object.defineProperty(this, _withoutUnsubscribedOrLockedFlags, {
      writable: true,
      value: flags => Object.fromEntries(Object.entries(flags).filter(_ref3 => {
        let _ref4 = _slicedToArray(_ref3, 1),
          flagName = _ref4[0];
        return !_classPrivateFieldLooseBase(this, _getIsFlagUnsubcribed)[_getIsFlagUnsubcribed](flagName) && !_classPrivateFieldLooseBase(this, _getIsFlagLocked)[_getIsFlagLocked](flagName);
      }))
    });
    Object.defineProperty(this, _getIsAnonymousContext, {
      writable: true,
      value: context => !(context !== null && context !== void 0 && context.key)
    });
    Object.defineProperty(this, _ensureContext, {
      writable: true,
      value: context => {
        const isAnonymousContext = _classPrivateFieldLooseBase(this, _getIsAnonymousContext)[_getIsAnonymousContext](context);

        // NOTE: When marked `anonymous` the SDK will generate a unique key and cache it in local storage
        return merge(context, {
          key: isAnonymousContext ? undefined : context.key,
          anonymous: isAnonymousContext
        });
      }
    });
    Object.defineProperty(this, _initializeClient, {
      writable: true,
      value: (clientSideId, context, options) => initialize(clientSideId, context, options)
    });
    Object.defineProperty(this, _changeClientContext, {
      writable: true,
      value: async nextContext => {
        var _classPrivateFieldLoo;
        return (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client) !== null && _classPrivateFieldLoo !== void 0 && _classPrivateFieldLoo.identify ? _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client.identify(nextContext) : Promise.reject(new Error('Can not change user context: client not yet initialized.'));
      }
    });
    Object.defineProperty(this, _getInitialFlags, {
      writable: true,
      value: async _ref5 => {
        let flags = _ref5.flags,
          throwOnInitializationFailure = _ref5.throwOnInitializationFailure;
        if (_classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client) {
          return _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client.waitForInitialization().then(async () => {
            let flagsFromSdk;
            if (_classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client && !flags) {
              flagsFromSdk = _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client.allFlags();
            } else if (_classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client && flags) {
              flagsFromSdk = {};
              for (const _ref6 of Object.entries(flags)) {
                var _ref7 = _slicedToArray(_ref6, 2);
                const requestedFlagName = _ref7[0];
                const defaultFlagValue = _ref7[1];
                const denormalizedRequestedFlagName = denormalizeFlagName(requestedFlagName);
                flagsFromSdk[denormalizedRequestedFlagName] = _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client.variation(denormalizedRequestedFlagName, defaultFlagValue);
              }
            }
            if (flagsFromSdk) {
              const normalizedFlags = normalizeFlags(flagsFromSdk);
              const flags = _classPrivateFieldLooseBase(this, _withoutUnsubscribedOrLockedFlags)[_withoutUnsubscribedOrLockedFlags](normalizedFlags);
              this.updateFlags(flags);
            }
            this.setConfigurationStatus(AdapterConfigurationStatus.Configured);
            return Promise.resolve({
              flagsFromSdk,
              initializationStatus: AdapterInitializationStatus.Succeeded
            });
          }).catch(async () => {
            if (throwOnInitializationFailure) return Promise.reject(new Error('@flopflip/launchdarkly-adapter: adapter failed to initialize.'));
            console.warn('@flopflip/launchdarkly-adapter: adapter failed to initialize.');
            return Promise.resolve({
              flagsFromSdk: undefined,
              initializationStatus: AdapterInitializationStatus.Failed
            });
          });
        }
        return Promise.reject(new Error('@flopflip/launchdarkly-adapter: can not subscribe with non initialized client.'));
      }
    });
    Object.defineProperty(this, _didFlagChange, {
      writable: true,
      value: (flagName, nextFlagValue) => {
        const previousFlagValue = this.getFlag(flagName);
        if (previousFlagValue === undefined) return true;
        return previousFlagValue !== nextFlagValue;
      }
    });
    Object.defineProperty(this, _setupFlagSubcription, {
      writable: true,
      value: _ref8 => {
        let flagsFromSdk = _ref8.flagsFromSdk,
          flagsUpdateDelayMs = _ref8.flagsUpdateDelayMs;
        for (const flagName in flagsFromSdk) {
          // Dispatch whenever a configured flag value changes
          if (Object.prototype.hasOwnProperty.call(flagsFromSdk, flagName) && _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client) {
            _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client.on(`change:${flagName}`, flagValue => {
              const _normalizeFlag = normalizeFlag(flagName, flagValue),
                _normalizeFlag2 = _slicedToArray(_normalizeFlag, 2),
                normalizedFlagName = _normalizeFlag2[0],
                normalizedFlagValue = _normalizeFlag2[1];
              if (_classPrivateFieldLooseBase(this, _getIsFlagUnsubcribed)[_getIsFlagUnsubcribed](normalizedFlagName)) return;

              // Sometimes the SDK flushes flag changes without a value having changed.
              if (!_classPrivateFieldLooseBase(this, _didFlagChange)[_didFlagChange](normalizedFlagName, normalizedFlagValue)) return;
              const updatedFlags = {
                [normalizedFlagName]: normalizedFlagValue
              };

              // NOTE: Adapter state needs to be updated outside of debounced-fn
              // so that no flag updates are lost.
              _classPrivateFieldLooseBase(this, _updateFlagsInAdapterState)[_updateFlagsInAdapterState](updatedFlags);
              const flushFlagsUpdate = () => {
                _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags);
              };
              const scheduleImmediately = {
                before: true,
                after: false
              };
              const scheduleTrailingEdge = {
                before: false,
                after: true
              };
              debounce(flushFlagsUpdate, _objectSpread({
                wait: flagsUpdateDelayMs
              }, flagsUpdateDelayMs ? scheduleTrailingEdge : scheduleImmediately))();
            });
          }
        }
      }
    });
    // External. Flags are autolocked when updated.
    this.updateFlags = (flags, options) => {
      _classPrivateFieldLooseBase(this, _updateFlagsInAdapterState)[_updateFlagsInAdapterState](flags, options);

      // ...and flush initial state of flags
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags);
    };
    this.unsubscribe = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus = AdapterSubscriptionStatus.Unsubscribed;
    };
    this.subscribe = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus = AdapterSubscriptionStatus.Subscribed;
    };
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState] = {
      subscriptionStatus: AdapterSubscriptionStatus.Subscribed,
      configurationStatus: AdapterConfigurationStatus.Unconfigured,
      context: undefined,
      client: undefined,
      flags: {},
      // Typings are incorrect and state that mitt is not callable.
      // Value of type 'MittStatic' is not callable. Did you mean to include 'new'
      emitter: mitt(),
      lockedFlags: new Set(),
      unsubscribedFlags: new Set()
    };
    this.id = adapterIdentifiers.launchdarkly;
  }
  async configure(adapterArgs, adapterEventHandlers) {
    var _sdk$clientOptions;
    const handleFlagsChange = nextFlags => {
      if (_classPrivateFieldLooseBase(this, _getIsAdapterUnsubscribed)[_getIsAdapterUnsubscribed]()) return;
      adapterEventHandlers.onFlagsStateChange({
        flags: nextFlags,
        id: this.id
      });
    };
    const handleStatusChange = nextStatus => {
      if (_classPrivateFieldLooseBase(this, _getIsAdapterUnsubscribed)[_getIsAdapterUnsubscribed]()) return;
      adapterEventHandlers.onStatusStateChange({
        status: nextStatus,
        id: this.id
      });
    };
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus = AdapterConfigurationStatus.Configuring;
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on('flagsStateChange', handleFlagsChange);
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on('statusStateChange', handleStatusChange);
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('statusStateChange', {
      configurationStatus: _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus
    });
    const sdk = adapterArgs.sdk,
      context = adapterArgs.context,
      flags = adapterArgs.flags,
      _adapterArgs$subscrib = adapterArgs.subscribeToFlagChanges,
      subscribeToFlagChanges = _adapterArgs$subscrib === void 0 ? true : _adapterArgs$subscrib,
      _adapterArgs$throwOnI = adapterArgs.throwOnInitializationFailure,
      throwOnInitializationFailure = _adapterArgs$throwOnI === void 0 ? false : _adapterArgs$throwOnI,
      flagsUpdateDelayMs = adapterArgs.flagsUpdateDelayMs;
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].context = _classPrivateFieldLooseBase(this, _ensureContext)[_ensureContext](context);
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client = _classPrivateFieldLooseBase(this, _initializeClient)[_initializeClient](sdk.clientSideId, _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].context, (_sdk$clientOptions = sdk.clientOptions) !== null && _sdk$clientOptions !== void 0 ? _sdk$clientOptions : {});
    return _classPrivateFieldLooseBase(this, _getInitialFlags)[_getInitialFlags]({
      flags,
      throwOnInitializationFailure
    }).then(_ref9 => {
      let flagsFromSdk = _ref9.flagsFromSdk,
        initializationStatus = _ref9.initializationStatus;
      if (subscribeToFlagChanges && flagsFromSdk) _classPrivateFieldLooseBase(this, _setupFlagSubcription)[_setupFlagSubcription]({
        flagsFromSdk,
        flagsUpdateDelayMs
      });
      return {
        initializationStatus
      };
    });
  }
  async reconfigure(adapterArgs, _adapterEventHandlers) {
    if (!this.getIsConfigurationStatus(AdapterConfigurationStatus.Configured)) return Promise.reject(new Error('@flopflip/launchdarkly-adapter: please configure adapter before reconfiguring.'));
    const nextContext = adapterArgs.context;
    if (!isEqual(_classPrivateFieldLooseBase(this, _adapterState)[_adapterState].context, nextContext)) {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].context = _classPrivateFieldLooseBase(this, _ensureContext)[_ensureContext](nextContext);
      await _classPrivateFieldLooseBase(this, _changeClientContext)[_changeClientContext](_classPrivateFieldLooseBase(this, _adapterState)[_adapterState].context);
      return Promise.resolve({
        initializationStatus: AdapterInitializationStatus.Succeeded
      });
    }
    return Promise.resolve({
      initializationStatus: AdapterInitializationStatus.Succeeded
    });
  }
  getIsConfigurationStatus(configurationStatus) {
    return _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus === configurationStatus;
  }
  setConfigurationStatus(nextConfigurationStatus) {
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus = nextConfigurationStatus;
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('statusStateChange', {
      configurationStatus: _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus
    });
  }
  getClient() {
    return _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].client;
  }
  getFlag(flagName) {
    return _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags[flagName];
  }
  async updateClientContext(updatedContextProps) {
    const isAdapterConfigured = this.getIsConfigurationStatus(AdapterConfigurationStatus.Configured);
    warning(isAdapterConfigured, '@flopflip/launchdarkly-adapter: adapter not configured. Client context can not be updated before.');
    if (!isAdapterConfigured) return Promise.reject(new Error('Can not update client context: adapter not yet configured.'));
    return _classPrivateFieldLooseBase(this, _changeClientContext)[_changeClientContext](_objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].context), updatedContextProps));
  }
}
const adapter = new LaunchDarklyAdapter();
exposeGlobally(adapter);

const version = "13.1.7";

export { adapter as default, version };
