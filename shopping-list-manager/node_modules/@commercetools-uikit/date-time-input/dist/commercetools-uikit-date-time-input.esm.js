import _Reflect$construct from '@babel/runtime-corejs3/core-js-stable/reflect/construct';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _classCallCheck from '@babel/runtime-corejs3/helpers/esm/classCallCheck';
import _createClass from '@babel/runtime-corejs3/helpers/esm/createClass';
import _inherits from '@babel/runtime-corejs3/helpers/esm/inherits';
import _possibleConstructorReturn from '@babel/runtime-corejs3/helpers/esm/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime-corejs3/helpers/esm/getPrototypeOf';
import _pt from 'prop-types';
import _concatInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/concat';
import _includesInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/includes';
import _fillInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/fill';
import _mapInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/map';
import { createRef, Component } from 'react';
import Downshift from 'downshift';
import { injectIntl } from 'react-intl';
import Constraints from '@commercetools-uikit/constraints';
import { parseTime, warning, filterDataAttributes } from '@commercetools-uikit/utils';
import { getToday, getDateInMonth, changeMonth, getStartOf, changeTime, createItemDateTimeToString, formatTime, createSuggestedItems, createCalendarItems, getPaddingDayCount, getWeekdayNames, getLocalizedDateTimeFormatPattern, parseInputText, getPreviousDay, getDaysInMonth, getMonthCalendarLabel, getYearCalendarLabel, isSameDay, getCalendarDayLabel } from '@commercetools-uikit/calendar-time-utils';
import { CalendarBody, CalendarMenu, CalendarHeader, CalendarContent, CalendarDay } from '@commercetools-uikit/calendar-utils';
import { css } from '@emotion/react';
import { designTokens } from '@commercetools-uikit/design-system';
import { jsx, jsxs } from '@emotion/react/jsx-runtime';

const getInputStyles = () => /*#__PURE__*/css("width:100%;text-align:center;border:0;border-top:1px solid ", designTokens.colorNeutral90, ";padding:10px 0;outline:0;font-size:", designTokens.fontSizeDefault, ";margin-top:", designTokens.spacing20, ";color:", designTokens.colorSolid, ";:disabled{background-color:", designTokens.colorSurface, ";}" + (process.env.NODE_ENV === "production" ? "" : ";label:getInputStyles;"), process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRpbWUtaW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU1nQyIsImZpbGUiOiJ0aW1lLWlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwiQGVtb3Rpb24vcmVhY3QvdHlwZXMvY3NzLXByb3BcIiAvPlxuaW1wb3J0IHR5cGUgeyBLZXlib2FyZEV2ZW50SGFuZGxlciwgUmVmT2JqZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgZGVzaWduVG9rZW5zIH0gZnJvbSAnQGNvbW1lcmNldG9vbHMtdWlraXQvZGVzaWduLXN5c3RlbSc7XG5pbXBvcnQgdHlwZSB7IFREYXRlVGltZUlucHV0UHJvcHMgfSBmcm9tICcuL2RhdGUtdGltZS1pbnB1dCc7XG5cbmNvbnN0IGdldElucHV0U3R5bGVzID0gKCkgPT4gY3NzYFxuICB3aWR0aDogMTAwJTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBib3JkZXI6IDA7XG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAke2Rlc2lnblRva2Vucy5jb2xvck5ldXRyYWw5MH07XG4gIHBhZGRpbmc6IDEwcHggMDtcbiAgb3V0bGluZTogMDtcbiAgZm9udC1zaXplOiAke2Rlc2lnblRva2Vucy5mb250U2l6ZURlZmF1bHR9O1xuICBtYXJnaW4tdG9wOiAke2Rlc2lnblRva2Vucy5zcGFjaW5nMjB9O1xuICBjb2xvcjogJHtkZXNpZ25Ub2tlbnMuY29sb3JTb2xpZH07XG5cbiAgOmRpc2FibGVkIHtcbiAgICAvKiBGaXhlcyBiYWNrZ3JvdW5kIGNvbG9yIGluIEZpcmVmb3ggKi9cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2Rlc2lnblRva2Vucy5jb2xvclN1cmZhY2V9O1xuICB9XG5gO1xuXG50eXBlIFREYXRlQ2FsZW5kYXJUaW1lSW5wdXRQcm9wcyA9IHtcbiAgdGltZUlucHV0UmVmOiBSZWZPYmplY3Q8SFRNTElucHV0RWxlbWVudD47XG4gIG9uS2V5RG93bjogS2V5Ym9hcmRFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59ICYgUGljazxcbiAgVERhdGVUaW1lSW5wdXRQcm9wcyxcbiAgJ2lzRGlzYWJsZWQnIHwgJ29uQ2hhbmdlJyB8ICd2YWx1ZScgfCAncGxhY2Vob2xkZXInXG4+O1xuXG5jb25zdCBEYXRlQ2FsZW5kYXJUaW1lSW5wdXQgPSAocHJvcHM6IFREYXRlQ2FsZW5kYXJUaW1lSW5wdXRQcm9wcykgPT4gKFxuICA8aW5wdXRcbiAgICBkaXNhYmxlZD17cHJvcHMuaXNEaXNhYmxlZH1cbiAgICByZWY9e3Byb3BzLnRpbWVJbnB1dFJlZn1cbiAgICB0eXBlPVwidGV4dFwiXG4gICAgdmFsdWU9e3Byb3BzLnZhbHVlfVxuICAgIG9uQ2hhbmdlPXtwcm9wcy5vbkNoYW5nZX1cbiAgICBvbktleURvd249e3Byb3BzLm9uS2V5RG93bn1cbiAgICBwbGFjZWhvbGRlcj17cHJvcHMucGxhY2Vob2xkZXJ9XG4gICAgY3NzPXtnZXRJbnB1dFN0eWxlcygpfVxuICAvPlxuKTtcblxuRGF0ZUNhbGVuZGFyVGltZUlucHV0LmRpc3BsYXlOYW1lID0gJ0RhdGVDYWxlbmRhclRpbWVJbnB1dCc7XG5cbmV4cG9ydCBkZWZhdWx0IERhdGVDYWxlbmRhclRpbWVJbnB1dDtcbiJdfQ== */");
const DateCalendarTimeInput = props => jsx("input", {
  disabled: props.isDisabled,
  ref: props.timeInputRef,
  type: "text",
  value: props.value,
  onChange: props.onChange,
  onKeyDown: props.onKeyDown,
  placeholder: props.placeholder,
  css: getInputStyles()
});
DateCalendarTimeInput.propTypes = process.env.NODE_ENV !== "production" ? {
  timeInputRef: _pt.any.isRequired,
  onKeyDown: _pt.func.isRequired
} : {};
DateCalendarTimeInput.displayName = 'DateCalendarTimeInput';
var TimeInput = DateCalendarTimeInput;

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context3, _context4; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
const activationTypes = [Downshift.stateChangeTypes.keyDownEnter, Downshift.stateChangeTypes.clickItem];
const preventDownshiftDefault = event => {
  event.nativeEvent.preventDownshiftDefault = true;
};

// This keeps the menu open when the user focuses the time input (thereby
// blurring the regular input/toggle button)
const createBlurHandler = timeInputRef => event => {
  event.persist();
  if (event.relatedTarget === timeInputRef.current) {
    preventDownshiftDefault(event);
  }
};
let DateTimeInput = /*#__PURE__*/function (_Component) {
  _inherits(DateTimeInput, _Component);
  var _super = _createSuper(DateTimeInput);
  function DateTimeInput() {
    var _this;
    _classCallCheck(this, DateTimeInput);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.inputRef = /*#__PURE__*/createRef();
    _this.timeInputRef = /*#__PURE__*/createRef();
    _this.state = {
      calendarDate: getToday(_this.props.timeZone),
      suggestedItems: [],
      highlightedIndex: _this.props.value === '' ? null : getDateInMonth(_this.props.value, _this.props.timeZone) - 1,
      timeString: ''
    };
    _this.jumpMonths = function (amount) {
      let dayToHighlight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      _this.setState(prevState => {
        const nextDate = changeMonth(prevState.calendarDate, _this.props.timeZone, amount);
        return {
          calendarDate: nextDate,
          highlightedIndex: dayToHighlight
        };
      });
    };
    _this.showToday = () => {
      const today = getToday(_this.props.timeZone);
      _this.setState(prevState => ({
        calendarDate: today,
        highlightedIndex: (prevState.suggestedItems || []).length + getDateInMonth(today, _this.props.timeZone) - 1
      }), () => {
        var _this$inputRef$curren;
        return (_this$inputRef$curren = _this.inputRef.current) === null || _this$inputRef$curren === void 0 ? void 0 : _this$inputRef$curren.focus();
      });
    };
    _this.handleBlur = () => {
      if (_this.props.onBlur) _this.props.onBlur({
        target: {
          id: _this.props.id,
          name: _this.props.name
        }
      });
    };
    _this.handleTimeChange = event => {
      const parsedTime = parseTime(event.target.value);
      _this.setState({
        timeString: event.target.value
      });

      // We can't update the parent when there is no value
      if (_this.props.value === '') return;
      let date = getStartOf(_this.props.value, _this.props.timeZone);
      if (parsedTime) {
        date = changeTime(date, _this.props.timeZone, parsedTime);
      }
      _this.emit(date);
    };
    _this.emit = value => {
      var _this$props$onChange, _this$props;
      return (_this$props$onChange = (_this$props = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props, {
        target: {
          id: _this.props.id,
          name: _this.props.name,
          // when cleared the value is null, but we always want it to be an
          // empty string when there is no value.
          value: value || ''
        }
      });
    };
    return _this;
  }
  _createClass(DateTimeInput, [{
    key: "render",
    value: function render() {
      var _context;
      if (!this.props.isReadOnly) {
        process.env.NODE_ENV !== "production" ? warning(typeof this.props.onChange === 'function', 'DateTimeInput: `onChange` is required when input is not read only.') : void 0;
      }
      return jsx(Constraints.Horizontal, {
        max: this.props.horizontalConstraint,
        children: jsx(Downshift
        // Setting the key to the timeZone conveniently forces a rerender
        // when the time-zone changes. Otherwise we'd need to make
        // inputValue a controlled property so that we can update
        // the displayed value as downshift seems to ignore an updated
        // itemToString function.
        , {
          inputId: this.props.id,
          itemToString: createItemDateTimeToString(this.props.intl.locale, this.props.timeZone),
          selectedItem: this.props.value === '' ? null : this.props.value,
          highlightedIndex: this.state.highlightedIndex,
          onChange: this.emit,
          stateReducer: (_, changes) => {
            if (_includesInstanceProperty(activationTypes).call(activationTypes, changes.type)) {
              return _objectSpread(_objectSpread({}, changes), {}, {
                isOpen: true
              });
            }
            return changes;
          },
          onStateChange: changes => {
            this.setState(prevState => {
              if (_includesInstanceProperty(activationTypes).call(activationTypes, changes.type)) {
                return {
                  startDate: changes.isOpen ? prevState.startDate : null,
                  inputValue: changes.inputValue || prevState.inputValue,
                  timeString: changes.selectedItem ? formatTime(changes.selectedItem, this.props.intl.locale, this.props.timeZone) : prevState.timeString
                };
              }
              if (changes.hasOwnProperty('inputValue')) {
                const suggestedItems = createSuggestedItems(changes.inputValue, this.props.timeZone);
                return {
                  suggestedItems,
                  highlightedIndex: suggestedItems.length > 0 ? 0 : null
                };
              }
              if (changes.hasOwnProperty('isOpen')) {
                return {
                  inputValue: changes.inputValue || prevState.inputValue,
                  startDate: changes.isOpen ? prevState.startDate : null,
                  // set time input value to time from value when menu is opened
                  timeString: changes.isOpen && this.props.value !== '' ? formatTime(this.props.value, this.props.intl.locale, this.props.timeZone) : '',
                  // ensure calendar always opens on selected item, or on
                  // current month when there is no selected item
                  calendarDate: this.props.value === '' ? getToday(this.props.timeZone) : this.props.value
                };
              }
              if (changes.hasOwnProperty('highlightedIndex')) {
                return {
                  highlightedIndex: changes.highlightedIndex
                };
              }
              return null;
            }, () => {
              if (_includesInstanceProperty(activationTypes).call(activationTypes, changes.type)) {
                var _this$timeInputRef$cu, _this$timeInputRef$cu2;
                (_this$timeInputRef$cu = this.timeInputRef.current) === null || _this$timeInputRef$cu === void 0 ? void 0 : _this$timeInputRef$cu.focus();
                (_this$timeInputRef$cu2 = this.timeInputRef.current) === null || _this$timeInputRef$cu2 === void 0 ? void 0 : _this$timeInputRef$cu2.setSelectionRange(0, this.state.timeString.length);
              }
            });
          },
          children: _ref => {
            var _context2;
            let getInputProps = _ref.getInputProps,
              getMenuProps = _ref.getMenuProps,
              getItemProps = _ref.getItemProps,
              getToggleButtonProps = _ref.getToggleButtonProps,
              clearSelection = _ref.clearSelection,
              highlightedIndex = _ref.highlightedIndex,
              openMenu = _ref.openMenu,
              closeMenu = _ref.closeMenu,
              setHighlightedIndex = _ref.setHighlightedIndex,
              selectedItem = _ref.selectedItem,
              inputValue = _ref.inputValue,
              isOpen = _ref.isOpen;
            const suggestedItems = this.state.suggestedItems;
            const calendarItems = createCalendarItems(this.state.calendarDate, this.state.timeString, this.props.timeZone);
            const paddingDayCount = getPaddingDayCount(this.state.calendarDate, this.props.intl.locale, this.props.timeZone);
            const paddingDays = _fillInstanceProperty(_context2 = Array(paddingDayCount)).call(_context2, undefined);
            const weekdays = getWeekdayNames(this.props.intl.locale);
            const today = getToday(this.props.timeZone);
            const isTimeInputVisible = Boolean(this.props.value) && this.props.value !== '';
            return jsxs("div", {
              onFocus: this.props.onFocus,
              onBlur: this.handleBlur,
              children: [jsx(CalendarBody, {
                inputRef: this.inputRef,
                inputProps: getInputProps(_objectSpread({
                  /* ARIA */
                  'aria-invalid': this.props['aria-invalid'],
                  'aria-errormessage': this.props['aria-errormessage'],
                  // Unset the aria-labelledby as it interfers with the link
                  // between the <label for> and the <input id>.
                  'aria-labelledby': undefined,
                  name: this.props.name,
                  placeholder: typeof this.props.placeholder === 'string' ? this.props.placeholder : getLocalizedDateTimeFormatPattern(this.props.intl.locale, 'full'),
                  onMouseEnter: () => {
                    // we remove the highlight so that the user can use the
                    // arrow keys to move the cursor when hovering
                    if (isOpen) setHighlightedIndex(-1);
                  },
                  onKeyDown: event => {
                    if (this.props.isReadOnly) {
                      preventDownshiftDefault(event);
                      return;
                    }
                    // parse input when user presses enter on regular input,
                    // close menu and notify parent
                    if (event.key === 'Enter' && highlightedIndex === null) {
                      preventDownshiftDefault(event);
                      const parsedDate = parseInputText(inputValue, this.props.intl.locale, this.props.timeZone);
                      this.emit(parsedDate);
                      closeMenu();
                    }
                    // ArrowDown
                    if (event.key === 'ArrowDown') {
                      if (Number(highlightedIndex) + 1 >= calendarItems.length) {
                        // if it's the end of the month
                        // then bypass normal arrow navigation
                        preventDownshiftDefault(event);
                        // then jump to start of next month
                        this.jumpMonths(1, 0);
                      }
                    }
                    // ArrowUp
                    if (event.key === 'ArrowUp') {
                      const previousDay = getPreviousDay(calendarItems[Number(highlightedIndex)]);
                      if (Number(highlightedIndex) <= 0) {
                        // if it's the start of the month
                        // then bypass normal arrow navigation
                        preventDownshiftDefault(event);
                        const numberOfDaysOfPrevMonth = getDaysInMonth(previousDay, this.props.timeZone);
                        // then jump to the last day of the previous month
                        this.jumpMonths(-1, numberOfDaysOfPrevMonth - 1);
                      }
                    }
                  },
                  onClick: this.props.isReadOnly ? undefined : openMenu,
                  onBlur: createBlurHandler(this.timeInputRef),
                  onChange: event => {
                    var _event$target$value;
                    // keep timeInput and regular input in sync when user
                    // types into regular input
                    if (!isOpen) return;
                    const time = (_event$target$value = event.target.value) === null || _event$target$value === void 0 ? void 0 : _event$target$value.split(' ')[1];
                    if (!time) return;
                    const parsedTime = parseTime(time);
                    this.setState(() => {
                      if (!parsedTime) return {
                        timeString: ''
                      };
                      let date = getToday(this.props.timeZone);
                      if (parsedTime) {
                        date = changeTime(date, this.props.timeZone, parsedTime);
                      }
                      return {
                        timeString: formatTime(date, this.props.intl.locale, this.props.timeZone)
                      };
                    });
                  }
                }, filterDataAttributes(this.props))),
                hasSelection: Boolean(selectedItem),
                onClear: clearSelection,
                isOpen: isOpen,
                isDisabled: this.props.isDisabled,
                isReadOnly: this.props.isReadOnly,
                toggleButtonProps: getToggleButtonProps({
                  onBlur: createBlurHandler(this.timeInputRef)
                }),
                hasError: this.props.hasError,
                hasWarning: this.props.hasWarning
              }), isOpen && !this.props.isDisabled && jsxs(CalendarMenu, _objectSpread(_objectSpread({}, getMenuProps()), {}, {
                hasFooter: true,
                hasError: this.props.hasError,
                hasWarning: this.props.hasWarning,
                children: [jsx(CalendarHeader, {
                  monthLabel: getMonthCalendarLabel(this.state.calendarDate, this.props.intl.locale),
                  yearLabel: getYearCalendarLabel(this.state.calendarDate, this.props.intl.locale),
                  onPrevMonthClick: () => this.jumpMonths(-1),
                  onTodayClick: this.showToday,
                  onNextMonthClick: () => this.jumpMonths(1),
                  onPrevYearClick: () => this.jumpMonths(-12),
                  onNextYearClick: () => this.jumpMonths(12)
                }), jsxs(CalendarContent, {
                  children: [_mapInstanceProperty(weekdays).call(weekdays, weekday => jsx(CalendarDay, {
                    type: "heading",
                    children: weekday
                  }, weekday)), _mapInstanceProperty(paddingDays).call(paddingDays, (_, index) => jsx(CalendarDay, {
                    type: "spacing"
                  }, index)), _mapInstanceProperty(calendarItems).call(calendarItems, (item, index) => jsx(CalendarDay, _objectSpread(_objectSpread({
                    isToday: isSameDay(today, item)
                  }, getItemProps({
                    disabled: this.props.isDisabled,
                    item,
                    onMouseOut: () => {
                      setHighlightedIndex(-1);
                    }
                  })), {}, {
                    isHighlighted: suggestedItems.length + index === highlightedIndex,
                    isSelected: isSameDay(item, this.props.value),
                    children: getCalendarDayLabel(item, this.props.timeZone)
                  }), item))]
                }), jsx(TimeInput, {
                  isDisabled: !isTimeInputVisible,
                  timeInputRef: this.timeInputRef,
                  placeholder: getLocalizedDateTimeFormatPattern(this.props.intl.locale, 'time'),
                  value: this.state.timeString,
                  onChange: this.handleTimeChange,
                  onKeyDown: event => {
                    if (event.key === 'ArrowUp') {
                      var _this$inputRef$curren2;
                      setHighlightedIndex(-1);
                      (_this$inputRef$curren2 = this.inputRef.current) === null || _this$inputRef$curren2 === void 0 ? void 0 : _this$inputRef$curren2.focus();
                      return;
                    }
                    if (event.key === 'Enter') {
                      var _this$inputRef$curren3, _this$inputRef$curren4;
                      setHighlightedIndex(-1);
                      (_this$inputRef$curren3 = this.inputRef.current) === null || _this$inputRef$curren3 === void 0 ? void 0 : _this$inputRef$curren3.focus();
                      (_this$inputRef$curren4 = this.inputRef.current) === null || _this$inputRef$curren4 === void 0 ? void 0 : _this$inputRef$curren4.setSelectionRange(0, 100);
                      closeMenu();
                    }
                  }
                })]
              }))]
            });
          }
        }, _concatInstanceProperty(_context = "".concat(this.props.timeZone, ":")).call(_context, this.props.intl.locale))
      });
    }
  }]);
  return DateTimeInput;
}(Component);
DateTimeInput.displayName = 'DateTimeInput';
DateTimeInput.propTypes = process.env.NODE_ENV !== "production" ? {
  'aria-invalid': _pt.bool,
  'aria-errormessage': _pt.string,
  horizontalConstraint: _pt.oneOf([6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 'scale', 'auto']),
  value: _pt.string.isRequired,
  onChange: _pt.func,
  onFocus: _pt.func,
  onBlur: _pt.func,
  timeZone: _pt.string.isRequired,
  id: _pt.string,
  name: _pt.string,
  placeholder: _pt.string,
  isDisabled: _pt.bool,
  isReadOnly: _pt.bool,
  hasError: _pt.bool,
  hasWarning: _pt.bool
} : {};
var dateTimeInput = injectIntl(DateTimeInput);

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

export { dateTimeInput as default, version };
