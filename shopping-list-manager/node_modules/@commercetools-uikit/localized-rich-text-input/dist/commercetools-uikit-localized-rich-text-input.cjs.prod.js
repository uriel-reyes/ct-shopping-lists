'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var _slicedToArray = require('@babel/runtime-corejs3/helpers/slicedToArray');
var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
var _reduceInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/reduce');
var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _concatInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/concat');
var _Map = require('@babel/runtime-corejs3/core-js-stable/map');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _mapInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/map');
var react = require('react');
var Stack = require('@commercetools-uikit/spacings-stack');
var Constraints = require('@commercetools-uikit/constraints');
var hooks = require('@commercetools-uikit/hooks');
var localizedUtils = require('@commercetools-uikit/localized-utils');
var inputUtils = require('@commercetools-uikit/input-utils');
var richTextUtils = require('@commercetools-uikit/rich-text-utils');
var utils = require('@commercetools-uikit/utils');
var _Reflect$construct = require('@babel/runtime-corejs3/core-js-stable/reflect/construct');
var _classCallCheck = require('@babel/runtime-corejs3/helpers/classCallCheck');
var _createClass = require('@babel/runtime-corejs3/helpers/createClass');
var _inherits = require('@babel/runtime-corejs3/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime-corejs3/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime-corejs3/helpers/getPrototypeOf');
require('prop-types');
var _styled = require('@emotion/styled/base');
var react$1 = require('@emotion/react');
var reactIntl = require('react-intl');
var designSystem = require('@commercetools-uikit/design-system');
var CollapsibleMotion = require('@commercetools-uikit/collapsible-motion');
var icons = require('@commercetools-uikit/icons');
var Text = require('@commercetools-uikit/text');
var FlatButton = require('@commercetools-uikit/flat-button');
var slateReact = require('slate-react');
var slate = require('slate');
var slateHistory = require('slate-history');
var isHotkey = require('is-hotkey');
var pipe = require('lodash/fp/pipe');
var jsxRuntime = require('@emotion/react/jsx-runtime');
var messages = require('@commercetools-uikit/messages');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var _reduceInstanceProperty__default = /*#__PURE__*/_interopDefault(_reduceInstanceProperty);
var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _concatInstanceProperty__default = /*#__PURE__*/_interopDefault(_concatInstanceProperty);
var _Map__default = /*#__PURE__*/_interopDefault(_Map);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _mapInstanceProperty__default = /*#__PURE__*/_interopDefault(_mapInstanceProperty);
var Stack__default = /*#__PURE__*/_interopDefault(Stack);
var Constraints__default = /*#__PURE__*/_interopDefault(Constraints);
var _Reflect$construct__default = /*#__PURE__*/_interopDefault(_Reflect$construct);
var _styled__default = /*#__PURE__*/_interopDefault(_styled);
var CollapsibleMotion__default = /*#__PURE__*/_interopDefault(CollapsibleMotion);
var Text__default = /*#__PURE__*/_interopDefault(Text);
var FlatButton__default = /*#__PURE__*/_interopDefault(FlatButton);
var isHotkey__default = /*#__PURE__*/_interopDefault(isHotkey);
var pipe__default = /*#__PURE__*/_interopDefault(pipe);

const getEditorLanguageLabelBorderColor = props => "1px solid ".concat(props.isReadOnly ? designSystem.designTokens.borderColorForInputWhenReadonly : designSystem.designTokens.borderColorForInputWhenDisabled);
const getBackgroundColor = props => {
  if (props.isDisabled) {
    return designSystem.designTokens.backgroundColorForInputWhenDisabled;
  }
  if (props.isReadOnly) {
    return designSystem.designTokens.backgroundColorForInputWhenDisabled;
  }
  return designSystem.designTokens.backgroundColorForInput;
};
const EditorLanguageLabel = /*#__PURE__*/_styled__default["default"]("label", {
  target: "ew063c2"
} )("white-space:nowrap;flex:0;color:", designSystem.designTokens.fontColorForInputWhenDisabled, ";line-height:calc(\n    ", designSystem.designTokens.sizeHeightInput, " - 2 * ", designSystem.designTokens.borderRadius1, "\n  );background-color:", props => getBackgroundColor(props), ";border-top-left-radius:", designSystem.designTokens.borderRadiusForInput, ";border-bottom-left-radius:", designSystem.designTokens.borderRadiusForInput, ";border:", props => getEditorLanguageLabelBorderColor(props), ";padding:", designSystem.designTokens.paddingForLocalizedRichTextInputLabel, ";transition:border-color ", designSystem.designTokens.transitionStandard, ",background-color ", designSystem.designTokens.transitionStandard, ",color ", designSystem.designTokens.transitionStandard, ";border-right:0;box-shadow:none;appearance:none;display:flex;align-items:center;cursor:inherit;" + ("" ));
const EditorWrapper = /*#__PURE__*/_styled__default["default"]("div", {
  target: "ew063c1"
} )("width:100%;position:relative;display:flex;cursor:", props => props.isDisabled || props.isReadOnly ? 'not-allowed' : 'inherit', ";" + ("" ));
const ToggleButtonWrapper = /*#__PURE__*/_styled__default["default"]("div", {
  target: "ew063c0"
} )({
  name: "ejz79s",
  styles: "flex:0;display:flex"
} );

function ownKeys$3(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys$3(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys$3(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const HOTKEYS = {
  'mod+b': 'bold',
  'mod+i': 'italic',
  'mod+u': 'underline',
  'mod+`': 'code'
};
const COLLAPSED_HEIGHT = 32;
const LeftColumn = /*#__PURE__*/_styled__default["default"]("div", {
  target: "el9zors2"
} )({
  name: "147rp59",
  styles: "flex:1;display:flex;align-items:flex-start"
} );
const RightColumn = /*#__PURE__*/_styled__default["default"]("div", {
  target: "el9zors1"
} )({
  name: "1m04uhl",
  styles: "position:relative;flex:0;display:flex;align-items:flex-start"
} );
const Row = /*#__PURE__*/_styled__default["default"]("div", {
  target: "el9zors0"
} )({
  name: "skgbeu",
  styles: "display:flex;justify-content:flex-end"
} );
const renderElement = props => jsxRuntime.jsx(richTextUtils.Element, _objectSpread$3({}, props));
const renderLeaf = props => jsxRuntime.jsx(richTextUtils.Leaf, _objectSpread$3({}, props));
var _ref = {
  name: "bcltzc",
  styles: "flex:auto;width:0;border-top-left-radius:0;border-bottom-left-radius:0"
} ;
const Editor = /*#__PURE__*/react.forwardRef((props, forwardedRef) => {
  const intl = reactIntl.useIntl();
  const ref = react.useRef();
  const createEditorWithPlugins = pipe__default["default"](slateReact.withReact, slateHistory.withHistory);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const editor = react.useMemo(() => createEditorWithPlugins(slate.createEditor()), []);
  if (props.showExpandIcon) ;
  const _useState = react.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    renderToggleButton = _useState2[0],
    setRenderToggleButton = _useState2[1];
  const toggleLanguage = props.toggleLanguage;
  const onToggle = react.useCallback(() => {
    toggleLanguage(props.language);
  }, [toggleLanguage, props.language]);
  const updateRenderToggleButton = react.useCallback(() => {
    var _ref$current;
    const doesExceedCollapsedHeightLimit = Number((_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.clientHeight) > COLLAPSED_HEIGHT;
    if (doesExceedCollapsedHeightLimit && !renderToggleButton) {
      setRenderToggleButton(true);
    }
    if (!doesExceedCollapsedHeightLimit && renderToggleButton) {
      setRenderToggleButton(false);
    }
  }, [setRenderToggleButton, renderToggleButton]);
  react.useEffect(() => {
    updateRenderToggleButton();
  }, [editor, updateRenderToggleButton]);

  // resetting
  const resetValue = react.useCallback(newValue => {
    var _newValue$props$langu;
    const newStringValue = typeof newValue === 'string' ? newValue : (_newValue$props$langu = newValue === null || newValue === void 0 ? void 0 : newValue[props.language]) !== null && _newValue$props$langu !== void 0 ? _newValue$props$langu : '';
    richTextUtils.resetEditor(editor, newStringValue);
  }, [editor, props.language]);
  /*
  Resetting the editor requires access to `editor` object returned from `useSlate` hook.
  Therefore, `reset` function is attached to the passed `ref` object via `useImperativeHandle`
  to be called from the parent component.
  e.g. <button onMouseDown={() => ref.current?.resetValue("<p><strong>Value after reset</strong></p>")}>Reset</button>
  */
  react.useImperativeHandle(forwardedRef, () => {
    return {
      resetValue
    };
  });
  const shouldToggleButtonTakeSpace =
  /*
    - if hasLanguagesControl and there are no errors/warnings to display
    - then the toggleButton is absolutely positioned
    This is because the toggle button is placed next to the LocalizedInputToggle without being siblings in the DOM.
    If there is a error or warning showing,
    then it can be placed statically because it will then be a sibling to the error/warning message
    and LocalizedInputToggle is placed below the errors/warnings.
  */

  renderToggleButton && !props.hasLanguagesControl || props.error || props.warning;
  return jsxRuntime.jsx(CollapsibleMotion__default["default"], {
    minHeight: COLLAPSED_HEIGHT,
    isClosed: !props.isOpen,
    onToggle: onToggle,
    isDefaultClosed: !props.defaultExpandMultilineText,
    children: _ref2 => {
      let isOpen = _ref2.isOpen,
        toggle = _ref2.toggle,
        containerStyles = _ref2.containerStyles,
        registerContentNode = _ref2.registerContentNode;
      const refObj = {
        containerRef: ref,
        registerContentNode
      };
      return jsxRuntime.jsxs(Stack__default["default"], {
        scale: "xs",
        children: [jsxRuntime.jsx(EditorWrapper, {
          isDisabled: props.isDisabled,
          isReadOnly: props.isReadOnly,
          children: jsxRuntime.jsxs(slateReact.Slate, {
            editor: editor,
            value: props.value,
            onChange: props.onChange,
            children: [jsxRuntime.jsx(EditorLanguageLabel, {
              htmlFor: props.id,
              isDisabled: props.isDisabled,
              isReadOnly: props.isReadOnly,
              children: jsxRuntime.jsx(Text__default["default"].Detail, {
                tone: "secondary",
                children: props.language.toUpperCase()
              })
            }), jsxRuntime.jsxs(richTextUtils.RichTextBody
            // @ts-ignore
            , {
              ref: refObj,
              styles: {
                container: _ref
              },
              hasError: props.hasError,
              isDisabled: props.isDisabled,
              hasWarning: props.hasWarning,
              isReadOnly: Boolean(props.isReadOnly),
              showExpandIcon: Boolean(props.showExpandIcon),
              onClickExpand: props.onClickExpand,
              containerStyles: containerStyles,
              children: [jsxRuntime.jsx(slateReact.Editable, _objectSpread$3(_objectSpread$3({}, utils.filterDataAttributes(props)), {}, {
                name: props.name,
                renderElement: renderElement,
                renderLeaf: renderLeaf,
                placeholder: props.placeholder,
                autoFocus: props.isAutofocused,
                onBlur: props.onBlur,
                onFocus: event => {
                  var _props$onFocus;
                  (_props$onFocus = props.onFocus) === null || _props$onFocus === void 0 ? void 0 : _props$onFocus.call(props, event);
                  // opens the input if it regains focus and it's closed
                  if (!isOpen) {
                    toggle();
                    richTextUtils.focusEditor(editor);
                  }
                },
                readOnly: props.isReadOnly,
                disabled: props.isDisabled,
                onKeyDown: event => {
                  for (const hotkey in HOTKEYS) {
                    if (isHotkey__default["default"](hotkey, event)) {
                      event.preventDefault();
                      const mark = HOTKEYS[hotkey];
                      richTextUtils.toggleMark(editor, mark);
                      break;
                    }
                  }
                }
              })), props.children, jsxRuntime.jsx(richTextUtils.HiddenInput, {
                isFocused: slateReact.ReactEditor.isFocused(editor),
                handleFocus: () => {
                  richTextUtils.focusEditor(editor);
                },
                id: props.id,
                disabled: props.isDisabled,
                readOnly: props.isReadOnly
              })]
            })]
          })
        }, props.language), jsxRuntime.jsxs(Row
        // NOTE: applying this style withing the `styled` component results in the production
        // bundle to apply the style in the wrong order.
        // For instance, we need to override the marging of the spacing component, which also
        // uses `!important`.
        // Anyway, apparently by passing the style as a `css` prop to the `styled` component
        // does the trick.
        // TODO: revisit the logic and the implementation to maybe avoid having to apply this style.
        , {
          css: /*#__PURE__*/react$1.css("margin-top:", shouldToggleButtonTakeSpace ? 'inherit' : '0px !important', ";" + ("" ), "" ),
          children: [(() => {
            if (props.error) return jsxRuntime.jsx(LeftColumn, {
              children: jsxRuntime.jsx("div", {
                children: props.error
              })
            });
            if (props.warning) return jsxRuntime.jsx(LeftColumn, {
              children: jsxRuntime.jsx("div", {
                children: props.warning
              })
            });
            return null;
          })(), renderToggleButton && jsxRuntime.jsx(RightColumn, {
            children: jsxRuntime.jsx(ToggleButtonWrapper, {
              css: [!shouldToggleButtonTakeSpace && /*#__PURE__*/react$1.css("position:absolute;top:0;right:0;margin-top:", designSystem.designTokens.spacing10, ";" + ("" ), "" ), "" , "" ],
              children: jsxRuntime.jsx(FlatButton__default["default"], {
                onClick: toggle,
                label: intl.formatMessage(isOpen ? inputUtils.messagesMultilineInput.collapse : inputUtils.messagesMultilineInput.expand),
                icon: isOpen ? jsxRuntime.jsx(icons.AngleUpIcon, {
                  size: "small"
                }) : jsxRuntime.jsx(icons.AngleDownIcon, {
                  size: "small"
                })
              })
            })
          })]
        })]
      });
    }
  });
});
Editor.displayName = 'Editor';
var Editor$1 = Editor;

function ownKeys$2(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys$2(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys$2(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct__default["default"](Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct__default["default"]) return false; if (_Reflect$construct__default["default"].sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct__default["default"](Boolean, [], function () {})); return true; } catch (e) { return false; } }
let RichTextInput = /*#__PURE__*/function (_PureComponent) {
  _inherits(RichTextInput, _PureComponent);
  var _super = _createSuper(RichTextInput);
  function RichTextInput() {
    var _this;
    _classCallCheck(this, RichTextInput);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.serializedValue = _this.props.value || '';
    _this.internalSlateValue = richTextUtils.validSlateStateAdapter(richTextUtils.html.deserialize(_this.props.value || ''));
    _this.onValueChange = state => {
      const serializedValue = richTextUtils.html.serialize(state);

      // because we are not using setState, we need to make sure that
      // we perform an update when the slate value changes
      // as this can contain things like cursor location
      // in this case, the internalSlateValue would change
      // but the serializedValue would NOT change.
      const hasInternalSlateValueChanged = _this.internalSlateValue !== state;
      const hasSerializedValueChanged = serializedValue !== _this.serializedValue;
      _this.internalSlateValue = richTextUtils.validSlateStateAdapter(state);
      _this.serializedValue = serializedValue;

      // the consumer only cares about the serializedValue, so it doesn't make sense to call
      // onChange unless this value changes.
      if (hasSerializedValueChanged) {
        var _this$props$onChange, _this$props;
        (_this$props$onChange = (_this$props = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props, richTextUtils.html.serialize(state));
      }
      if (hasInternalSlateValueChanged && !hasSerializedValueChanged) {
        // this way we force update if cursor or selection changes
        _this.forceUpdate();
      }
    };
    return _this;
  }
  _createClass(RichTextInput, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.props.value !== this.serializedValue) {
        this.internalSlateValue = richTextUtils.validSlateStateAdapter(richTextUtils.html.deserialize(this.props.value));
        this.serializedValue = this.props.value;
        this.forceUpdate();
      }
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.props.isReadOnly) ;
      if (this.props.showExpandIcon) ;
      return jsxRuntime.jsx(Editor$1, _objectSpread$2(_objectSpread$2({}, utils.filterDataAttributes(this.props)), {}, {
        name: this.props.name,
        isReadOnly: this.props.isReadOnly,
        onChange: this.onValueChange,
        id: this.props.id,
        value: this.internalSlateValue,
        onFocus: this.props.onFocus,
        onBlur: this.props.onBlur,
        isDisabled: this.props.isDisabled,
        defaultExpandMultilineText: this.props.defaultExpandMultilineText,
        hasWarning: this.props.hasWarning,
        hasError: this.props.hasError,
        placeholder: this.props.placeholder,
        showExpandIcon: this.props.showExpandIcon,
        onClickExpand: this.props.onClickExpand,
        language: this.props.language,
        toggleLanguage: this.props.toggleLanguage,
        isOpen: this.props.isOpen,
        warning: this.props.warning,
        error: this.props.error,
        hasLanguagesControl: this.props.hasLanguagesControl,
        ref: this.props.parentRef
      }));
    }
  }]);
  return RichTextInput;
}(react.PureComponent);
RichTextInput.defaultProps = {
  defaultExpandMultilineText: false,
  placeholder: ''
};
RichTextInput.displayName = 'RichTextInput';
RichTextInput.propTypes = {};
const RichTextInputWithRef = /*#__PURE__*/react.forwardRef((props, ref) => jsxRuntime.jsx(RichTextInput, _objectSpread$2({
  parentRef: ref
}, props)));
RichTextInputWithRef.displayName = 'RichTextInputWithRef';
var RichTextInput$1 = RichTextInputWithRef;

function ownKeys$1(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys$1(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys$1(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const RequiredValueErrorMessage = () => jsxRuntime.jsx(messages.ErrorMessage, {
  children: jsxRuntime.jsx(reactIntl.FormattedMessage, _objectSpread$1({}, inputUtils.messagesLocalizedInput.missingRequiredField))
});
RequiredValueErrorMessage.displayName = 'RequiredValueErrorMessage';
var RequiredValueErrorMessage$1 = RequiredValueErrorMessage;

function ownKeys(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context6, _context7; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context6 = ownKeys(Object(source), !0)).call(_context6, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context7 = ownKeys(Object(source))).call(_context7, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const defaultProps = {
  horizontalConstraint: 'scale',
  showExpandIcon: false
};
const expandedTranslationsReducer = (state, action) => {
  switch (action.type) {
    case 'toggle':
      return _objectSpread(_objectSpread({}, state), {}, {
        [action.payload]: !state[action.payload]
      });
    case 'toggleAll':
      {
        var _context;
        const newState = _reduceInstanceProperty__default["default"](_context = _Object$keys__default["default"](state)).call(_context, (translations, locale) => {
          return _objectSpread({
            [locale]: true
          }, translations);
        }, {});
        return newState;
      }
    default:
      return state;
  }
};

// This component supports expanding/collapsing rich text inputs, but it also
// supports showing/hiding the remaining languages.
// These two features are both about opening/closing something, and so the code
// can get quite confusing. We try to stick to expand/collapse for the
// multiline inputs, while we use show/hide/open/close for the remaining
// languages.
const LocalizedRichTextInput = /*#__PURE__*/react.forwardRef((props, ref) => {
  var _context2;
  if (!props.isReadOnly) ;
  if (props.showExpandIcon) ;
  if (props.hideLanguageExpansionControls) ;
  const initialExpandedTranslationsState = _reduceInstanceProperty__default["default"](_context2 = _Object$keys__default["default"](props.value)).call(_context2, (translations, locale) => _objectSpread(_objectSpread({}, translations), {}, {
    [locale]: Boolean(props.defaultExpandMultilineText)
  }), {});
  const _useReducer = react.useReducer(expandedTranslationsReducer, initialExpandedTranslationsState),
    _useReducer2 = _slicedToArray(_useReducer, 2),
    expandedTranslationsState = _useReducer2[0],
    expandedTranslationsDispatch = _useReducer2[1];
  const defaultExpansionState = Boolean(props.hideLanguageExpansionControls || props.defaultExpandLanguages);
  const _useToggleState = hooks.useToggleState(defaultExpansionState),
    _useToggleState2 = _slicedToArray(_useToggleState, 2),
    areLanguagesOpened = _useToggleState2[0],
    toggleLanguages = _useToggleState2[1];
  const toggleLanguage = react.useCallback(language => {
    expandedTranslationsDispatch({
      type: 'toggle',
      payload: language
    });
  }, [expandedTranslationsDispatch]);
  const createChangeHandler = react.useCallback(language => state => {
    var _props$onChange, _context3, _context4;
    (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, {
      target: {
        id: props !== null && props !== void 0 && props.id ? _concatInstanceProperty__default["default"](_context3 = "".concat(props.id, ".")).call(_context3, language) : '',
        name: props !== null && props !== void 0 && props.name ? _concatInstanceProperty__default["default"](_context4 = "".concat(props.name, ".")).call(_context4, language) : '',
        language,
        value: state
      }
    });
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [props.id, props.name, props.onChange]);
  const languages = localizedUtils.sortLanguages(props.selectedLanguage, _Object$keys__default["default"](props.value));
  const hasErrorInRemainingLanguages = props.hasError || localizedUtils.getHasErrorOnRemainingLanguages(props.errors, props.selectedLanguage);
  const hasWarningInRemainingLanguages = props.hasWarning || localizedUtils.getHasWarningOnRemainingLanguages(props.warnings, props.selectedLanguage);
  if (hasErrorInRemainingLanguages || hasWarningInRemainingLanguages) {
    if (!areLanguagesOpened) {
      // this update within render replaces the old `getDerivedStateFromProps` functionality
      // https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops
      toggleLanguages();
    }
  }
  const langRefs = react.useRef(new _Map__default["default"]());
  const resetValue = react.useCallback(newValue => {
    var _context5;
    _forEachInstanceProperty__default["default"](_context5 = langRefs.current).call(_context5, langRef => {
      langRef === null || langRef === void 0 ? void 0 : langRef.resetValue(newValue);
    });
  }, []);
  react.useImperativeHandle(ref, () => {
    return {
      resetValue
    };
  });
  const shouldRenderLanguagesControl = languages.length > 1 && !props.hideLanguageExpansionControls;
  return jsxRuntime.jsx(Constraints__default["default"].Horizontal, {
    max: props.horizontalConstraint,
    children: jsxRuntime.jsxs(Stack__default["default"], {
      scale: "xs",
      children: [jsxRuntime.jsx(Stack__default["default"], {
        children: _mapInstanceProperty__default["default"](languages).call(languages, (language, index) => {
          const isFirstLanguage = index === 0;
          if (!isFirstLanguage && !areLanguagesOpened) return null;
          const isLastLanguage = index === languages.length - 1;
          const hasLanguagesControl = isFirstLanguage && !areLanguagesOpened || isLastLanguage;
          return react$1.createElement(RichTextInput$1, _objectSpread(_objectSpread({}, utils.filterDataAttributes(props)), {}, {
            key: language,
            id: localizedUtils.getId(props.id, language),
            name: localizedUtils.getName(props.name, language),
            value: props.value[language],
            onChange: createChangeHandler(language),
            language: language,
            isOpen: expandedTranslationsState[language],
            toggleLanguage: toggleLanguage,
            placeholder: props.placeholder ? props.placeholder[language] : undefined,
            onBlur: props.onBlur,
            onFocus: props.onFocus,
            isDisabled: props.isDisabled,
            isReadOnly: props.isReadOnly,
            hasError: Boolean(props.hasError || props.errors && props.errors[language]),
            hasWarning: Boolean(props.hasWarning || props.warnings && props.warnings[language]),
            warning: props.warnings && props.warnings[language],
            error: props.errors && props.errors[language],
            showExpandIcon: props.showExpandIcon,
            onClickExpand: props.onClickExpand,
            hasLanguagesControl: hasLanguagesControl,
            defaultExpandMultilineText: Boolean(props.defaultExpandMultilineText),
            ref: el => langRefs.current.set(language, el)
          }, localizedUtils.createLocalizedDataAttributes(props, language)));
        })
      }), shouldRenderLanguagesControl && jsxRuntime.jsx(inputUtils.LocalizedInputToggle, {
        isOpen: areLanguagesOpened,
        onClick: toggleLanguages,
        isDisabled: areLanguagesOpened && Boolean(hasErrorInRemainingLanguages || hasWarningInRemainingLanguages),
        remainingLocalizations: languages.length - 1
      })]
    })
  });
});
LocalizedRichTextInput.displayName = 'LocalizedRichTextInput';
LocalizedRichTextInput.RequiredValueErrorMessage = RequiredValueErrorMessage$1;
LocalizedRichTextInput.getId = localizedUtils.getId;
LocalizedRichTextInput.getName = localizedUtils.getName;
LocalizedRichTextInput.defaultProps = defaultProps;
LocalizedRichTextInput.createLocalizedString = richTextUtils.localized.createLocalizedString;
LocalizedRichTextInput.isEmpty = richTextUtils.localized.isEmpty;
LocalizedRichTextInput.omitEmptyTranslations = richTextUtils.localized.omitEmptyTranslations;
LocalizedRichTextInput.isTouched = localizedUtils.isTouched;
var LocalizedRichTextInput$1 = LocalizedRichTextInput;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

exports["default"] = LocalizedRichTextInput$1;
exports.version = version;
