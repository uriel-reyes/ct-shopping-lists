import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import _pt from 'prop-types';
import 'react';
import isNil from 'lodash/isNil';
import { warning } from '@commercetools-uikit/utils';
import { useToggleState } from '@commercetools-uikit/hooks';
import { jsx, Fragment } from '@emotion/react/jsx-runtime';

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const ControlledCollapsible = props => jsx(Fragment, {
  children: props.children({
    isOpen: !props.isClosed,
    toggle: props.onToggle
  })
});
ControlledCollapsible.displayName = 'ControlledCollapsible';
const UncontrolledCollapsible = props => {
  const _useToggleState = useToggleState(!props.isDefaultClosed),
    _useToggleState2 = _slicedToArray(_useToggleState, 2),
    isOpen = _useToggleState2[0],
    toggle = _useToggleState2[1];
  return jsx(Fragment, {
    children: props.children({
      isOpen,
      toggle
    })
  });
};
UncontrolledCollapsible.displayName = 'UncontrolledCollapsible';
const Collapsible = props => {
  const isControlledComponent = !isNil(props.isClosed);
  const hasOnToggle = !isNil(props.onToggle);
  if (isControlledComponent) {
    process.env.NODE_ENV !== "production" ? warning(hasOnToggle, "ui-kit/Collapsible: missing required prop \"onToggle\" when using the \"isClosed\" prop (controlled component).") : void 0;
    return jsx(ControlledCollapsible, _objectSpread({}, props));
  }
  process.env.NODE_ENV !== "production" ? warning(!hasOnToggle, "ui-kit/Collapsible: the prop \"onToggle\" does not have any effect (uncontrolled component). Please remove it.") : void 0;
  return jsx(UncontrolledCollapsible, _objectSpread({}, props));
};
Collapsible.propTypes = process.env.NODE_ENV !== "production" ? {
  isDefaultClosed: _pt.bool,
  children: _pt.func.isRequired,
  isClosed: _pt.bool,
  onToggle: _pt.func
} : {};
Collapsible.displayName = 'Collapsible';
const collapsibleDefaultProps = {
  isDefaultClosed: false
};
Collapsible.defaultProps = collapsibleDefaultProps;
var Collapsible$1 = Collapsible;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

export { Collapsible$1 as default, version };
