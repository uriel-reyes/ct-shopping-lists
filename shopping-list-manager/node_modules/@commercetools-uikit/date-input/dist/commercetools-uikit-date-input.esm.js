import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import _pt from 'prop-types';
import _fillInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/fill';
import _trimInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/trim';
import _mapInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/map';
import { useState, useRef, useCallback } from 'react';
import Downshift from 'downshift';
import { useIntl } from 'react-intl';
import Constraints from '@commercetools-uikit/constraints';
import { warning, filterDataAttributes } from '@commercetools-uikit/utils';
import { getToday, getDateInMonth, createItemToString, parseInputToDate, getIsDateInRange, createCalendarItems, getPaddingDayCount, getWeekdayNames, CalendarBody, getNextDay, getPreviousDay, getDaysInMonth, CalendarMenu, CalendarHeader, getMonthCalendarLabel, getYearCalendarLabel, CalendarContent, CalendarDay, isSameDay, getCalendarDayLabel, changeMonth } from '@commercetools-uikit/calendar-utils';
import { getLocalizedDateTimeFormatPattern } from '@commercetools-uikit/calendar-time-utils';
import { jsx, jsxs } from '@emotion/react/jsx-runtime';

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context2, _context3; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context2 = ownKeys(Object(source), !0)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context3 = ownKeys(Object(source))).call(_context3, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const preventDownshiftDefault = event => {
  event.nativeEvent.preventDownshiftDefault = true;
};
const DateInput = props => {
  const intl = useIntl();
  const _useState = useState(props.value || getToday()),
    _useState2 = _slicedToArray(_useState, 2),
    calendarDate = _useState2[0],
    setCalendarDate = _useState2[1];
  const _useState3 = useState([]),
    _useState4 = _slicedToArray(_useState3, 2),
    suggestedItems = _useState4[0],
    setSuggestedItems = _useState4[1];
  const _useState5 = useState(props.value === '' ? null : getDateInMonth(props.value) - 1),
    _useState6 = _slicedToArray(_useState5, 2),
    highlightedIndex = _useState6[0],
    setHighlightedIndex = _useState6[1];
  const inputRef = useRef(null);
  if (!props.isReadOnly) {
    process.env.NODE_ENV !== "production" ? warning(typeof props.onChange === 'function', 'DateInput: `onChange` is required when input is not read only.') : void 0;
  }
  const onChange = props.onChange;
  const emit = useCallback(value => onChange === null || onChange === void 0 ? void 0 : onChange({
    target: {
      id: props.id,
      name: props.name,
      // when cleared the value is null, but we always want it to be an
      // empty string when there is no value.
      value: value || ''
    }
  }), [onChange, props.id, props.name]);
  const handleChange = useCallback(date => {
    var _inputRef$current;
    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.setSelectionRange(0, 100);
    emit(date);
  }, [inputRef, emit]);
  const onBlur = props.onBlur;
  const handleBlur = useCallback(() => {
    if (onBlur) onBlur({
      target: {
        id: props.id,
        name: props.name
      }
    });
  }, [onBlur, props.id, props.name]);
  const showToday = () => {
    var _inputRef$current2;
    const today = getToday();
    setCalendarDate(today);
    setHighlightedIndex(suggestedItems.length + getDateInMonth(today) - 1);
    (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.focus();
  };
  const jumpMonth = function (amount) {
    let dayToHighlight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const nextDate = changeMonth(calendarDate, amount);
    setCalendarDate(nextDate);
    setHighlightedIndex(dayToHighlight);
  };
  return jsx(Constraints.Horizontal, {
    max: props.horizontalConstraint,
    children: jsx(Downshift, {
      inputId: props.id,
      itemToString: createItemToString(intl.locale),
      selectedItem: props.value === '' ? null : props.value,
      highlightedIndex: highlightedIndex,
      onChange: handleChange,
      onStateChange: changes => {
        if (changes.hasOwnProperty('inputValue')) {
          // input changed because user typed
          if (changes.type === Downshift.stateChangeTypes.changeInput) {
            const date = parseInputToDate(changes.inputValue, intl.locale);
            if (date === '') {
              setSuggestedItems([]);
              setHighlightedIndex(null);
            } else {
              setSuggestedItems([date]);
              if (getIsDateInRange(date, props.minValue, props.maxValue)) {
                setHighlightedIndex(getDateInMonth(date) - 1);
              }
              setCalendarDate(date);
            }
          } else {
            // input changed because user selected a date
            setSuggestedItems([]);
            setHighlightedIndex(null);
          }
          /**
           * Asides the inputValue, we also have other ways to enter calendar inputs like the mouse move event to enter calender values.
           * We check the downshift changes property to be sure it has highlightedIndex That is not null before updating it,
           * otherwise it may override the initially set highlightedIndex from the inputValue and set it to null.
           */
        } else if (changes.hasOwnProperty('highlightedIndex')) {
          setHighlightedIndex(changes.highlightedIndex);
        }
      },
      children: _ref => {
        var _context;
        let getInputProps = _ref.getInputProps,
          getMenuProps = _ref.getMenuProps,
          getItemProps = _ref.getItemProps,
          getToggleButtonProps = _ref.getToggleButtonProps,
          clearSelection = _ref.clearSelection,
          downshiftHighlightedIndex = _ref.highlightedIndex,
          openMenu = _ref.openMenu,
          setDownshiftHighlightedIndex = _ref.setHighlightedIndex,
          selectedItem = _ref.selectedItem,
          isOpen = _ref.isOpen,
          inputValue = _ref.inputValue;
        const calendarItems = createCalendarItems(calendarDate);
        const paddingDayCount = getPaddingDayCount(calendarDate, intl.locale);
        const paddingDays = _fillInstanceProperty(_context = Array(paddingDayCount)).call(_context, undefined);
        const weekdays = getWeekdayNames(intl.locale);
        const today = getToday();
        return jsxs("div", {
          onFocus: props.onFocus,
          onBlur: handleBlur,
          children: [jsx(CalendarBody, {
            inputRef: inputRef,
            inputProps: getInputProps(_objectSpread({
              /* ARIA */
              'aria-invalid': props['aria-invalid'],
              'aria-errormessage': props['aria-errormessage'],
              // Unset the aria-labelledby as it interfers with the link
              // between the <label for> and the <input id>.
              'aria-labelledby': undefined,
              name: props.name,
              placeholder: typeof props.placeholder === 'string' ? props.placeholder : getLocalizedDateTimeFormatPattern(intl.locale),
              onMouseEnter: () => {
                // we remove the highlight so that the user can use the
                // arrow keys to move the cursor when hovering
                // @ts-ignore
                if (isOpen) setDownshiftHighlightedIndex(null);
              },
              onKeyDown: event => {
                if (props.isReadOnly) {
                  preventDownshiftDefault(event);
                  return;
                }
                if (event.key === 'Enter' && (inputValue === null || inputValue === void 0 ? void 0 : _trimInstanceProperty(inputValue).call(inputValue)) === '') {
                  clearSelection();
                }
                // ArrowDown
                if (event.key === 'ArrowDown') {
                  const nextDayToHighlight = getNextDay(calendarItems[Number(highlightedIndex)]);
                  if (!getIsDateInRange(nextDayToHighlight, props.minValue, props.maxValue)) {
                    // if the date to highlight is disabled
                    // then do nothing
                    preventDownshiftDefault(event);
                    return;
                  }
                  if (Number(highlightedIndex) + 1 >= calendarItems.length) {
                    // if it's the end of the month
                    // then bypass normal arrow navigation
                    preventDownshiftDefault(event);
                    // then jump to start of next month
                    jumpMonth(1, 0);
                  }
                }
                // ArrowUp
                if (event.key === 'ArrowUp') {
                  const previousDay = getPreviousDay(calendarItems[Number(highlightedIndex)]);
                  if (!getIsDateInRange(previousDay, props.minValue, props.maxValue)) {
                    // if the date to highlight is disabled
                    // then do nothing
                    preventDownshiftDefault(event);
                    return;
                  }
                  if (Number(highlightedIndex) <= 0) {
                    // if it's the start of the month
                    // then bypass normal arrow navigation
                    preventDownshiftDefault(event);
                    const numberOfDaysOfPrevMonth = getDaysInMonth(previousDay);
                    // then jump to the last day of the previous month
                    jumpMonth(-1, numberOfDaysOfPrevMonth - 1);
                  }
                }
              },
              // we only do this for readOnly because the input
              // doesn't ignore these events, unlike when its disabled
              onClick: props.isReadOnly ? undefined : openMenu
            }, filterDataAttributes(props))),
            hasSelection: Boolean(selectedItem),
            onClear: clearSelection,
            isOpen: isOpen,
            isDisabled: props.isDisabled,
            isReadOnly: props.isReadOnly,
            toggleButtonProps: getToggleButtonProps(),
            hasError: props.hasError,
            hasWarning: props.hasWarning
          }), isOpen && !props.isDisabled && !props.isReadOnly && jsxs(CalendarMenu, _objectSpread(_objectSpread({}, getMenuProps()), {}, {
            hasError: props.hasError,
            hasWarning: props.hasWarning,
            children: [jsx(CalendarHeader, {
              monthLabel: getMonthCalendarLabel(calendarDate, intl.locale),
              yearLabel: getYearCalendarLabel(calendarDate, intl.locale),
              onPrevMonthClick: () => jumpMonth(-1),
              onTodayClick: showToday,
              onNextMonthClick: () => jumpMonth(1),
              onPrevYearClick: () => jumpMonth(-12),
              onNextYearClick: () => jumpMonth(12)
            }), jsxs(CalendarContent, {
              children: [_mapInstanceProperty(weekdays).call(weekdays, weekday => jsx(CalendarDay, {
                type: "heading",
                children: weekday
              }, weekday)), _mapInstanceProperty(paddingDays).call(paddingDays, (_, index) => jsx(CalendarDay, {
                type: "spacing"
              }, index)), _mapInstanceProperty(calendarItems).call(calendarItems, (item, index) => jsx(CalendarDay, _objectSpread(_objectSpread({
                isToday: isSameDay(today, item)
              }, getItemProps({
                disabled: !getIsDateInRange(item, props.minValue, props.maxValue),
                item,
                onMouseOut: () => {
                  // @ts-ignore
                  setDownshiftHighlightedIndex(null);
                }
              })), {}, {
                isHighlighted: index === downshiftHighlightedIndex,
                isSelected: isSameDay(item, props.value),
                children: getCalendarDayLabel(item)
              }), item))]
            })]
          }))]
        });
      }
    }, intl.locale)
  });
};
DateInput.propTypes = process.env.NODE_ENV !== "production" ? {
  horizontalConstraint: _pt.oneOf([6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 'scale', 'auto']),
  value: _pt.string.isRequired,
  onChange: _pt.func,
  onFocus: _pt.func,
  onBlur: _pt.func,
  id: _pt.string,
  'aria-invalid': _pt.bool,
  'aria-errormessage': _pt.string,
  name: _pt.string,
  placeholder: _pt.string,
  isDisabled: _pt.bool,
  isReadOnly: _pt.bool,
  hasError: _pt.bool,
  hasWarning: _pt.bool,
  minValue: _pt.string,
  maxValue: _pt.string
} : {};
DateInput.displayName = 'DateInput';
DateInput.isEmpty = value => value === '';
var DateInput$1 = DateInput;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

export { DateInput$1 as default, version };
