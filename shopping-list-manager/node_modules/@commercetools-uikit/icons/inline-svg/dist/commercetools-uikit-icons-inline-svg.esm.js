import _pt from 'prop-types';
import { useMemo, cloneElement, isValidElement } from 'react';
import DOMPurify from 'dompurify';
import convert from 'react-from-dom';
import { css, ClassNames } from '@emotion/react';
import { warning, canUseDOM } from '@commercetools-uikit/utils';
import _concatInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/concat';
import { designTokens } from '@commercetools-uikit/design-system';
import { jsx } from '@emotion/react/jsx-runtime';

const iconSizes = {
  small: 12,
  medium: 16,
  big: 24
};
const getSizeDimensions = size => {
  switch (size) {
    case 'scale':
      return {
        width: '100%',
        height: 'auto'
      };
    case 'small':
    case 'medium':
    case 'big':
      return {
        width: "".concat(iconSizes[size], "px"),
        height: "".concat(iconSizes[size], "px")
      };
    default:
      return {
        width: "".concat(iconSizes.big, "px"),
        height: "".concat(iconSizes.big, "px")
      };
  }
};
const getSizeStyle = size => {
  var _context, _context2;
  const dimensions = getSizeDimensions(size);
  switch (size) {
    case 'scale':
      return _concatInstanceProperty(_context = "\n        &:not(:root) {\n          width: ".concat(dimensions.width, ";\n          height: ")).call(_context, dimensions.height, ";\n        }\n      ");
    default:
      return _concatInstanceProperty(_context2 = "\n        width: ".concat(dimensions.width, ";\n        height: ")).call(_context2, dimensions.height, ";\n      ");
  }
};
const getColor = color => {
  if (!color) return 'inherit';
  let iconColor;
  switch (color) {
    case 'solid':
      iconColor = designTokens.colorSolid;
      break;
    case 'neutral60':
      iconColor = designTokens.colorNeutral60;
      break;
    case 'surface':
      iconColor = designTokens.colorSurface;
      break;
    case 'info':
      iconColor = designTokens.colorInfo;
      break;
    case 'primary':
      iconColor = designTokens.colorPrimary;
      break;
    case 'primary40':
      iconColor = designTokens.colorPrimary40;
      break;
    case 'warning':
      iconColor = designTokens.colorWarning;
      break;
    case 'error':
      iconColor = designTokens.colorError;
      break;
  }
  if (!iconColor) {
    process.env.NODE_ENV !== "production" ? warning(color, "ui-kit/Icon: the specified color '".concat(color, "' is not supported.")) : void 0;
    return 'inherit';
  }
  return iconColor;
};

// @ts-ignore
const getIconStyles = props => /*#__PURE__*/css("*:not([fill='none']){fill:", getColor(props.color), ";}&,image{", getSizeStyle(props.size), ";}flex-shrink:0;" + (process.env.NODE_ENV === "production" ? "" : ";label:getIconStyles;"), process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImljb24uc3R5bGVzLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFvR2tEIiwiZmlsZSI6Imljb24uc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHsgd2FybmluZyB9IGZyb20gJ0Bjb21tZXJjZXRvb2xzLXVpa2l0L3V0aWxzJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IGNzcywgQ2xhc3NOYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCB7IGRlc2lnblRva2VucyB9IGZyb20gJ0Bjb21tZXJjZXRvb2xzLXVpa2l0L2Rlc2lnbi1zeXN0ZW0nO1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IHtcbiAgY29sb3I/OlxuICAgIHwgJ3NvbGlkJ1xuICAgIHwgJ25ldXRyYWw2MCdcbiAgICB8ICdzdXJmYWNlJ1xuICAgIHwgJ2luZm8nXG4gICAgfCAncHJpbWFyeSdcbiAgICB8ICdwcmltYXJ5NDAnXG4gICAgfCAnd2FybmluZydcbiAgICB8ICdlcnJvcic7XG4gIHNpemU/OiAnc21hbGwnIHwgJ21lZGl1bScgfCAnYmlnJyB8ICdzY2FsZSc7XG59O1xuZXhwb3J0IHR5cGUgU1ZHUHJvcHMgPSBQcm9wcyAmIHsgY2xhc3NOYW1lOiBzdHJpbmcgfTtcblxuY29uc3QgaWNvblNpemVzID0ge1xuICBzbWFsbDogMTIsXG4gIG1lZGl1bTogMTYsXG4gIGJpZzogMjQsXG59IGFzIGNvbnN0O1xuY29uc3QgZ2V0U2l6ZURpbWVuc2lvbnMgPSAoc2l6ZTogUHJvcHNbJ3NpemUnXSkgPT4ge1xuICBzd2l0Y2ggKHNpemUpIHtcbiAgICBjYXNlICdzY2FsZSc6XG4gICAgICByZXR1cm4geyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICdhdXRvJyB9O1xuICAgIGNhc2UgJ3NtYWxsJzpcbiAgICBjYXNlICdtZWRpdW0nOlxuICAgIGNhc2UgJ2JpZyc6XG4gICAgICByZXR1cm4geyB3aWR0aDogYCR7aWNvblNpemVzW3NpemVdfXB4YCwgaGVpZ2h0OiBgJHtpY29uU2l6ZXNbc2l6ZV19cHhgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IHdpZHRoOiBgJHtpY29uU2l6ZXMuYmlnfXB4YCwgaGVpZ2h0OiBgJHtpY29uU2l6ZXMuYmlnfXB4YCB9O1xuICB9XG59O1xuY29uc3QgZ2V0U2l6ZVN0eWxlID0gKHNpemU6IFByb3BzWydzaXplJ10pID0+IHtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGdldFNpemVEaW1lbnNpb25zKHNpemUpO1xuICBzd2l0Y2ggKHNpemUpIHtcbiAgICBjYXNlICdzY2FsZSc6XG4gICAgICByZXR1cm4gYFxuICAgICAgICAmOm5vdCg6cm9vdCkge1xuICAgICAgICAgIHdpZHRoOiAke2RpbWVuc2lvbnMud2lkdGh9O1xuICAgICAgICAgIGhlaWdodDogJHtkaW1lbnNpb25zLmhlaWdodH07XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBgXG4gICAgICAgIHdpZHRoOiAke2RpbWVuc2lvbnMud2lkdGh9O1xuICAgICAgICBoZWlnaHQ6ICR7ZGltZW5zaW9ucy5oZWlnaHR9O1xuICAgICAgYDtcbiAgfVxufTtcblxuY29uc3QgZ2V0Q29sb3IgPSAoY29sb3I6IFByb3BzWydjb2xvciddKSA9PiB7XG4gIGlmICghY29sb3IpIHJldHVybiAnaW5oZXJpdCc7XG5cbiAgbGV0IGljb25Db2xvcjtcbiAgc3dpdGNoIChjb2xvcikge1xuICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgIGljb25Db2xvciA9IGRlc2lnblRva2Vucy5jb2xvclNvbGlkO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbmV1dHJhbDYwJzpcbiAgICAgIGljb25Db2xvciA9IGRlc2lnblRva2Vucy5jb2xvck5ldXRyYWw2MDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N1cmZhY2UnOlxuICAgICAgaWNvbkNvbG9yID0gZGVzaWduVG9rZW5zLmNvbG9yU3VyZmFjZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2luZm8nOlxuICAgICAgaWNvbkNvbG9yID0gZGVzaWduVG9rZW5zLmNvbG9ySW5mbztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ByaW1hcnknOlxuICAgICAgaWNvbkNvbG9yID0gZGVzaWduVG9rZW5zLmNvbG9yUHJpbWFyeTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ByaW1hcnk0MCc6XG4gICAgICBpY29uQ29sb3IgPSBkZXNpZ25Ub2tlbnMuY29sb3JQcmltYXJ5NDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIGljb25Db2xvciA9IGRlc2lnblRva2Vucy5jb2xvcldhcm5pbmc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICBpY29uQ29sb3IgPSBkZXNpZ25Ub2tlbnMuY29sb3JFcnJvcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmICghaWNvbkNvbG9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGNvbG9yLFxuICAgICAgYHVpLWtpdC9JY29uOiB0aGUgc3BlY2lmaWVkIGNvbG9yICcke2NvbG9yfScgaXMgbm90IHN1cHBvcnRlZC5gXG4gICAgKTtcbiAgICByZXR1cm4gJ2luaGVyaXQnO1xuICB9XG5cbiAgcmV0dXJuIGljb25Db2xvcjtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBnZXRJY29uU3R5bGVzID0gKHByb3BzOiBQcm9wcykgPT4gY3NzYFxuICAqOm5vdChbZmlsbD0nbm9uZSddKSB7XG4gICAgZmlsbDogJHtnZXRDb2xvcihwcm9wcy5jb2xvcil9O1xuICB9XG4gICYsXG4gIGltYWdlIHtcbiAgICAke2dldFNpemVTdHlsZShwcm9wcy5zaXplKX07XG4gIH1cbiAgZmxleC1zaHJpbms6IDA7XG5gO1xuIl19 */");

const InlineSvg = props => {
  const sanitized = useMemo(() => {
    if (!canUseDOM) {
      return props.data;
    }
    return DOMPurify.sanitize(props.data, {
      USE_PROFILES: {
        svg: true
      },
      RETURN_DOM: true,
      FORBID_ATTR: [
      // To avoid injection by using `style="filter:url(\"data:image/svg+xml,<svg`
      'style']
    }).innerHTML;
  }, [props.data]);
  const svgElement = useStringToReactElement(sanitized);
  if (svgElement) {
    return jsx(ClassNames, {
      children: _ref => {
        let css = _ref.css;
        return /*#__PURE__*/cloneElement(svgElement, {
          className: css(getIconStyles(props))
        });
      }
    });
  }
  return null;
};
InlineSvg.propTypes = process.env.NODE_ENV !== "production" ? {
  data: _pt.string.isRequired
} : {};
var InlineSvg$1 = InlineSvg;

// Inspired by https://github.com/gilbarbara/react-inlinesvg
function useStringToReactElement(data) {
  return useMemo(() => {
    if (!canUseDOM) {
      return null;
    }
    try {
      const node = convert(data, {
        nodeOnly: true
      });
      if (!node || !(node instanceof SVGSVGElement)) {
        throw new Error('Could not convert the string to a DOM node');
      }
      const element = convert(node);
      if (!element || ! /*#__PURE__*/isValidElement(element)) {
        throw new Error('Could not convert the DOM node to a React element');
      }
      return element;
    } catch (error) {
      console.error(error);
      return null;
    }
  }, [data]);
}

export { InlineSvg$1 as default };
