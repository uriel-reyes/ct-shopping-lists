import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import _pt from 'prop-types';
import _someInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/some';
import _Object$values from '@babel/runtime-corejs3/core-js-stable/object/values';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import { isValidElement } from 'react';
import { defineMessages, useIntl } from 'react-intl';
import { createSequentialId, warning, filterDataAttributes } from '@commercetools-uikit/utils';
import { useToggleState, useFieldId } from '@commercetools-uikit/hooks';
import Constraints from '@commercetools-uikit/constraints';
import Inline from '@commercetools-uikit/spacings-inline';
import Stack from '@commercetools-uikit/spacings-stack';
import FieldLabel from '@commercetools-uikit/field-label';
import PasswordInput from '@commercetools-uikit/password-input';
import FlatButton from '@commercetools-uikit/flat-button';
import { EyeCrossedIcon, EyeIcon } from '@commercetools-uikit/icons';
import FieldErrors from '@commercetools-uikit/field-errors';
import { jsx, jsxs } from '@emotion/react/jsx-runtime';

var messages = defineMessages({
  show: {
    id: 'UIKit.PasswordField.show',
    description: 'Label for the button to show the password',
    defaultMessage: 'show'
  },
  hide: {
    id: 'UIKit.PasswordField.hide',
    description: 'Label for the button to hide the password',
    defaultMessage: 'hide'
  }
});

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context2, _context3; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context2 = ownKeys(Object(source), !0)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context3 = ownKeys(Object(source))).call(_context3, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const sequentialId = createSequentialId('password-field-');
const sequentialErrorsId = createSequentialId('password-field-error-')();

// Similar shape of `FormikErrors` but values are `TFieldErrors` objects.

const hasErrors = errors => {
  var _context;
  return errors && _someInstanceProperty(_context = _Object$values(errors)).call(_context, Boolean);
};
const defaultProps = {
  horizontalConstraint: 'scale'
};
const PasswordField = props => {
  const intl = useIntl();
  const _useToggleState = useToggleState(false),
    _useToggleState2 = _slicedToArray(_useToggleState, 2),
    isPasswordVisible = _useToggleState2[0],
    togglePasswordVisibility = _useToggleState2[1];
  const id = useFieldId(props.id, sequentialId);
  const hasError = props.touched && hasErrors(props.errors);
  if (!props.isReadOnly) {
    process.env.NODE_ENV !== "production" ? warning(Boolean(props.onChange), 'PasswordField: `onChange` is required when field is not read only.') : void 0;
  }
  if (props.hintIcon) {
    process.env.NODE_ENV !== "production" ? warning(typeof props.hint === 'string' || /*#__PURE__*/isValidElement(props.hint), 'PasswordField: `hint` is required to be string or ReactNode if hintIcon is present') : void 0;
  }
  return jsx(Constraints.Horizontal, {
    max: props.horizontalConstraint,
    children: jsxs(Stack, {
      scale: "xs",
      children: [jsxs(Inline, {
        alignItems: "flex-end",
        justifyContent: "space-between",
        children: [jsx(FieldLabel, {
          hint: props.hint,
          title: props.title,
          badge: props.badge,
          htmlFor: id,
          hintIcon: props.hintIcon,
          description: props.description,
          onInfoButtonClick: props.onInfoButtonClick,
          hasRequiredIndicator: props.isRequired
        }), !props.isDisabled && !props.isReadOnly && jsx(FlatButton, {
          icon: isPasswordVisible ? jsx(EyeCrossedIcon, {}) : jsx(EyeIcon, {}),
          label: isPasswordVisible ? intl.formatMessage(messages.hide) : intl.formatMessage(messages.show),
          onClick: togglePasswordVisibility,
          isDisabled: !props.value
        })]
      }), jsx(PasswordInput, _objectSpread(_objectSpread({
        id: id,
        name: props.name,
        value: props.value,
        onChange: props.onChange,
        onBlur: props.onBlur,
        onFocus: props.onFocus,
        isAutofocussed: props.isAutofocussed,
        isPasswordVisible: isPasswordVisible,
        isDisabled: props.isDisabled,
        isReadOnly: props.isReadOnly,
        hasError: hasError,
        placeholder: props.placeholder,
        autoComplete: props.autoComplete,
        horizontalConstraint: "scale"
      }, filterDataAttributes(props)), {}, {
        /* ARIA */
        "aria-invalid": hasError,
        "aria-errormessage": sequentialErrorsId
      })), jsx(FieldErrors, {
        id: sequentialErrorsId,
        errors: props.errors,
        isVisible: hasError,
        renderError: props.renderError
      })]
    })
  });
};
PasswordField.propTypes = process.env.NODE_ENV !== "production" ? {
  id: _pt.string,
  horizontalConstraint: _pt.oneOf([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 'scale', 'auto']),
  errors: _pt.objectOf(_pt.bool),
  renderError: _pt.func,
  isRequired: _pt.bool,
  touched: _pt.bool,
  name: _pt.string,
  value: _pt.string.isRequired,
  onChange: _pt.func,
  onBlur: _pt.func,
  onFocus: _pt.func,
  isAutofocussed: _pt.bool,
  isDisabled: _pt.bool,
  isReadOnly: _pt.bool,
  placeholder: _pt.string,
  autoComplete: _pt.oneOf(['on', 'off', 'current-password', 'new-password']),
  title: _pt.oneOfType([_pt.string, _pt.node]).isRequired,
  hint: _pt.oneOfType([_pt.string, _pt.node]),
  description: _pt.oneOfType([_pt.string, _pt.node]),
  onInfoButtonClick: _pt.func,
  hintIcon: _pt.element,
  badge: _pt.node
} : {};
PasswordField.displayName = 'PasswordField';
PasswordField.defaultProps = defaultProps;
/**
 * Use this function to convert the Formik `errors` object type to
 * our custom field errors type.
 * This is primarly useful when using TypeScript.
 */
PasswordField.toFieldErrors = function toFieldErrors(errors) {
  return errors;
};
var PasswordField$1 = PasswordField;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

export { PasswordField$1 as default, version };
