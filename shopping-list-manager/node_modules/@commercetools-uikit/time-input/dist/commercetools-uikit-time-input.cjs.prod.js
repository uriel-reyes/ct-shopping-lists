'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
require('prop-types');
var _padStartInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/pad-start');
var _concatInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/concat');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var react$1 = require('react');
var reactIntl = require('react-intl');
var Constraints = require('@commercetools-uikit/constraints');
var utils = require('@commercetools-uikit/utils');
var hooks = require('@commercetools-uikit/hooks');
var icons = require('@commercetools-uikit/icons');
var Inline = require('@commercetools-uikit/spacings-inline');
var AccessibleButton = require('@commercetools-uikit/accessible-button');
var _styled = require('@emotion/styled/base');
var react = require('@emotion/react');
var designSystem = require('@commercetools-uikit/design-system');
var inputUtils = require('@commercetools-uikit/input-utils');
var jsxRuntime = require('@emotion/react/jsx-runtime');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _padStartInstanceProperty__default = /*#__PURE__*/_interopDefault(_padStartInstanceProperty);
var _concatInstanceProperty__default = /*#__PURE__*/_interopDefault(_concatInstanceProperty);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var Constraints__default = /*#__PURE__*/_interopDefault(Constraints);
var Inline__default = /*#__PURE__*/_interopDefault(Inline);
var AccessibleButton__default = /*#__PURE__*/_interopDefault(AccessibleButton);
var _styled__default = /*#__PURE__*/_interopDefault(_styled);

// NOTE: order is important here
// * a disabled-field currently does not display warning/error-states so it takes precedence
// * a readonly-field cannot be changed, but it might be relevant for validation, so error and warning are checked first
// how you can interact with the field is controlled separately by the props, this only influences visuals
const getClearSectionStyles = () => {
  return /*#__PURE__*/react.css("align-items:center;box-sizing:border-box;display:flex;margin:", designSystem.designTokens.spacing10, ";cursor:pointer;& svg *:not([fill='none']){fill:", designSystem.designTokens.iconColorForDatetimeInputIcon, ";}&:hover svg *{fill:", designSystem.designTokens.iconColorForDatetimeInputIconWhenHovered, ";}" + ("" ), "" );
};
const getClockIconContainerColor = props => {
  if (props.isDisabled) {
    return designSystem.designTokens.borderColorForInputWhenDisabled;
  }
  if (props.hasError) {
    return designSystem.designTokens.borderColorForInputWhenError;
  }
  if (props.isReadOnly) {
    return designSystem.designTokens.borderColorForInputWhenReadonly;
  }
  return designSystem.designTokens.borderColorForInput;
};
const getClockIconContainerFontColor = props => {
  if (props.isDisabled) {
    return designSystem.designTokens.fontColorForInputWhenDisabled;
  }
  if (props.hasError) {
    return designSystem.designTokens.fontColorForInputWhenError;
  }
  if (props.isReadOnly) {
    return designSystem.designTokens.fontColorForInputWhenReadonly;
  }
  return designSystem.designTokens.fontColorForInput;
};
const getClockIconContainerStyles = props => {
  return [/*#__PURE__*/react.css("align-items:center;box-sizing:border-box;background:none;background-color:", props.isDisabled ? designSystem.designTokens.backgroundColorForInputWhenDisabled : 'none', ";border:0;border-top-right-radius:", designSystem.designTokens.borderRadiusForInput, ";border-bottom-right-radius:", designSystem.designTokens.borderRadiusForInput, ";border-color:", getClockIconContainerColor(props), ";color:", getClockIconContainerFontColor(props), ";cursor:", props.isDisabled ? 'not-allowed' : 'default', ";height:100%;display:flex;padding:", designSystem.designTokens.spacing10, ";outline:0;transition:color ", designSystem.designTokens.transitionStandard, ",border-color ", designSystem.designTokens.transitionStandard, ";&:hover:not(:disabled):not(:read-only),&:focus{border-color:", designSystem.designTokens.borderColorForInputWhenFocused, ";}" + ("" ), "" )];
};
const getInputContainerBorderColor = props => {
  if (props.isDisabled) {
    return designSystem.designTokens.borderColorForInputWhenDisabled;
  }
  if (props.hasError) {
    return designSystem.designTokens.borderColorForInputWhenError;
  }
  if (props.isReadOnly) {
    return designSystem.designTokens.borderColorForInputWhenReadonly;
  }
  return designSystem.designTokens.borderColorForInput;
};
const getInputContainerFontColor = props => {
  if (props.isDisabled) {
    return designSystem.designTokens.fontColorForInputWhenDisabled;
  }
  if (props.hasError) {
    return designSystem.designTokens.fontColorForInputWhenError;
  }
  if (props.isReadOnly) {
    return designSystem.designTokens.fontColorForInputWhenReadonly;
  }
  return designSystem.designTokens.fontColorForInput;
};
const getInputContainerBackgroundColor = props => {
  if (props.isDisabled) {
    return designSystem.designTokens.backgroundColorForInputWhenDisabled;
  }
  if (props.isReadOnly) {
    return designSystem.designTokens.backgroundColorForInputWhenReadonly;
  }
  return designSystem.designTokens.backgroundColorForInput;
};

// This styled component is only useful because it's referenced in the styles below
const StyledClockIconContainer = /*#__PURE__*/_styled__default["default"]("label", {
  target: "e1dwg5ng1"
} )("" );
const getInputContainerStyles = props => {
  return [/*#__PURE__*/react.css("appearance:none;background-color:", props.isDisabled ? designSystem.designTokens.backgroundColorForInputWhenDisabled : designSystem.designTokens.backgroundColorForInput, ";background-color:", getInputContainerBackgroundColor(props), ";border:1px solid ", getInputContainerBorderColor(props), ";border-radius:", designSystem.designTokens.borderRadiusForInput, ";box-sizing:border-box;color:", getInputContainerFontColor(props), ";cursor:", props.isDisabled ? 'not-allowed' : 'default', ";width:100%;height:", designSystem.designTokens.heightForInput, ";align-items:center;display:flex;font-size:", designSystem.designTokens.fontSizeForInput, ";font-family:inherit;transition:border-color ", designSystem.designTokens.transitionStandard, ",box-shadow ", designSystem.designTokens.transitionStandard, ";svg{fill:", props.isReadOnly ? designSystem.designTokens.fontColorForInputWhenReadonly : 'inherit', ";}&:focus{border-color:", designSystem.designTokens.borderColorForInputWhenFocused, ";}" + ("" ), "" ), !props.isDisabled && !props.isReadOnly && /*#__PURE__*/react.css("&:hover{background-color:", designSystem.designTokens.backgroundColorForInputWhenHovered, ";}&:focus-within{border-color:", designSystem.designTokens.borderColorForInputWhenFocused, ";box-shadow:", designSystem.designTokens.boxShadowForDatetimeInputWhenHovered, " ", designSystem.designTokens.borderColorForInputWhenFocused, ";&:hover{background-color:", designSystem.designTokens.colorSurface, ";}}" + ("" ), "" ), props.hasError && /*#__PURE__*/react.css("box-shadow:", designSystem.designTokens.boxShadowForDatetimeInputWhenHovered, ";" + ("" ), "" )];
};
var _ref = {
  name: "v9rb4r",
  styles: "border:none;box-shadow:none;background:none;&,&:focus,&:focus:not(:read-only){box-shadow:none;}&:focus,&:hover{background-color:transparent!important;}"
} ;
const getTimeInputStyles = props => {
  const baseStyles = [inputUtils.getInputStyles(props), _ref];
  return baseStyles;
};
const StyledInputContainer = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e1dwg5ng0"
} )("" );

function ownKeys$1(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys$1(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys$1(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const ClearSection = props => {
  return jsxRuntime.jsx(AccessibleButton__default["default"], {
    css: getClearSectionStyles(),
    label: "clear",
    "aria-label": "clear",
    onClick: props.onClear,
    children: jsxRuntime.jsx(icons.CloseIcon, {
      size: "medium"
    })
  });
};
ClearSection.propTypes = {};
ClearSection.displayName = 'ClearSection';
const TimeInputBody = /*#__PURE__*/react$1.forwardRef((props, ref) => {
  return jsxRuntime.jsx(Inline__default["default"], {
    alignItems: "center",
    children: jsxRuntime.jsxs(StyledInputContainer, {
      css: getInputContainerStyles(props),
      children: [jsxRuntime.jsx("input", _objectSpread$1(_objectSpread$1({
        ref: ref,
        css: getTimeInputStyles(props),
        id: props.id,
        name: props.name,
        autoComplete: props.autoComplete,
        placeholder: props.placeholder,
        autoFocus: props.isAutofocussed,
        disabled: props.isDisabled,
        readOnly: props.isReadOnly,
        value: props.value,
        onChange: props.onChange,
        onFocus: props.onFocus,
        onBlur: props.onBlur
      }, utils.filterDataAttributes(props)), {}, {
        /* ARIA */
        "aria-readonly": props.isReadOnly,
        contentEditable: !props.isReadOnly
      }, !props.isReadOnly ? {
        'aria-invalid': props['aria-invalid'],
        'aria-errormessage': props['aria-errormessage']
      } : {})), !props.isDisabled && !props.isReadOnly && Boolean(props.value) && jsxRuntime.jsx(ClearSection, {
        isDisabled: props.isDisabled,
        hasError: props.hasError,
        isReadOnly: props.isReadOnly,
        onClear: props.onClear
      }), jsxRuntime.jsx(StyledClockIconContainer, {
        css: getClockIconContainerStyles(props),
        htmlFor: props.id,
        "data-toggle": true,
        children: jsxRuntime.jsx(icons.ClockIcon, {
          color: "neutral60"
        })
      })]
    })
  });
});
TimeInputBody.displayName = 'TimeInputBody';
var TimeInputBody$1 = TimeInputBody;

var messages = reactIntl.defineMessages({
  placeholder: {
    id: 'UIKit.TimeInput.placeholder',
    description: 'Placeholder for time input',
    defaultMessage: 'HH:mm AM/PM'
  }
});

function ownKeys(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context6, _context7; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context6 = ownKeys(Object(source), !0)).call(_context6, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context7 = ownKeys(Object(source))).call(_context7, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const sequentialId = utils.createSequentialId('time-input-');
const leftPad = function (value) {
  var _context;
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  return _padStartInstanceProperty__default["default"](_context = String(value)).call(_context, length, '0');
};
const format24hr = _ref => {
  var _context2, _context3, _context4, _context5;
  let hours = _ref.hours,
    minutes = _ref.minutes,
    seconds = _ref.seconds,
    milliseconds = _ref.milliseconds;
  const base = _concatInstanceProperty__default["default"](_context2 = "".concat(leftPad(hours), ":")).call(_context2, leftPad(minutes));
  if (seconds === 0 && milliseconds === 0) return base;
  if (milliseconds === 0) return _concatInstanceProperty__default["default"](_context3 = "".concat(base, ":")).call(_context3, leftPad(seconds));
  // string representation of a time without timezone in ISO 8601 format
  return _concatInstanceProperty__default["default"](_context4 = _concatInstanceProperty__default["default"](_context5 = "".concat(base, ":")).call(_context5, leftPad(seconds), ".")).call(_context4, leftPad(milliseconds, 3));
};
const hasMilliseconds = parsedTime => parsedTime.milliseconds !== 0;

// Calling `eventTarget.dispatchEvent` does not natively work in React.
// Instead, we need to grab the element value setter, set the value, and dispatch a change event.
const dispatchReactChangeEvent = (node, value) => {
  var _Object$getOwnPropert;
  const setValue = (_Object$getOwnPropert = _Object$getOwnPropertyDescriptor__default["default"](node.constructor.prototype, 'value')) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.set;
  setValue === null || setValue === void 0 ? void 0 : setValue.call(node, value);
  node.dispatchEvent(new Event('change', {
    bubbles: true
  }));
};
const TimeInput = props => {
  const id = hooks.useFieldId(props.id, sequentialId);
  const intl = reactIntl.useIntl();
  const element = react$1.useRef(null);
  const onChange = props.onChange;
  if (!props.isReadOnly) ;
  const onBlur = props.onBlur;
  const handleBlur = react$1.useCallback(event => {
    const rawValue = event.target.value;
    const formattedValue = TimeInput.toLocaleTime(rawValue, intl.locale);
    event.target.value = formattedValue;
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
  }, [intl.locale, onBlur]);
  const handleClear = react$1.useCallback(() => {
    if (element.current) {
      dispatchReactChangeEvent(element.current, '');
    }
    onChange === null || onChange === void 0 ? void 0 : onChange({
      target: {
        value: ''
      }
    });
  }, [onChange]);

  // if locale has changed trigger a new change event
  react$1.useEffect(() => {
    if (element.current) {
      dispatchReactChangeEvent(element.current, props.value);
    }
    // Only subscribe this effect to `intl.locale` changes.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [intl.locale]);
  return jsxRuntime.jsx(Constraints__default["default"].Horizontal, {
    max: props.horizontalConstraint,
    children: jsxRuntime.jsx(TimeInputBody$1, _objectSpread(_objectSpread({
      ref: element,
      id: id,
      name: props.name,
      autoComplete: props.autoComplete,
      value: props.value,
      onChange: onChange,
      onBlur: handleBlur,
      onFocus: props.onFocus,
      isAutofocussed: props.isAutofocussed,
      isDisabled: props.isDisabled,
      isReadOnly: props.isReadOnly,
      hasError: props.hasError,
      onClear: handleClear,
      placeholder: typeof props.placeholder === 'string' ? props.placeholder : intl.formatMessage(messages.placeholder)
    }, utils.filterDataAttributes(props)), {}, {
      /* ARIA */
      "aria-invalid": props['aria-invalid'],
      "aria-errormessage": props['aria-errormessage']
    }))
  });
};
TimeInput.propTypes = {};
TimeInput.displayName = 'TimeInput';

// Takes any input like 15:10, 3 AM, 3AM, 3:15AM, 3:5AM and turns it
// into a 24h format (with seconds and milliseconds if present)
TimeInput.to24h = time => {
  const parsedTime = utils.parseTime(time);
  return parsedTime ? format24hr(parsedTime) : '';
};
TimeInput.defaultProps = {
  horizontalConstraint: 'scale'
};

// Converts any value to either a formatted value or an empty string
// The resulting format might use 12h or 24h, unless the time contains
// milliseconds. If milliseconds are contained, the
// the 24h format is returned.
//
// Returns time in a format suitable for the locale.
TimeInput.toLocaleTime = (time, locale) => {
  const parsedTime = utils.parseTime(time);
  if (!parsedTime) return '';
  const timeIn24hFormat = format24hr(parsedTime);

  // return the 24h format, as the time has high precision
  if (hasMilliseconds(parsedTime)) return timeIn24hFormat;

  // return the localized time (12h or 24h format)
  const date = new Date(1970, 0, 1, parsedTime.hours, parsedTime.minutes, parsedTime.seconds, parsedTime.milliseconds);
  const options = {
    hour: 'numeric',
    minute: 'numeric',
    // only show seconds when time contains seconds
    second: parsedTime.seconds > 0 ? 'numeric' : undefined
  };
  const isValidDate = !isNaN(date.getTime());
  return isValidDate ? date.toLocaleTimeString(locale, options) : '';
};
var TimeInput$1 = TimeInput;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

exports["default"] = TimeInput$1;
exports.version = version;
