'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var _slicedToArray = require('@babel/runtime-corejs3/helpers/slicedToArray');
var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
require('prop-types');
var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _mapInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/map');
var react$1 = require('react');
var reactIntl = require('react-intl');
var react = require('@emotion/react');
var hooks = require('@commercetools-uikit/hooks');
var messages = require('@commercetools-uikit/messages');
var Stack = require('@commercetools-uikit/spacings-stack');
var Constraints = require('@commercetools-uikit/constraints');
var localizedUtils = require('@commercetools-uikit/localized-utils');
var utils = require('@commercetools-uikit/utils');
var TextInput = require('@commercetools-uikit/text-input');
var inputUtils = require('@commercetools-uikit/input-utils');
var designSystem = require('@commercetools-uikit/design-system');
var jsxRuntime = require('@emotion/react/jsx-runtime');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _mapInstanceProperty__default = /*#__PURE__*/_interopDefault(_mapInstanceProperty);
var Stack__default = /*#__PURE__*/_interopDefault(Stack);
var Constraints__default = /*#__PURE__*/_interopDefault(Constraints);
var TextInput__default = /*#__PURE__*/_interopDefault(TextInput);

var _ref$1 = {
  name: "1ps4mw6",
  styles: "border-top-left-radius:0;border-bottom-left-radius:0;border-style:solid;flex:auto"
} ;
// NOTE: order is important here
// * a disabled-field currently does not display warning/error-states so it takes precedence
// * a readonly-field cannot be changed, but it might be relevant for validation, so error and warning are checked first
// how you can interact with the field is controlled separately by the props, this only influences visuals
const getLocalizedInputStyles = () => [_ref$1];
const getLanguageLabelBackgroundColor = props => {
  if (props.isDisabled) {
    return designSystem.designTokens.backgroundColorForLocalizedInputLabelWhenDisabled;
  }
  if (props.isReadOnly) {
    return designSystem.designTokens.backgroundColorForLocalizedInputLabelWhenReadonly;
  }
  return designSystem.designTokens.backgroundColorForLocalizedInputLabel;
};
const getLanguageLabelBorderColor = props => {
  if (props.isDisabled) {
    return designSystem.designTokens.borderColorForInputWhenDisabled;
  }
  return props.isReadOnly ? designSystem.designTokens.borderColorForLocalizedInputLabelWhenReadonly : designSystem.designTokens.borderColorForLocalizedInputLabel;
};
const getLanguageLabelStyles = props => {
  return /*#__PURE__*/react.css("display:flex;flex-direction:column;justify-content:center;flex:1 0 auto;box-sizing:border-box;color:", designSystem.designTokens.fontColorForLocalizedInputLabel, ";cursor:", props.isDisabled ? 'not-allowed' : 'default', ";height:", designSystem.designTokens.heightForInput, ";font-size:", designSystem.designTokens.fontSizeForLocalizedInputLabel, ";background-color:", getLanguageLabelBackgroundColor(props), ";border-top-left-radius:", designSystem.designTokens.borderRadiusForInput, ";border-bottom-left-radius:", designSystem.designTokens.borderRadiusForInput, ";border:1px solid ", getLanguageLabelBorderColor(props), ";padding:", designSystem.designTokens.paddingForLocalizedInputLabel, ";transition:border-color ", designSystem.designTokens.transitionStandard, ",background-color ", designSystem.designTokens.transitionStandard, ",color ", designSystem.designTokens.transitionStandard, ";border-right:0;box-shadow:none;appearance:none;" + ("" ), "" );
};

function ownKeys(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const sequentialId = utils.createSequentialId('localized-text-input-');
var _ref = {
  name: "1ktetz7",
  styles: "width:100%;position:relative;display:flex"
} ;
const LocalizedInput = props => {
  const onChange = props.onChange;
  const handleChange = react$1.useCallback(event => {
    // We manipulate the event to add the language to the target.
    // That way the users of LocalizedTextInput's onChange can read
    // event.target.language and event.target.value to determine the next value.
    //
    // We only need this information for the story, the MC application code will
    // never need to access the information in such an inconvenient way, as
    // Formik can deal with a name like "foo.en" and sets the value correctly.
    // We can't use this as we aren't guaranteed a name in the story as the user
    // might clear it using the knob, and then we can't parse the language from
    // the input name anymore.
    //
    event.target.language = props.language;
    onChange === null || onChange === void 0 ? void 0 : onChange(event);
  }, [props.language, onChange]);
  if (!props.isReadOnly) ;
  return jsxRuntime.jsxs("div", {
    css: _ref,
    children: [jsxRuntime.jsx("label", {
      htmlFor: props.id,
      css: getLanguageLabelStyles(props),
      children: props.language.toUpperCase()
    }), jsxRuntime.jsx(TextInput__default["default"], _objectSpread(_objectSpread({}, props), {}, {
      onChange: handleChange,
      css: getLocalizedInputStyles
    }))]
  }, props.language);
};
LocalizedInput.propTypes = {};
LocalizedInput.displayName = 'LocalizedInput';
const RequiredValueErrorMessage = () => jsxRuntime.jsx(messages.ErrorMessage, {
  children: jsxRuntime.jsx(reactIntl.FormattedMessage, _objectSpread({}, inputUtils.messagesLocalizedInput.missingRequiredField))
});
RequiredValueErrorMessage.displayName = 'RequiredValueErrorMessage';
const LocalizedTextInput = props => {
  const defaultExpansionState = props.hideLanguageExpansionControls || props.defaultExpandLanguages ||
  // default to `false`, because useToggleState defaults to `true`
  false;
  const _useToggleState = hooks.useToggleState(defaultExpansionState),
    _useToggleState2 = _slicedToArray(_useToggleState, 2),
    areLanguagesExpanded = _useToggleState2[0],
    toggleLanguages = _useToggleState2[1];
  const onLocalizedInputToggle = react$1.useCallback(() => toggleLanguages(), [toggleLanguages]);
  const languages = localizedUtils.sortLanguages(props.selectedLanguage, _Object$keys__default["default"](props.value));
  const id = hooks.useFieldId(props.id, sequentialId);
  const hasErrorInRemainingLanguages = props.hasError || localizedUtils.getHasErrorOnRemainingLanguages(props.errors, props.selectedLanguage);
  if (hasErrorInRemainingLanguages) {
    // this update within render replaces the old `getDerivedStateFromProps` functionality
    // https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops
    if (hasErrorInRemainingLanguages !== areLanguagesExpanded) {
      toggleLanguages();
    }
  }
  const shouldRenderLanguagesButton = languages.length > 1 && !props.hideLanguageExpansionControls;
  if (!props.isReadOnly) ;
  if (props.hideLanguageExpansionControls) ;
  return jsxRuntime.jsx(Constraints__default["default"].Horizontal, {
    max: props.horizontalConstraint,
    children: jsxRuntime.jsxs(Stack__default["default"], {
      scale: "xs",
      children: [jsxRuntime.jsx(Stack__default["default"], {
        children: _mapInstanceProperty__default["default"](languages).call(languages, (language, index) => {
          const isFirstLanguage = index === 0;
          if (!isFirstLanguage && !areLanguagesExpanded) return null;
          return jsxRuntime.jsx("div", {
            children: jsxRuntime.jsxs(Stack__default["default"], {
              scale: "xs",
              children: [jsxRuntime.jsx(LocalizedInput, _objectSpread(_objectSpread({
                autoComplete: props.autoComplete,
                id: LocalizedTextInput.getId(id, language),
                name: LocalizedTextInput.getName(props.name, language),
                value: props.value[language],
                onChange: props.onChange,
                language: language,
                placeholder: props.placeholder ? props.placeholder[language] : undefined,
                onBlur: props.onBlur,
                onFocus: props.onFocus,
                isAutofocussed: index === 0 && props.isAutofocussed,
                isDisabled: props.isDisabled,
                isReadOnly: props.isReadOnly,
                hasError: Boolean(props.hasError || props.errors && props.errors[language])
              }, localizedUtils.createLocalizedDataAttributes(props, language)), {}, {
                /* ARIA */
                "aria-invalid": props['aria-invalid'],
                "aria-errormessage": props['aria-errormessage']
              })), props.errors && props.errors[language]]
            })
          }, language);
        })
      }), shouldRenderLanguagesButton && jsxRuntime.jsx(inputUtils.LocalizedInputToggle, {
        isOpen: areLanguagesExpanded,
        onClick: onLocalizedInputToggle,
        isDisabled: areLanguagesExpanded && hasErrorInRemainingLanguages,
        remainingLocalizations: languages.length - 1
      })]
    })
  });
};
LocalizedTextInput.propTypes = {};
LocalizedTextInput.displayName = 'LocalizedTextInput';
LocalizedTextInput.RequiredValueErrorMessage = RequiredValueErrorMessage;
LocalizedTextInput.defaultProps = {
  horizontalConstraint: 'scale'
};
LocalizedTextInput.getId = localizedUtils.getId;
LocalizedTextInput.getName = localizedUtils.getName;
LocalizedTextInput.createLocalizedString = localizedUtils.createLocalizedString;
LocalizedTextInput.isEmpty = localizedUtils.isEmpty;
LocalizedTextInput.omitEmptyTranslations = localizedUtils.omitEmptyTranslations;
LocalizedTextInput.isTouched = localizedUtils.isTouched;
var LocalizedTextInput$1 = LocalizedTextInput;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

exports["default"] = LocalizedTextInput$1;
exports.version = version;
