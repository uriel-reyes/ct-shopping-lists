import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _pt from 'prop-types';
import { useIntl } from 'react-intl';
import isEmpty from 'lodash/isEmpty';
import { components } from 'react-select';
import CreatableSelect from 'react-select/creatable';
import Constraints from '@commercetools-uikit/constraints';
import { warning, filterDataAttributes } from '@commercetools-uikit/utils';
import { messages, customComponentsWithIcons, createSelectStyles, DropdownIndicator, ClearIndicator, TagRemove } from '@commercetools-uikit/select-utils';
import { jsx } from '@emotion/react/jsx-runtime';

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const customizedComponents = {
  DropdownIndicator,
  ClearIndicator,
  MultiValueRemove: TagRemove
};
const defaultProps = {
  // Using "null" will ensure that the currently selected value disappears in
  // case "undefined" gets passed as the next value
  value: null,
  // The input needs to be searchable, otherwise it's not possible to create
  // new options.
  // We still allow consumers to pass isSearchable={false} so that they can
  // use CreatableSelectInput as an alternative to SelectInput, which does
  // not do the option/value mapping going on there and therefore provides
  // the default API of react-select.
  isSearchable: true,
  menuPortalZIndex: 1
};
const CreatableSelectInput = props => {
  const intl = useIntl();
  if (!props.isReadOnly) {
    process.env.NODE_ENV !== "production" ? warning(typeof props.onChange === 'function', 'CreatableSelectInput: `onChange` is required when input is not read only.') : void 0;
  }
  const placeholder = props.placeholder || intl.formatMessage(messages.placeholder);
  return jsx(Constraints.Horizontal, {
    max: props.horizontalConstraint,
    children: jsx("div", _objectSpread(_objectSpread({}, filterDataAttributes(props)), {}, {
      children: jsx(CreatableSelect, {
        "aria-label": props['aria-label'],
        "aria-labelledby": props['aria-labelledby'],
        "aria-invalid": props['aria-invalid'],
        "aria-errormessage": props['aria-errormessage'],
        autoFocus: props.isAutofocussed,
        backspaceRemovesValue: props.isReadOnly ? false : props.backspaceRemovesValue,
        components: _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, customizedComponents), props.components), props.iconLeft && !props.isMulti ? customComponentsWithIcons : {}), props.isReadOnly ? {
          Input: ownProps => jsx(components.Input, _objectSpread(_objectSpread({}, ownProps), {}, {
            readOnly: true
          }))
        } : {}), props.components),
        menuIsOpen: props.isReadOnly ? false : undefined,
        styles: createSelectStyles({
          hasWarning: props.hasWarning,
          hasError: props.hasError,
          showOptionGroupDivider: props.showOptionGroupDivider,
          menuPortalZIndex: props.menuPortalZIndex,
          isDisabled: props.isDisabled,
          isReadOnly: props.isReadOnly,
          iconLeft: props.iconLeft,
          isMulti: props.isMulti,
          hasValue: !isEmpty(props.value),
          horizontalConstraint: props.horizontalConstraint
        }),
        filterOption: props.filterOption
        // react-select uses "id" (for the container) and "inputId" (for the input),
        // but we use "id" (for the input) and "containerId" (for the container)
        // instead.
        // This makes it easier to less confusing to use with <label />s.
        ,
        id: props.containerId,
        inputId: props.id,
        inputValue: props.inputValue,
        isClearable: props.isReadOnly ? false : props.isClearable,
        isDisabled: props.isDisabled,
        isOptionDisabled: props.isOptionDisabled,
        isMulti: props.isMulti,
        isSearchable: props.isSearchable,
        maxMenuHeight: props.maxMenuHeight,
        menuPortalTarget: props.menuPortalTarget,
        menuShouldBlockScroll: props.menuShouldBlockScroll,
        closeMenuOnSelect: props.closeMenuOnSelect,
        name: props.name,
        noOptionsMessage: props.noOptionsMessage || (_ref => {
          let inputValue = _ref.inputValue;
          return inputValue === '' ? intl.formatMessage(messages.noOptionsMessageWithoutInputValue) : intl.formatMessage(messages.noOptionsMessageWithInputValue, {
            inputValue
          });
        }),
        onBlur: typeof props.onBlur === 'function' ? () => {
          const event = {
            target: {
              id: props.id,
              name: (() => {
                if (!props.isMulti) return props.name;
                // We append the ".0" to make Formik set the touched
                // state as an array instead of a boolean only.
                // Otherwise the shapes would clash on submission, as
                // Formik will create an array on submission anyways.
                return props.name ? "".concat(props.name, ".0") : undefined;
              })()
            },
            persist: () => {}
          };
          props.onBlur && props.onBlur(event);
        } : undefined,
        onChange: (value, info) => {
          var _props$onChange;
          // selectedOptions is either an array, or a single option, or null
          // depending on whether we're in multi-mode or not (isMulti)

          let newValue = value;
          if (props.isMulti && !newValue) {
            newValue = [];
          }
          (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, {
            target: {
              id: props.id,
              name: props.name,
              value: newValue
            },
            persist: () => {}
          }, info);
        },
        onFocus: props.onFocus,
        onInputChange: props.onInputChange,
        options: props.options,
        placeholder: placeholder,
        tabIndex: props.tabIndex,
        tabSelectsValue: props.tabSelectsValue,
        value: props.value
        // Creatable props
        ,
        allowCreateWhileLoading: props.allowCreateWhileLoading,
        formatCreateLabel: props.formatCreateLabel || (inputValue => intl.formatMessage(messages.createLabel, {
          inputValue
        })),
        isValidNewOption: props.isValidNewOption,
        getNewOptionData: props.getNewOptionData,
        onCreateOption: props.onCreateOption,
        createOptionPosition: props.createOptionPosition
        //@ts-ignore
        ,
        iconLeft: props.iconLeft
      })
    }))
  });
};
CreatableSelectInput.propTypes = process.env.NODE_ENV !== "production" ? {
  horizontalConstraint: _pt.oneOf([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 'scale', 'auto']),
  hasError: _pt.bool,
  hasWarning: _pt.bool,
  isReadOnly: _pt.bool,
  iconLeft: _pt.node,
  isAutofocussed: _pt.bool,
  menuPortalZIndex: _pt.number.isRequired,
  onBlur: _pt.func,
  onChange: _pt.func,
  options: _pt.oneOfType([_pt.arrayOf(_pt.shape({
    value: _pt.string.isRequired,
    label: _pt.node
  })), _pt.arrayOf(_pt.shape({
    options: _pt.arrayOf(_pt.shape({
      value: _pt.string.isRequired,
      label: _pt.node
    })).isRequired
  }))]),
  showOptionGroupDivider: _pt.bool
} : {};
CreatableSelectInput.displayName = 'CreatableSelectInput';
CreatableSelectInput.defaultProps = defaultProps;

/**
 * Expose static helper methods.
 */

// Both "true" and an empty array [] represent a touched state. The Boolean
// conveniently handles both cases
CreatableSelectInput.isTouched = touched => Boolean(touched);

/**
 * Expose react-select components for customization purposes.
 */

// custom
CreatableSelectInput.ClearIndicator = customizedComponents.ClearIndicator;
CreatableSelectInput.Control = components.Control;
CreatableSelectInput.CrossIcon = components.CrossIcon;
CreatableSelectInput.DownChevron = components.DownChevron;
// custom
CreatableSelectInput.DropdownIndicator = customizedComponents.DropdownIndicator;
CreatableSelectInput.Group = components.Group;
CreatableSelectInput.GroupHeading = components.GroupHeading;
CreatableSelectInput.IndicatorSeparator = components.IndicatorSeparator;
CreatableSelectInput.IndicatorsContainer = components.IndicatorsContainer;
CreatableSelectInput.Input = components.Input;
CreatableSelectInput.LoadingIndicator = components.LoadingIndicator;
CreatableSelectInput.LoadingMessage = components.LoadingMessage;
CreatableSelectInput.Menu = components.Menu;
CreatableSelectInput.MenuList = components.MenuList;
CreatableSelectInput.MenuPortal = components.MenuPortal;
CreatableSelectInput.MultiValue = components.MultiValue;
CreatableSelectInput.MultiValueContainer = components.MultiValueContainer;
CreatableSelectInput.MultiValueLabel = components.MultiValueLabel;
// custom
CreatableSelectInput.MultiValueRemove = customizedComponents.MultiValueRemove;
CreatableSelectInput.NoOptionsMessage = components.NoOptionsMessage;
CreatableSelectInput.Option = components.Option;
CreatableSelectInput.Placeholder = components.Placeholder;
CreatableSelectInput.SelectContainer = components.SelectContainer;
CreatableSelectInput.SingleValue = components.SingleValue;
CreatableSelectInput.ValueContainer = components.ValueContainer;
var CreatableSelectInput$1 = CreatableSelectInput;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

export { CreatableSelectInput$1 as default, version };
