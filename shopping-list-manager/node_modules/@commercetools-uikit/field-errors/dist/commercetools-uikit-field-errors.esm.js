import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import _pt from 'prop-types';
import _mapInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/map';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$entries from '@babel/runtime-corejs3/core-js-stable/object/entries';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import 'react';
import { defineMessages, FormattedMessage } from 'react-intl';
import { ErrorMessage } from '@commercetools-uikit/messages';
import { jsx, Fragment } from '@emotion/react/jsx-runtime';

var messages = defineMessages({
  missingRequiredField: {
    id: 'UIKit.FieldErrors.missingRequiredField',
    description: 'Error message for missing required value',
    defaultMessage: 'This field is required. Provide a value.'
  },
  invalidNegativeNumber: {
    id: 'UIKit.FieldErrors.invalidNegativeNumber',
    description: 'Error message when negative number is used',
    defaultMessage: 'Negative number is not supported.'
  },
  invalidFractionalNumber: {
    id: 'UIKit.FieldErrors.invalidFractionalNumber',
    description: 'Error message when fractional number is used',
    defaultMessage: 'A whole number is required.'
  }
});

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context3, _context4; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const isObject = obj => typeof obj === 'object';
const FieldErrors = props => {
  var _context, _context2;
  if (!props.isVisible) return null;
  if (!props.errors || !isObject(props.errors)) return null;
  return jsx(Fragment, {
    children: _mapInstanceProperty(_context = _filterInstanceProperty(_context2 = _Object$entries(props.errors)
    // Only render errors which have truthy values, to avoid
    // rendering an error for, e.g. { missing: false }
    ).call(_context2, _ref => {
      let _ref2 = _slicedToArray(_ref, 2),
        error = _ref2[1];
      return error;
    })).call(_context, _ref3 => {
      let _ref4 = _slicedToArray(_ref3, 2),
        key = _ref4[0],
        error = _ref4[1];
      // We might not use a custom error renderer, so we fall back to null
      // to enable the default errors to kick in
      const errorElement = props.renderError ? props.renderError(key, error) : null;
      // Render a custom error if one was provided.
      // Custom errors take precedence over the default errors
      if (errorElement) return jsx(ErrorMessage, {
        id: props.id,
        children: errorElement
      }, key);
      const defaultErrorElement = props.renderDefaultError ? props.renderDefaultError(key, error) : null;
      // Render a default error if one was provided.
      // Default errors take precedence over the known errors
      if (defaultErrorElement) return jsx(ErrorMessage, {
        id: props.id,
        children: defaultErrorElement
      }, key);

      // Try to see if we know this error and render that error instead then
      if (key === FieldErrors.errorTypes.MISSING) return jsx(ErrorMessage, {
        id: props.id,
        children: jsx(FormattedMessage, _objectSpread({}, messages.missingRequiredField))
      }, key);
      if (key === FieldErrors.errorTypes.NEGATIVE) return jsx(ErrorMessage, {
        id: props.id,
        children: jsx(FormattedMessage, _objectSpread({}, messages.invalidNegativeNumber))
      }, key);
      if (key === FieldErrors.errorTypes.FRACTIONS) return jsx(ErrorMessage, {
        id: props.id,
        children: jsx(FormattedMessage, _objectSpread({}, messages.invalidFractionalNumber))
      }, key);
      // Render nothing in case the error is not known and no custom error
      // was returned
      return null;
    })
  });
};
FieldErrors.propTypes = process.env.NODE_ENV !== "production" ? {
  id: _pt.string,
  errors: _pt.objectOf(_pt.bool),
  isVisible: _pt.bool,
  renderError: _pt.func,
  renderDefaultError: _pt.func
} : {};
FieldErrors.displayName = 'FieldErrors';
FieldErrors.errorTypes = {
  MISSING: 'missing',
  NEGATIVE: 'negative',
  FRACTIONS: 'fractions'
};
var FieldErrors$1 = FieldErrors;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

export { FieldErrors$1 as default, version };
