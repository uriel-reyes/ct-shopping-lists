'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _Reflect$construct = require('@babel/runtime-corejs3/core-js-stable/reflect/construct');
var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
var _classCallCheck = require('@babel/runtime-corejs3/helpers/classCallCheck');
var _createClass = require('@babel/runtime-corejs3/helpers/createClass');
var _inherits = require('@babel/runtime-corejs3/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime-corejs3/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime-corejs3/helpers/getPrototypeOf');
var _pt = require('prop-types');
var react = require('react');
var utils = require('@commercetools-uikit/utils');
var richTextUtils = require('@commercetools-uikit/rich-text-utils');
var _slicedToArray = require('@babel/runtime-corejs3/helpers/slicedToArray');
var reactIntl = require('react-intl');
var CollapsibleMotion = require('@commercetools-uikit/collapsible-motion');
var Stack = require('@commercetools-uikit/spacings-stack');
var icons = require('@commercetools-uikit/icons');
var Constraints = require('@commercetools-uikit/constraints');
var FlatButton = require('@commercetools-uikit/flat-button');
var inputUtils = require('@commercetools-uikit/input-utils');
var slateReact = require('slate-react');
var slate = require('slate');
var slateHistory = require('slate-history');
var isHotkey = require('is-hotkey');
var pipe = require('lodash/fp/pipe');
var _styled = require('@emotion/styled/base');
var jsxRuntime = require('@emotion/react/jsx-runtime');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _Reflect$construct__default = /*#__PURE__*/_interopDefault(_Reflect$construct);
var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var _pt__default = /*#__PURE__*/_interopDefault(_pt);
var CollapsibleMotion__default = /*#__PURE__*/_interopDefault(CollapsibleMotion);
var Stack__default = /*#__PURE__*/_interopDefault(Stack);
var Constraints__default = /*#__PURE__*/_interopDefault(Constraints);
var FlatButton__default = /*#__PURE__*/_interopDefault(FlatButton);
var isHotkey__default = /*#__PURE__*/_interopDefault(isHotkey);
var pipe__default = /*#__PURE__*/_interopDefault(pipe);
var _styled__default = /*#__PURE__*/_interopDefault(_styled);

const EditorWrapper = /*#__PURE__*/_styled__default["default"]("div", process.env.NODE_ENV === "production" ? {
  target: "e1d53kc50"
} : {
  target: "e1d53kc50",
  label: "EditorWrapper"
})("align-self:stretch;cursor:", props => props.isDisabled || props.isReadOnly ? 'not-allowed' : 'inherit', ";" + (process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVkaXRvci5zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBS3FEIiwiZmlsZSI6ImVkaXRvci5zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IFRFZGl0b3JQcm9wcyB9IGZyb20gJy4vZWRpdG9yJztcblxudHlwZSBURWRpdG9yV3JhcHBlclByb3BzID0gUGljazxURWRpdG9yUHJvcHMsICdpc0Rpc2FibGVkJyB8ICdpc1JlYWRPbmx5Jz47XG5cbmNvbnN0IEVkaXRvcldyYXBwZXIgPSBzdHlsZWQuZGl2PFRFZGl0b3JXcmFwcGVyUHJvcHM+YFxuICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICBjdXJzb3I6ICR7KHByb3BzKSA9PlxuICAgIHByb3BzLmlzRGlzYWJsZWQgfHwgcHJvcHMuaXNSZWFkT25seSA/ICdub3QtYWxsb3dlZCcgOiAnaW5oZXJpdCd9O1xuYDtcblxuZXhwb3J0IHsgRWRpdG9yV3JhcHBlciB9O1xuIl19 */"));

function ownKeys$1(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys$1(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys$1(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const HOTKEYS = {
  'mod+b': 'bold',
  'mod+i': 'italic',
  'mod+u': 'underline',
  'mod+`': 'code'
};
const COLLAPSED_HEIGHT = 32;
const renderElement = props => jsxRuntime.jsx(richTextUtils.Element, _objectSpread$1({}, props));
const renderLeaf = props => jsxRuntime.jsx(richTextUtils.Leaf, _objectSpread$1({}, props));
const Editor = /*#__PURE__*/react.forwardRef((props, forwardedRef) => {
  const intl = reactIntl.useIntl();
  const ref = react.useRef(null);
  const createEditorWithPlugins = pipe__default["default"](slateReact.withReact, slateHistory.withHistory);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const editor = react.useMemo(() => createEditorWithPlugins(slate.createEditor()), []);
  const _useState = react.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    renderToggleButton = _useState2[0],
    setRenderToggleButton = _useState2[1];
  const updateRenderToggleButton = react.useCallback(() => {
    var _ref$current;
    const doesExceedCollapsedHeightLimit = Number((_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.clientHeight) > COLLAPSED_HEIGHT;
    if (doesExceedCollapsedHeightLimit && !renderToggleButton) {
      setRenderToggleButton(true);
    }
    if (!doesExceedCollapsedHeightLimit && renderToggleButton) {
      setRenderToggleButton(false);
    }
  }, [setRenderToggleButton, renderToggleButton]);
  react.useEffect(() => {
    updateRenderToggleButton();
  }, [editor, updateRenderToggleButton]);

  // resetting
  const resetValue = react.useCallback(newValue => {
    richTextUtils.resetEditor(editor, newValue);
  }, [editor]);
  /* 
  Resetting the editor requires access to `editor` object returned from `useSlate` hook.
  Therefore, `reset` function is attached to the passed `ref` object via `useImperativeHandle` hook
  to be called from the parent component. 
  e.g. <button onMouseDown={() => ref.current?.resetValue("<p><strong>Value after reset</strong></p>")}>Reset</button>
  */
  react.useImperativeHandle(forwardedRef, () => {
    return {
      resetValue
    };
  });
  return jsxRuntime.jsx(CollapsibleMotion__default["default"], {
    minHeight: COLLAPSED_HEIGHT,
    isDefaultClosed: !props.defaultExpandMultilineText,
    children: _ref => {
      let isOpen = _ref.isOpen,
        toggle = _ref.toggle,
        containerStyles = _ref.containerStyles,
        registerContentNode = _ref.registerContentNode;
      const refObj = {
        containerRef: ref,
        registerContentNode
      };
      return jsxRuntime.jsx(Constraints__default["default"].Horizontal, {
        max: props.horizontalConstraint,
        children: jsxRuntime.jsxs(Stack__default["default"], {
          scale: "xs",
          alignItems: "flex-end",
          children: [jsxRuntime.jsx(EditorWrapper, {
            isDisabled: props.isDisabled,
            isReadOnly: props.isReadOnly,
            children: jsxRuntime.jsx(slateReact.Slate, {
              editor: editor,
              value: props.value,
              onChange: props.onChange,
              children: jsxRuntime.jsxs(richTextUtils.RichTextBody
              // @ts-ignore
              , {
                ref: refObj,
                hasError: props.hasError,
                isDisabled: props.isDisabled,
                hasWarning: props.hasWarning,
                isReadOnly: Boolean(props.isReadOnly),
                showExpandIcon: Boolean(props.showExpandIcon),
                onClickExpand: props.onClickExpand,
                containerStyles: containerStyles,
                children: [jsxRuntime.jsx(slateReact.Editable, _objectSpread$1(_objectSpread$1({}, utils.filterDataAttributes(props)), {}, {
                  name: props.name,
                  renderElement: renderElement,
                  renderLeaf: renderLeaf,
                  placeholder: props.placeholder,
                  autoFocus: props.isAutofocused,
                  readOnly: props.isReadOnly,
                  disabled: props.isDisabled,
                  onBlur: props.onBlur,
                  onFocus: event => {
                    var _props$onFocus;
                    (_props$onFocus = props.onFocus) === null || _props$onFocus === void 0 ? void 0 : _props$onFocus.call(props, event);
                    // opens the input if it regains focus and it's closed
                    if (!isOpen) {
                      toggle();
                      richTextUtils.focusEditor(editor);
                    }
                  },
                  onKeyDown: event => {
                    for (const hotkey in HOTKEYS) {
                      if (isHotkey__default["default"](hotkey, event)) {
                        event.preventDefault();
                        const mark = HOTKEYS[hotkey];
                        richTextUtils.toggleMark(editor, mark);
                        break;
                      }
                    }
                  }
                })), props.children, jsxRuntime.jsx(richTextUtils.HiddenInput, {
                  isFocused: slateReact.ReactEditor.isFocused(editor),
                  handleFocus: () => {
                    richTextUtils.focusEditor(editor);
                  },
                  id: props.id,
                  disabled: props.isDisabled,
                  readOnly: props.isReadOnly
                })]
              })
            })
          }), renderToggleButton && jsxRuntime.jsx(FlatButton__default["default"], {
            onClick: toggle,
            label: isOpen ? intl.formatMessage(inputUtils.messagesMultilineInput.collapse) : intl.formatMessage(inputUtils.messagesMultilineInput.expand),
            icon: isOpen ? jsxRuntime.jsx(icons.AngleUpIcon, {
              size: "small"
            }) : jsxRuntime.jsx(icons.AngleDownIcon, {
              size: "small"
            })
          })]
        })
      });
    }
  });
});
Editor.displayName = 'Editor';
var Editor$1 = Editor;

function ownKeys(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct__default["default"](Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct__default["default"]) return false; if (_Reflect$construct__default["default"].sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct__default["default"](Boolean, [], function () {})); return true; } catch (e) { return false; } }
let RichTextInput = /*#__PURE__*/function (_PureComponent) {
  _inherits(RichTextInput, _PureComponent);
  var _super = _createSuper(RichTextInput);
  function RichTextInput() {
    var _this;
    _classCallCheck(this, RichTextInput);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.serializedValue = _this.props.value;
    _this.internalSlateValue = richTextUtils.validSlateStateAdapter(richTextUtils.html.deserialize(_this.props.value || ''));
    _this.onValueChange = state => {
      const serializedValue = richTextUtils.html.serialize(state);
      // because we are not using setState, we need to make sure that
      // we perform an update when the slate value changes
      // as this can contain things like cursor location
      // in this case, the internalSlateValue would change
      // but the serializedValue would NOT change.
      const hasInternalSlateValueChanged = _this.internalSlateValue !== state;
      const hasSerializedValueChanged = serializedValue !== _this.serializedValue;
      _this.internalSlateValue = richTextUtils.validSlateStateAdapter(state);
      _this.serializedValue = serializedValue;
      // the consumer only cares about the serializedValue, so it doesn't make sense to call
      // onChange unless this value changes.
      if (hasSerializedValueChanged) {
        var _this$props$onChange, _this$props;
        (_this$props$onChange = (_this$props = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props, {
          target: {
            value: richTextUtils.html.serialize(state)
          }
        });
      }
      if (hasInternalSlateValueChanged && !hasSerializedValueChanged) {
        // this way we force update if cursor or selection changes
        _this.forceUpdate();
      }
    };
    return _this;
  }
  _createClass(RichTextInput, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      // everytime we call `onChange`, we update `this.serializedValue`
      // to the new HTML value
      // this condition only occurs if the parent component takes `control`
      // and resets the component to a different HTML value that what
      // we expect
      // in this case, we need to parse this new value into a value slate
      // can understand, save this value to our class variable, and forceUpdate
      // this keeps the component in sync.
      if (this.props.value !== this.serializedValue) {
        const value = this.props.value || '';
        this.internalSlateValue = richTextUtils.validSlateStateAdapter(richTextUtils.html.deserialize(value));
        this.serializedValue = value;
        this.forceUpdate();
      }
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.props.isReadOnly) {
        process.env.NODE_ENV !== "production" ? utils.warning(typeof this.props.onChange === 'function', 'RichTextInput: "onChange" is required when input is not read only.') : void 0;
      }
      if (this.props.showExpandIcon) {
        process.env.NODE_ENV !== "production" ? utils.warning(typeof this.props.onClickExpand === 'function', 'RichTextInput: "onClickExpand" is required when showExpandIcon is true') : void 0;
      }
      return jsxRuntime.jsx(Editor$1, _objectSpread(_objectSpread({}, utils.filterDataAttributes(this.props)), {}, {
        isAutofocused: this.props.isAutofocussed,
        id: this.props.id,
        name: this.props.name,
        onFocus: this.props.onFocus,
        onBlur: this.props.onBlur,
        isDisabled: this.props.isDisabled,
        isReadOnly: this.props.isReadOnly || this.props.isDisabled,
        value: this.internalSlateValue,
        onChange: this.onValueChange,
        horizontalConstraint: this.props.horizontalConstraint,
        defaultExpandMultilineText: this.props.defaultExpandMultilineText,
        hasWarning: this.props.hasWarning,
        hasError: this.props.hasError,
        placeholder: this.props.placeholder,
        showExpandIcon: this.props.showExpandIcon,
        onClickExpand: this.props.onClickExpand,
        ref: this.props.parentRef
      }));
    }
  }]);
  return RichTextInput;
}(react.PureComponent); // When component is using `forwardRef` only `defaultProps` and `displayName` are recognized by default as static props
RichTextInput.defaultProps = {
  defaultExpandMultilineText: false,
  horizontalConstraint: 'scale',
  placeholder: '',
  showExpandIcon: false
};
RichTextInput.displayName = 'RichTextInput';
RichTextInput.propTypes = process.env.NODE_ENV !== "production" ? {
  isAutofocussed: _pt__default["default"].bool,
  defaultExpandMultilineText: _pt__default["default"].bool,
  hasError: _pt__default["default"].bool,
  hasWarning: _pt__default["default"].bool,
  id: _pt__default["default"].string,
  name: _pt__default["default"].string,
  placeholder: _pt__default["default"].string,
  isDisabled: _pt__default["default"].bool,
  isReadOnly: _pt__default["default"].bool,
  horizontalConstraint: _pt__default["default"].oneOf([7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 'scale', 'auto']),
  onChange: _pt__default["default"].func,
  onFocus: _pt__default["default"].func,
  onBlur: _pt__default["default"].func,
  value: _pt__default["default"].string,
  showExpandIcon: _pt__default["default"].bool,
  onClickExpand: _pt__default["default"].func
} : {};
const isTouched = touched => Boolean(touched);
const RichTextInputWithRef = /*#__PURE__*/react.forwardRef((props, ref) => jsxRuntime.jsx(RichTextInput, _objectSpread({
  parentRef: ref
}, props)));
RichTextInputWithRef.displayName = 'RichTextInputWithRef';
RichTextInputWithRef.isEmpty = richTextUtils.isEmpty;
RichTextInputWithRef.isTouched = isTouched;
var RichTextInputWithRef$1 = RichTextInputWithRef;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

exports["default"] = RichTextInputWithRef$1;
exports.version = version;
