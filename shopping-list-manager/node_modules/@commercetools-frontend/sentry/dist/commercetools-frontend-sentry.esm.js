import _JSON$stringify from '@babel/runtime-corejs3/core-js-stable/json/stringify';
import _includesInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/includes';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _concatInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/concat';
import * as Sentry from '@sentry/react';
import { BrowserTracing } from '@sentry/browser';
import history from '@commercetools-frontend/browser-history';
import _Reflect$construct from '@babel/runtime-corejs3/core-js-stable/reflect/construct';
import _classCallCheck from '@babel/runtime-corejs3/helpers/esm/classCallCheck';
import _createClass from '@babel/runtime-corejs3/helpers/esm/createClass';
import _inherits from '@babel/runtime-corejs3/helpers/esm/inherits';
import _possibleConstructorReturn from '@babel/runtime-corejs3/helpers/esm/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime-corejs3/helpers/esm/getPrototypeOf';
import _pt from 'prop-types';
import { PureComponent, Component } from 'react';

// NOTE: This string will be replaced on build time with the package version.
var version = "22.13.0";

const makeErrorToCapture = error => {
  if (error instanceof Error) return error;
  if (error instanceof ErrorEvent) return new Error(error.message);
  return new Error(_JSON$stringify(error.reason || 'Unhandled rejection without a reason'));
};
const sendErrorToSentry = error => {
  if (typeof error === 'string') return Sentry.captureMessage(error);
  const errorToCapture = makeErrorToCapture(error);
  return Sentry.captureException(errorToCapture);
};
const replaceEventValues = (source, replacements) => {
  const replaceEventValue = prop => {
    source[prop] = replacements[prop];
  };
  for (const prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      var _context;
      const hasPropReplacement = _includesInstanceProperty(_context = _Object$keys(replacements)).call(_context, prop);
      switch (typeof source[prop]) {
        case 'string':
          if (hasPropReplacement) {
            replaceEventValue(prop);
          }
          break;
        case 'object':
          if (hasPropReplacement) {
            replaceEventValue(prop);
          } else {
            replaceEventValues(source[prop], replacements);
          }
          break;
      }
    }
  }
  return source;
};
const redactUnsafeEventFields = event => {
  return replaceEventValues(event, {
    firstName: '[Redacted]',
    lastName: '[Redacted]',
    email: '[Redacted]'
  });
};
const boot = () => {
  if (window.app.trackingSentry && window.app.trackingSentry !== 'null') {
    var _context2;
    Sentry.init({
      dsn: window.app.trackingSentry,
      release: window.app.revision,
      environment: _concatInstanceProperty(_context2 = "".concat(window.app.env, "-")).call(_context2, window.app.location),
      // In order to reduce the noise in sentry we only track errors that come
      // from our code and ignore errors that come from other services
      // https://blog.sentry.io/2017/03/27/tips-for-reducing-javascript-error-noise.html
      allowUrls: [window.app.cdnUrl, window.app.frontendHost],
      integrations: [new Sentry.Integrations.GlobalHandlers({
        onunhandledrejection: false,
        onerror: false
      }), new BrowserTracing({
        routingInstrumentation: Sentry.reactRouterV5Instrumentation(history)
      })],
      // Sending 5% of transactions. We can adjust that as we see a need to.
      // Generally we need to find a balance between performance and data volume.
      // If we need more flexible and dynamic way of gathering important samples,
      // we can implement the `tracesSampler` function.
      // https://docs.sentry.io/platforms/javascript/guides/react/configuration/sampling/#sampling-transaction-events
      tracesSampleRate: 0.05,
      beforeSend(event) {
        return redactUnsafeEventFields(event);
      }
    });
    Sentry.configureScope(scope => {
      scope.setTag('role', 'frontend');
    });
  }
};
const isExtraAsObject = extrasOrExtra => typeof extrasOrExtra === 'object';
const reportErrorToSentry = (error, extraInfo, getIsEnabled) => {
  const isEnabled = getIsEnabled ? getIsEnabled() : Boolean(window.app.trackingSentry);
  if (typeof error === 'string' && !isEnabled) {
    console.warn('[SENTRY]: You called "reportErrorToSentry" with a string argument. ' + '"Error" objects should be preferred so that a stack-trace can be made available in Sentry. ' + 'See: https://docs.sentry.io/clients/javascript/usage/#try-catch');
  }
  if (isEnabled) {
    if (extraInfo !== null && extraInfo !== void 0 && extraInfo.extra) {
      if (isExtraAsObject(extraInfo.extra)) {
        // See https://docs.sentry.io/platforms/javascript/react/
        Sentry.setExtras(extraInfo.extra);
      } else {
        Sentry.setExtra('extra', extraInfo.extra);
      }
    }
    // Generate a unique ID referring to the last generated Sentry error
    const errorId = sendErrorToSentry(error);

    // The error stack should be available in Sentry, so there is no
    // need to print it in the console as well.
    // We just notify that an error occurred and provide the error ID.
    console.error("[SENTRY]: An error occured (ID: ".concat(errorId, ")."));
    return errorId;
  }
  console.error('[SENTRY]:', error);
  return undefined;
};

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * This component will let sentry know if any information about the user has
 * changed.
 */
let SentryUserTracker = /*#__PURE__*/function (_PureComponent) {
  _inherits(SentryUserTracker, _PureComponent);
  var _super = _createSuper$1(SentryUserTracker);
  function SentryUserTracker() {
    var _this;
    _classCallCheck(this, SentryUserTracker);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.syncUser = () => {
      if (_this.props.user && window.app.trackingSentry) {
        // to avoid sending personal data to sentry we anonymize the email address
        // by only sending the domain part or the email
        const emailTld = _this.props.user.email.split('@')[1];
        Sentry.setUser({
          email: "xxx@".concat(emailTld),
          id: _this.props.user.id
        });
      }
    };
    return _this;
  }
  _createClass(SentryUserTracker, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // since the user and project could have been loaded from the apollo cache
      // they could be preset already when mounting
      this.syncUser();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.syncUser();
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);
  return SentryUserTracker;
}(PureComponent);
SentryUserTracker.displayName = 'SentryUserTracker';
SentryUserTracker.propTypes = process.env.NODE_ENV !== "production" ? {
  user: _pt.shape({
    id: _pt.string.isRequired,
    email: _pt.string.isRequired
  })
} : {};

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
let SentryUserLogoutTracker = /*#__PURE__*/function (_Component) {
  _inherits(SentryUserLogoutTracker, _Component);
  var _super = _createSuper(SentryUserLogoutTracker);
  function SentryUserLogoutTracker() {
    _classCallCheck(this, SentryUserLogoutTracker);
    return _super.apply(this, arguments);
  }
  _createClass(SentryUserLogoutTracker, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // When the user is not logged in anymore (e.g. on logout) we still track
      // errors but without the user data in context.
      if (window.app.trackingSentry) {
        Sentry.configureScope(scope => {
          scope.clear();
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);
  return SentryUserLogoutTracker;
}(Component);
SentryUserLogoutTracker.displayName = 'SentryUserLogoutTracker';

export { SentryUserLogoutTracker, SentryUserTracker, boot, redactUnsafeEventFields, reportErrorToSentry, version };
