'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _JSON$stringify = require('@babel/runtime-corejs3/core-js-stable/json/stringify');
var _includesInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/includes');
var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _concatInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/concat');
var Sentry = require('@sentry/react');
var browser = require('@sentry/browser');
var history = require('@commercetools-frontend/browser-history');
var _Reflect$construct = require('@babel/runtime-corejs3/core-js-stable/reflect/construct');
var _classCallCheck = require('@babel/runtime-corejs3/helpers/classCallCheck');
var _createClass = require('@babel/runtime-corejs3/helpers/createClass');
var _inherits = require('@babel/runtime-corejs3/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime-corejs3/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime-corejs3/helpers/getPrototypeOf');
require('prop-types');
var react = require('react');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var _JSON$stringify__default = /*#__PURE__*/_interopDefault(_JSON$stringify);
var _includesInstanceProperty__default = /*#__PURE__*/_interopDefault(_includesInstanceProperty);
var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _concatInstanceProperty__default = /*#__PURE__*/_interopDefault(_concatInstanceProperty);
var Sentry__namespace = /*#__PURE__*/_interopNamespace(Sentry);
var history__default = /*#__PURE__*/_interopDefault(history);
var _Reflect$construct__default = /*#__PURE__*/_interopDefault(_Reflect$construct);

// NOTE: This string will be replaced on build time with the package version.
var version = "22.13.0";

const makeErrorToCapture = error => {
  if (error instanceof Error) return error;
  if (error instanceof ErrorEvent) return new Error(error.message);
  return new Error(_JSON$stringify__default["default"](error.reason || 'Unhandled rejection without a reason'));
};
const sendErrorToSentry = error => {
  if (typeof error === 'string') return Sentry__namespace.captureMessage(error);
  const errorToCapture = makeErrorToCapture(error);
  return Sentry__namespace.captureException(errorToCapture);
};
const replaceEventValues = (source, replacements) => {
  const replaceEventValue = prop => {
    source[prop] = replacements[prop];
  };
  for (const prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      var _context;
      const hasPropReplacement = _includesInstanceProperty__default["default"](_context = _Object$keys__default["default"](replacements)).call(_context, prop);
      switch (typeof source[prop]) {
        case 'string':
          if (hasPropReplacement) {
            replaceEventValue(prop);
          }
          break;
        case 'object':
          if (hasPropReplacement) {
            replaceEventValue(prop);
          } else {
            replaceEventValues(source[prop], replacements);
          }
          break;
      }
    }
  }
  return source;
};
const redactUnsafeEventFields = event => {
  return replaceEventValues(event, {
    firstName: '[Redacted]',
    lastName: '[Redacted]',
    email: '[Redacted]'
  });
};
const boot = () => {
  if (window.app.trackingSentry && window.app.trackingSentry !== 'null') {
    var _context2;
    Sentry__namespace.init({
      dsn: window.app.trackingSentry,
      release: window.app.revision,
      environment: _concatInstanceProperty__default["default"](_context2 = "".concat(window.app.env, "-")).call(_context2, window.app.location),
      // In order to reduce the noise in sentry we only track errors that come
      // from our code and ignore errors that come from other services
      // https://blog.sentry.io/2017/03/27/tips-for-reducing-javascript-error-noise.html
      allowUrls: [window.app.cdnUrl, window.app.frontendHost],
      integrations: [new Sentry__namespace.Integrations.GlobalHandlers({
        onunhandledrejection: false,
        onerror: false
      }), new browser.BrowserTracing({
        routingInstrumentation: Sentry__namespace.reactRouterV5Instrumentation(history__default["default"])
      })],
      // Sending 5% of transactions. We can adjust that as we see a need to.
      // Generally we need to find a balance between performance and data volume.
      // If we need more flexible and dynamic way of gathering important samples,
      // we can implement the `tracesSampler` function.
      // https://docs.sentry.io/platforms/javascript/guides/react/configuration/sampling/#sampling-transaction-events
      tracesSampleRate: 0.05,
      beforeSend(event) {
        return redactUnsafeEventFields(event);
      }
    });
    Sentry__namespace.configureScope(scope => {
      scope.setTag('role', 'frontend');
    });
  }
};
const isExtraAsObject = extrasOrExtra => typeof extrasOrExtra === 'object';
const reportErrorToSentry = (error, extraInfo, getIsEnabled) => {
  const isEnabled = getIsEnabled ? getIsEnabled() : Boolean(window.app.trackingSentry);
  if (typeof error === 'string' && !isEnabled) {
    console.warn('[SENTRY]: You called "reportErrorToSentry" with a string argument. ' + '"Error" objects should be preferred so that a stack-trace can be made available in Sentry. ' + 'See: https://docs.sentry.io/clients/javascript/usage/#try-catch');
  }
  if (isEnabled) {
    if (extraInfo !== null && extraInfo !== void 0 && extraInfo.extra) {
      if (isExtraAsObject(extraInfo.extra)) {
        // See https://docs.sentry.io/platforms/javascript/react/
        Sentry__namespace.setExtras(extraInfo.extra);
      } else {
        Sentry__namespace.setExtra('extra', extraInfo.extra);
      }
    }
    // Generate a unique ID referring to the last generated Sentry error
    const errorId = sendErrorToSentry(error);

    // The error stack should be available in Sentry, so there is no
    // need to print it in the console as well.
    // We just notify that an error occurred and provide the error ID.
    console.error("[SENTRY]: An error occured (ID: ".concat(errorId, ")."));
    return errorId;
  }
  console.error('[SENTRY]:', error);
  return undefined;
};

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct__default["default"](Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !_Reflect$construct__default["default"]) return false; if (_Reflect$construct__default["default"].sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct__default["default"](Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * This component will let sentry know if any information about the user has
 * changed.
 */
let SentryUserTracker = /*#__PURE__*/function (_PureComponent) {
  _inherits(SentryUserTracker, _PureComponent);
  var _super = _createSuper$1(SentryUserTracker);
  function SentryUserTracker() {
    var _this;
    _classCallCheck(this, SentryUserTracker);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.syncUser = () => {
      if (_this.props.user && window.app.trackingSentry) {
        // to avoid sending personal data to sentry we anonymize the email address
        // by only sending the domain part or the email
        const emailTld = _this.props.user.email.split('@')[1];
        Sentry__namespace.setUser({
          email: "xxx@".concat(emailTld),
          id: _this.props.user.id
        });
      }
    };
    return _this;
  }
  _createClass(SentryUserTracker, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // since the user and project could have been loaded from the apollo cache
      // they could be preset already when mounting
      this.syncUser();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.syncUser();
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);
  return SentryUserTracker;
}(react.PureComponent);
SentryUserTracker.displayName = 'SentryUserTracker';
SentryUserTracker.propTypes = {};

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct__default["default"](Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct__default["default"]) return false; if (_Reflect$construct__default["default"].sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct__default["default"](Boolean, [], function () {})); return true; } catch (e) { return false; } }
let SentryUserLogoutTracker = /*#__PURE__*/function (_Component) {
  _inherits(SentryUserLogoutTracker, _Component);
  var _super = _createSuper(SentryUserLogoutTracker);
  function SentryUserLogoutTracker() {
    _classCallCheck(this, SentryUserLogoutTracker);
    return _super.apply(this, arguments);
  }
  _createClass(SentryUserLogoutTracker, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // When the user is not logged in anymore (e.g. on logout) we still track
      // errors but without the user data in context.
      if (window.app.trackingSentry) {
        Sentry__namespace.configureScope(scope => {
          scope.clear();
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);
  return SentryUserLogoutTracker;
}(react.Component);
SentryUserLogoutTracker.displayName = 'SentryUserLogoutTracker';

exports.SentryUserLogoutTracker = SentryUserLogoutTracker;
exports.SentryUserTracker = SentryUserTracker;
exports.boot = boot;
exports.redactUnsafeEventFields = redactUnsafeEventFields;
exports.reportErrorToSentry = reportErrorToSentry;
exports.version = version;
