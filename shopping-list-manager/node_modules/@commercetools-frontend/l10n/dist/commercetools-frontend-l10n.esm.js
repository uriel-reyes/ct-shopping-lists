import _startsWithInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/starts-with';
import _findInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/find';
import _concatInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/concat';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import PropTypes from 'prop-types';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import { useReducer, useEffect } from 'react';
import { reportErrorToSentry } from '@commercetools-frontend/sentry';
import { jsx } from '@emotion/react/jsx-runtime';
import _reduceInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/reduce';
import _sortInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/sort';
import _mapInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/map';
import _Object$entries from '@babel/runtime-corejs3/core-js-stable/object/entries';
import _parseFloat from '@babel/runtime-corejs3/core-js-stable/parse-float';
import moment from 'moment-timezone';
import omit from 'lodash/omit';

// NOTE: This string will be replaced on build time with the package version.
var version = "22.13.0";

// https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros
const supportedLocales = ["en", "de", "es", "fr-FR", "pt-BR", "zh-CN"];
const mapLocaleToIntlLocale = locale => {
  if (_startsWithInstanceProperty(locale).call(locale, 'de')) return 'de';
  if (_startsWithInstanceProperty(locale).call(locale, 'es')) return 'es';
  if (_startsWithInstanceProperty(locale).call(locale, 'fr')) return 'fr-FR';
  if (locale === 'pt-BR') return 'pt-BR';
  if (locale === 'zh-CN') return 'zh-CN';
  return 'en';
};
const defaultLocale = 'en';
function getSupportedLocales() {
  return supportedLocales;
}

// Given a locale, return the locale only if it's supported.
// If not, return a default locale.
function getSupportedLocale(locale) {
  const isSupported = _findInstanceProperty(supportedLocales).call(supportedLocales, supportedLocale => _startsWithInstanceProperty(locale).call(locale, supportedLocale));
  return isSupported ? locale : defaultLocale;
}

// given a currenyCode and a list of currencies with the following shape
// [{ label, symbol }], we return the symbol.
const getSymbolFromCurrency = (currencyCode, currencies) => {
  if (currencies[currencyCode] && currencies[currencyCode].symbol) {
    return currencies[currencyCode].symbol;
  }
  return '';
};

// From https://github.com/acdlite/recompose/blob/master/src/packages/recompose/getDisplayName.js
const getDisplayName = Component => {
  if (typeof Component === 'string') {
    return Component;
  }
  if (!Component) {
    return undefined;
  }
  return Component.displayName || Component.name || 'Component';
};
const getPrimaryLocale = locale => locale.split('-')[0];
const formatLocalizedFallbackHint = (value, locale) => {
  var _context;
  return _concatInstanceProperty(_context = "".concat(value, " (")).call(_context, locale.toUpperCase(), ")");
};
const findFallbackLocale = (localizedString, fallbackOrder) => {
  var _context2;
  return _findInstanceProperty(_context2 = _concatInstanceProperty(fallbackOrder).call(fallbackOrder, _Object$keys(localizedString))).call(_context2, lang => Boolean(localizedString[lang]));
};

function ownKeys$2(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var _context2, _context3; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context2 = ownKeys$2(Object(t), !0)).call(_context2, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context3 = ownKeys$2(Object(t))).call(_context3, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
const initialState = {
  isLoading: true,
  // Keep it as an empty object, for backwards compatibility
  data: {}
};
function reducer() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  let action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case 'loading':
      return _objectSpread$2(_objectSpread$2({}, state), {}, {
        isLoading: true,
        data: {}
      });
    case 'ok':
      return _objectSpread$2(_objectSpread$2({}, state), {}, {
        isLoading: false,
        data: action.data
      });
    case 'error':
      return _objectSpread$2(_objectSpread$2({}, state), {}, {
        isLoading: false,
        error: action.error
      });
    default:
      return state;
  }
}
function createL10NHook(loadLocale) {
  return locale => {
    const _useReducer = useReducer(reducer, initialState),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      data = _useReducer2[0],
      dispatch = _useReducer2[1];
    useEffect(() => {
      let cleaning = false;
      dispatch({
        type: 'loading'
      });
      async function run() {
        try {
          const data = await loadLocale(locale);
          if (!cleaning) {
            dispatch({
              type: 'ok',
              data
            });
          }
        } catch (error) {
          if (error instanceof Error) {
            reportErrorToSentry(error);
            if (!cleaning) {
              dispatch({
                type: 'error',
                error
              });
            }
          }
        }
      }
      run();
      return () => {
        cleaning = true;
      };
    }, [locale]);
    return data;
  };
}
function createL10NInjector(_ref) {
  let displayName = _ref.displayName,
    propKey = _ref.propKey,
    propLoadingKey = _ref.propLoadingKey,
    loadLocale = _ref.loadLocale;
  return function createHOC(mapPropsToLocale) {
    const useL10n = createL10NHook(loadLocale);
    return WrappedComponent => {
      var _context;
      const L10NComponent = props => {
        const state = useL10n(mapPropsToLocale(props));
        return jsx(WrappedComponent, _objectSpread$2(_objectSpread$2({}, props), {}, {
          [propLoadingKey]: state.isLoading,
          [propKey]: state.data
        }));
      };
      L10NComponent.displayName = _concatInstanceProperty(_context = "".concat(displayName, "(")).call(_context, getDisplayName(WrappedComponent), ")");
      return L10NComponent;
    };
  };
}

const getImportChunk$3 = locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return import( /* webpackChunkName: "country-data-de" */'./de-c86b6188.esm.js');
    case 'es':
      return import( /* webpackChunkName: "country-data-es" */'./es-260e98bc.esm.js');
    case 'fr-FR':
      return import( /* webpackChunkName: "country-data-fr-FR" */'./fr-FR-8225f110.esm.js');
    case 'pt-BR':
      return import( /* webpackChunkName: "country-data-pt-BR" */'./pt-BR-23d7d3ea.esm.js');
    case 'zh-CN':
      return import( /* webpackChunkName: "country-data-zh-CN" */'./zh-CN-60a55020.esm.js');
    default:
      return import( /* webpackChunkName: "country-data-en" */'./en-261128d4.esm.js');
  }
};
const countriesShape = PropTypes.objectOf(PropTypes.string);

/**
 * If running through webpack, code splitting makes `getCountriesForLocale`
 * a function that asynchronously loads the country data.
 */
const getCountriesForLocale = async locale => {
  const supportedLocale = getSupportedLocale(locale);
  // Use default webpackMode (lazy) so that we generate one file per locale.
  // The files are named like "country-data-en-json.chunk.js" after compilation
  // https://webpack.js.org/api/module-methods/#import-
  const countries = await getImportChunk$3(supportedLocale);
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  return countries.default || countries;
};
const withCountries = createL10NInjector({
  displayName: 'withCountries',
  propKey: 'countries',
  propLoadingKey: 'isLoadingCountries',
  loadLocale: getCountriesForLocale
});
const useCountries = createL10NHook(getCountriesForLocale);

const getImportChunk$2 = locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return import( /* webpackChunkName: "currency-data-de" */'./de-b05bdd99.esm.js');
    case 'es':
      return import( /* webpackChunkName: "currency-data-es" */'./es-82efe2f0.esm.js');
    case 'fr-FR':
      return import( /* webpackChunkName: "currency-data-fr-FR" */'./fr-FR-910d88c6.esm.js');
    case 'pt-BR':
      return import( /* webpackChunkName: "currency-data-pt-BR" */'./pt-BR-de2ae554.esm.js');
    case 'zh-CN':
      return import( /* webpackChunkName: "currency-data-zh-CN" */'./zh-CN-57d9ff35.esm.js');
    default:
      return import( /* webpackChunkName: "currency-data-en" */'./en-114d9c70.esm.js');
  }
};
PropTypes.objectOf(PropTypes.shape({
  label: PropTypes.string,
  symbol: PropTypes.string
}));

/**
 * If running through webpack, code splitting makes `getCurrenciesForLocale`
 * a function that asynchronously loads the country data.
 */
const getCurrenciesForLocale = async locale => {
  const supportedLocale = getSupportedLocale(locale);
  // Use default webpackMode (lazy) so that we generate one file per locale.
  // The files are named like "currency-data-en-json.chunk.js" after compilation
  // https://webpack.js.org/api/module-methods/#import-
  const currencies = await getImportChunk$2(supportedLocale);
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  return currencies.default || currencies;
};
const withCurrencies = createL10NInjector({
  displayName: 'withCurrencies',
  propKey: 'currencies',
  propLoadingKey: 'isLoadingCurrencies',
  loadLocale: getCurrenciesForLocale
});
const useCurrencies = createL10NHook(getCurrenciesForLocale);

const getImportChunk$1 = locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return import( /* webpackChunkName: "language-data-de" */'./de-a87de19c.esm.js');
    case 'es':
      return import( /* webpackChunkName: "language-data-es" */'./es-7df7f986.esm.js');
    case 'fr-FR':
      return import( /* webpackChunkName: "language-data-fr-FR" */'./fr-FR-0125c6c5.esm.js');
    case 'pt-BR':
      return import( /* webpackChunkName: "language-data-pt-BR" */'./pt-BR-9eac167d.esm.js');
    case 'zh-CN':
      return import( /* webpackChunkName: "language-data-zh-CN" */'./zh-CN-1e3b78ca.esm.js');
    default:
      return import( /* webpackChunkName: "language-data-en" */'./en-7917b9da.esm.js');
  }
};
const languagesShape = PropTypes.objectOf(PropTypes.shape({
  country: PropTypes.string,
  language: PropTypes.string.isRequired
}));

/**
 * If running through webpack, code splitting makes `getLanguagesForLocale`
 * a function that asynchronously loads the country data.
 */
const getLanguagesForLocale = async locale => {
  const supportedLocale = getSupportedLocale(locale);
  // Use default webpackMode (lazy) so that we generate one file per locale.
  // The files are named like "language-data-en-json.chunk.js" after compilation
  // https://webpack.js.org/api/module-methods/#import-
  const languages = await getImportChunk$1(supportedLocale);
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  return languages.default || languages;
};
const withLanguages = createL10NInjector({
  displayName: 'withLanguages',
  propKey: 'languages',
  propLoadingKey: 'isLoadingLanguages',
  loadLocale: getLanguagesForLocale
});
const useLanguages = createL10NHook(getLanguagesForLocale);

function ownKeys$1(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var _context4, _context5; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context4 = ownKeys$1(Object(t), !0)).call(_context4, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context5 = ownKeys$1(Object(t))).call(_context5, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
const getTranslationsMapChunk = async () => {
  const translationsMapChunk = await import( /* webpackChunkName: "time-zone-translations-map" */'./translations-map-a3b482d1.esm.js');
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  return translationsMapChunk.default || translationsMapChunk;
};

/**
 * Build offset and abbreviation data for each timezone at runtime from moment-timezone
 * in order to return accurate offset values for timezones that have daylight time.
 */
const augmentTimeZoneData = async timeZones => {
  var _context, _context2, _context3;
  const translationsMap = await getTranslationsMapChunk();
  return _reduceInstanceProperty(_context = _sortInstanceProperty(_context2 = _mapInstanceProperty(_context3 = _Object$entries(timeZones)).call(_context3, _ref => {
    let _ref2 = _slicedToArray(_ref, 2),
      id = _ref2[0],
      name = _ref2[1];
    return {
      id,
      name,
      abbr: moment().tz(id).zoneAbbr(),
      offset: moment().tz(id).format('Z'),
      translationFor: translationsMap[id]
    };
  })).call(_context2, (a, b) => _parseFloat(a.offset.replace(':', '.')) - _parseFloat(b.offset.replace(':', '.')))).call(_context, (previousTimeZones, timeZone) => _objectSpread$1(_objectSpread$1({}, previousTimeZones), {}, {
    [timeZone.id]: timeZone
  }), {});
};
const getImportChunk = locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return import( /* webpackChunkName: "timezone-data-de" */'./de-833edb33.esm.js');
    case 'es':
      return import( /* webpackChunkName: "timezone-data-es" */'./es-cd1940a4.esm.js');
    case 'fr-FR':
      return import( /* webpackChunkName: "timezone-data-fr-FR" */'./fr-FR-27ef287f.esm.js');
    case 'pt-BR':
      return import( /* webpackChunkName: "timezone-data-pt-BR" */'./pt-BR-2a6004db.esm.js');
    case 'zh-CN':
      return import( /* webpackChunkName: "timezone-data-zh-CN" */'./zh-CN-1949afc5.esm.js');
    default:
      return import( /* webpackChunkName: "timezone-data-en" */'./en-fb4b590b.esm.js');
  }
};
const timeZonesShape = PropTypes.objectOf(PropTypes.shape({
  label: PropTypes.string,
  abbr: PropTypes.string,
  offset: PropTypes.string,
  translationFor: PropTypes.array
}));

/**
 * If running through webpack, code splitting makes `getTimeZonesForLocale`
 * a function that asynchronously loads the country data.
 */
const getTimeZonesForLocale = async locale => {
  const supportedLocale = getSupportedLocale(locale);
  // Use default webpackMode (lazy) so that we generate one file per locale.
  // The files are named like "time-zone-data-en-json.chunk.js" after compilation
  // https://webpack.js.org/api/module-methods/#import-
  const timeZonesChunk = await getImportChunk(supportedLocale);
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  const timeZones = timeZonesChunk.default || timeZonesChunk;

  // create time zone object with abbreviations and offsets
  const timeZoneData = await augmentTimeZoneData(timeZones);
  return timeZoneData;
};
const withTimeZones = createL10NInjector({
  displayName: 'withTimeZones',
  propKey: 'timeZones',
  propLoadingKey: 'isLoadingTimeZones',
  loadLocale: getTimeZonesForLocale
});
const useTimeZones = createL10NHook(getTimeZonesForLocale);

function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context2, _context3; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context2 = ownKeys(Object(t), !0)).call(_context2, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context3 = ownKeys(Object(t))).call(_context3, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }

/**
 * Transforms a list of `LocalizedField` into a `LocalizedString` object
 * [{ locale: 'sv', value: 'Hej' }] -> { sv: 'Hej' }
 */
const transformLocalizedFieldToLocalizedString = localizedFields => {
  if (!localizedFields || localizedFields.length === 0) return null;
  return _reduceInstanceProperty(localizedFields).call(localizedFields, (nexLocalizedString, field) => _objectSpread(_objectSpread({}, nexLocalizedString), {}, {
    [field.locale]: field.value
  }), {});
};

/**
 * Transforms a `LocalizedString` object into a list of `LocalizedField`
 *
 * { sv: 'Hej' } -> [{ locale: 'sv', value: 'Hej' }]
 */
const transformLocalizedStringToLocalizedField = localizedString => {
  var _context;
  if (!localizedString || _Object$keys(localizedString).length === 0) return [];
  const sorted = _sortInstanceProperty(_context = _Object$keys(localizedString)).call(_context);
  return _reduceInstanceProperty(sorted).call(sorted, (updatedLocalizedField, locale) => [...updatedLocalizedField, {
    locale,
    value: localizedString[locale]
  }], []);
};

/**
 * Given a list of localized field names to map, replace the fields in the
 * format of `LocalizedField` to a `LocalizedString` object.
 * The existing "localized" fields (the list version) will be removed.
 *
 * @param objectWithLocalizedFields
 * the object with `LocalizedField` fields
 * that need to be transformed into `LocalizedString`s
 * @param fieldNames
 * An array of objects with following shape:
 *   * `from`: the field to transform and to remove after
 *   * `to`: the target field to write the transformed shape
 */
const applyTransformedLocalizedFields = (objectWithLocalizedFields, fieldNames) => {
  const transformedFieldDefinitions = _reduceInstanceProperty(fieldNames).call(fieldNames, (nextTransformed, fieldName) => _objectSpread(_objectSpread({}, nextTransformed), {}, {
    [fieldName.to]: transformLocalizedFieldToLocalizedString(objectWithLocalizedFields[fieldName.from])
  }), {});
  const namesToOmit = _mapInstanceProperty(fieldNames).call(fieldNames, fieldName => fieldName.from);
  const objectWithouLocalizedFields = omit(objectWithLocalizedFields, namesToOmit);
  return _objectSpread(_objectSpread({}, objectWithouLocalizedFields), transformedFieldDefinitions);
};

/**
 * Given a list of localized string names to map, replace the fields in the
 * format of `LocalizedString` to a `LocalizedField` object.
 * The existing "localized" strings (the list version) will be removed.
 *
 * @param objectWithLocalizedStrings
 * the object with `LocalizedString` fields
 * that need to be transformed into `LocalizedField`s
 * @param fieldNames
 * An array of objects with following shape:
 *   * `from`: the field to transform and to remove after
 *   * `to`: the target field to write the transformed shape
 */
const applyTransformedLocalizedStrings = (objectWithLocalizedStrings, fieldNames) => {
  const transformedFieldDefinitions = _reduceInstanceProperty(fieldNames).call(fieldNames, (nextTransformed, fieldName) => _objectSpread(_objectSpread({}, nextTransformed), {}, {
    [fieldName.to]: transformLocalizedStringToLocalizedField(objectWithLocalizedStrings[fieldName.from])
  }), {});
  const namesToOmit = _mapInstanceProperty(fieldNames).call(fieldNames, fieldName => fieldName.from);
  const objectWithouLocalizedFields = omit(objectWithLocalizedStrings, namesToOmit);
  return _objectSpread(_objectSpread({}, objectWithouLocalizedFields), transformedFieldDefinitions);
};

/**
 * Translates a localized string on an entity.
 *
 * The `localize` function receives a complete entity that can have several
 * localized fields.
 *
 * Arguments
 *  - `obj`: that entity
 *  - `key`: the field within `obj` that might contain a localized strings
 *  - `locale`: the language key that should be the first choice to show
 *  - `fallbackOrder`: an array of language keys which will be tried in the
 *     provided order for any set value
 *  - `fallback`: the final fallback that should be displayed as a last resort.
 *     This fallback will also be shown in case the field does not exist on the
 *     provided object.
 *
 * Before `fallback` kicks in, the following is tried to display a meaningful value:
 *  - if `locale` is `<language>-<extlang>`, eg. `de-AT`, try if `de` is set
 *  - if not, iterate through all languages of project-settings
 *    (passed as `fallbackOrder`) and pick the first one with a value
 *  - if nothing is found, go through all the languages in provided localized
 *    string an pick the first with a value
 *  - if still no value is found display `fallback`
 *
 * NOTE: It is known that this might lead to strings displayed in different
 *       languages within the same page. This is an accepted downside.
 *
 * NOTE: A missing field is treated like a localied string with no translations:
 *       let a = formatLocalizedString({ name: { en: '', de: '' } }, { locale: 'en' })
 *       let b = formatLocalizedString({}, { locale: 'en' })
 *       let c = formatLocalizedString(undefined, { locale: 'en' })
 *       a === b && a === c -> true
 */
const formatLocalizedString = (entity, _ref) => {
  let _ref$key = _ref.key,
    key = _ref$key === void 0 ? '' : _ref$key,
    locale = _ref.locale,
    _ref$fallbackOrder = _ref.fallbackOrder,
    fallbackOrder = _ref$fallbackOrder === void 0 ? [] : _ref$fallbackOrder,
    _ref$fallback = _ref.fallback,
    fallback = _ref$fallback === void 0 ? '' : _ref$fallback;
  if (!entity || !entity[key]) return fallback;
  const localizedString = entity[key];
  const fallbackLocale = findFallbackLocale(localizedString, fallbackOrder);
  const formattedLocalizedFallback = fallbackLocale ? formatLocalizedFallbackHint(localizedString[fallbackLocale], fallbackLocale) : fallback;

  // GIVEN no `locale`
  // THEN return formattedFallback by fallbackOrder
  if (!locale) return formattedLocalizedFallback;

  // GIVEN locale
  // AND there is a value on `localizedString`
  // THEN return value
  if (localizedString[locale]) return localizedString[locale];

  // GIVEN locale
  // AND there is a value on primary locale
  // THEN return value on primary locale
  const primaryLocale = locale && getPrimaryLocale(locale);
  if (localizedString[primaryLocale]) return localizedString[primaryLocale];

  // use formattedFallback by fallbackOrder as last resort
  return formattedLocalizedFallback;
};

export { applyTransformedLocalizedFields, applyTransformedLocalizedStrings, countriesShape, formatLocalizedString, getSupportedLocale, getSupportedLocales, getSymbolFromCurrency, languagesShape, timeZonesShape, transformLocalizedFieldToLocalizedString, transformLocalizedStringToLocalizedField, useCountries, useCurrencies, useLanguages, useTimeZones, version, withCountries, withCurrencies, withLanguages, withTimeZones };
