'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _classPrivateFieldLooseBase = require('@babel/runtime/helpers/classPrivateFieldLooseBase');
var _classPrivateFieldLooseKey = require('@babel/runtime/helpers/classPrivateFieldLooseKey');
var adapterUtilities = require('@flopflip/adapter-utilities');
var types = require('@flopflip/types');
var mitt = require('mitt');
var warning = require('tiny-warning');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var mitt__default = /*#__PURE__*/_interopDefault(mitt);
var warning__default = /*#__PURE__*/_interopDefault(warning);

const intialAdapterState = {
  configurationStatus: types.AdapterConfigurationStatus.Unconfigured,
  subscriptionStatus: types.AdapterSubscriptionStatus.Subscribed,
  emitter: mitt__default["default"]()
};
var _internalConfiguredStatusChange__ = /*#__PURE__*/_classPrivateFieldLooseKey("__internalConfiguredStatusChange__");
var _adapters = /*#__PURE__*/_classPrivateFieldLooseKey("adapters");
var _adapterState = /*#__PURE__*/_classPrivateFieldLooseKey("adapterState");
var _getHasCombinedAdapters = /*#__PURE__*/_classPrivateFieldLooseKey("getHasCombinedAdapters");
var _getHasArgsForAllAdapters = /*#__PURE__*/_classPrivateFieldLooseKey("getHasArgsForAllAdapters");
var _getIsAdapterUnsubscribed = /*#__PURE__*/_classPrivateFieldLooseKey("getIsAdapterUnsubscribed");
class CombineAdapters {
  constructor() {
    this.id = void 0;
    this.effectIds = void 0;
    // eslint-disable-next-line @typescript-eslint/prefer-readonly
    Object.defineProperty(this, _internalConfiguredStatusChange__, {
      writable: true,
      value: '__internalConfiguredStatusChange__'
    });
    Object.defineProperty(this, _adapters, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _adapterState, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _getHasCombinedAdapters, {
      writable: true,
      value: () => _classPrivateFieldLooseBase(this, _adapters)[_adapters].length > 0
    });
    Object.defineProperty(this, _getHasArgsForAllAdapters, {
      writable: true,
      value: adapterArgs => _classPrivateFieldLooseBase(this, _adapters)[_adapters].every(adapter => adapterArgs[adapter.id])
    });
    Object.defineProperty(this, _getIsAdapterUnsubscribed, {
      writable: true,
      value: () => _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus === types.AdapterSubscriptionStatus.Unsubscribed
    });
    this.updateFlags = (flags, options) => {
      const isAdapterConfigured = this.getIsConfigurationStatus(types.AdapterConfigurationStatus.Configured);
      const hasCombinedAdapters = _classPrivateFieldLooseBase(this, _getHasCombinedAdapters)[_getHasCombinedAdapters]();
      warning__default["default"](isAdapterConfigured, '@flopflip/combine-adapters: adapter is not configured. Flags can not be updated before.');
      warning__default["default"](hasCombinedAdapters, '@flopflip/combine-adapters: adapter has no combined adapters. Please combine before updating flags.');
      if (!isAdapterConfigured || !hasCombinedAdapters) {
        return;
      }
      _classPrivateFieldLooseBase(this, _adapters)[_adapters].forEach(adapter => {
        adapter.updateFlags(flags, options);
      });
    };
    this.reset = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState] = _objectSpread({}, intialAdapterState);
    };
    this.unsubscribe = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus = types.AdapterSubscriptionStatus.Unsubscribed;
    };
    this.subscribe = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus = types.AdapterSubscriptionStatus.Subscribed;
    };
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState] = _objectSpread({}, intialAdapterState);
    this.id = types.adapterIdentifiers.combined;
  }
  combine(adapters) {
    _classPrivateFieldLooseBase(this, _adapters)[_adapters] = adapters;
    this.effectIds = adapters.map(adapter => adapter.id).concat(this.id);
  }
  async configure(adapterArgs, adapterEventHandlers) {
    const hasCombinedAdapters = _classPrivateFieldLooseBase(this, _getHasCombinedAdapters)[_getHasCombinedAdapters]();
    const hasArgsForAllAdapters = _classPrivateFieldLooseBase(this, _getHasArgsForAllAdapters)[_getHasArgsForAllAdapters](adapterArgs);
    warning__default["default"](hasCombinedAdapters, '@flopflip/combine-adapters: adapter has no combined adapters. Please combine before reconfiguring flags.');
    warning__default["default"](hasArgsForAllAdapters, '@flopflip/combine-adapters: not all adapters have args. Please provide args for all adapters.');
    if (!hasCombinedAdapters || !hasArgsForAllAdapters) {
      return Promise.resolve({
        initializationStatus: types.AdapterInitializationStatus.Failed
      });
    }
    const handleStatusChange = nextStatus => {
      if (_classPrivateFieldLooseBase(this, _getIsAdapterUnsubscribed)[_getIsAdapterUnsubscribed]()) return;
      adapterEventHandlers.onStatusStateChange({
        status: nextStatus,
        id: this.id
      });
    };
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on('statusStateChange', handleStatusChange);
    this.setConfigurationStatus(types.AdapterConfigurationStatus.Configuring);
    return Promise.all(_classPrivateFieldLooseBase(this, _adapters)[_adapters].map(async adapter => {
      const adapterArgsForAdapter = adapterArgs[adapter.id];

      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      return adapter.configure(adapterArgsForAdapter, {
        onFlagsStateChange: adapterEventHandlers.onFlagsStateChange,
        onStatusStateChange: adapterEventHandlers.onStatusStateChange
      });
    })).then(allInitializationStatus => {
      const haveAllAdaptersInitializedSuccessfully = allInitializationStatus.every(_ref => {
        let initializationStatus = _ref.initializationStatus;
        return initializationStatus === types.AdapterInitializationStatus.Succeeded;
      });

      // NOTE: We consider this adapter configured if all adapters have been asked to do so
      // and have reported to be initialized successfully.
      this.setConfigurationStatus(types.AdapterConfigurationStatus.Configured);
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit(_classPrivateFieldLooseBase(this, _internalConfiguredStatusChange__)[_internalConfiguredStatusChange__]);
      if (haveAllAdaptersInitializedSuccessfully) {
        return {
          initializationStatus: types.AdapterInitializationStatus.Succeeded
        };
      }

      // NOTE: If not all adapters have initialized successfully we can not consider
      // this adapter being configured fully.
      this.setConfigurationStatus(types.AdapterConfigurationStatus.Unconfigured);
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit(_classPrivateFieldLooseBase(this, _internalConfiguredStatusChange__)[_internalConfiguredStatusChange__]);
      return {
        initializationStatus: types.AdapterInitializationStatus.Failed
      };
    });
  }
  async reconfigure(adapterArgs, adapterEventHandlers) {
    this.setConfigurationStatus(types.AdapterConfigurationStatus.Configuring);
    const hasCombinedAdapters = _classPrivateFieldLooseBase(this, _getHasCombinedAdapters)[_getHasCombinedAdapters]();
    const hasArgsForAllAdapters = _classPrivateFieldLooseBase(this, _getHasArgsForAllAdapters)[_getHasArgsForAllAdapters](adapterArgs);
    warning__default["default"](hasCombinedAdapters, '@flopflip/combine-adapters: adapter has no combined adapters. Please combine before reconfiguring flags.');
    warning__default["default"](hasArgsForAllAdapters, '@flopflip/combine-adapters: not all adapters have args. Please provide args for all adapters.');
    if (!hasCombinedAdapters || !hasArgsForAllAdapters) {
      return Promise.resolve({
        initializationStatus: types.AdapterInitializationStatus.Failed
      });
    }
    return Promise.all(_classPrivateFieldLooseBase(this, _adapters)[_adapters].map(async adapter => {
      const adapterArgsForAdapter = adapterArgs[adapter.id];

      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      return adapter.reconfigure(adapterArgsForAdapter, {
        onFlagsStateChange: adapterEventHandlers.onFlagsStateChange,
        onStatusStateChange: adapterEventHandlers.onStatusStateChange
      });
    })).then(allInitializationStatus => {
      const haveAllAdaptersInitializedSuccessfully = allInitializationStatus.every(_ref2 => {
        let initializationStatus = _ref2.initializationStatus;
        return initializationStatus === types.AdapterInitializationStatus.Succeeded;
      });

      // NOTE: We consider this adapter reconfigured if all adapters have been asked to do so
      // and have reported to be initialized successfully.
      this.setConfigurationStatus(types.AdapterConfigurationStatus.Configured);
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit(_classPrivateFieldLooseBase(this, _internalConfiguredStatusChange__)[_internalConfiguredStatusChange__]);
      if (haveAllAdaptersInitializedSuccessfully) {
        return {
          initializationStatus: types.AdapterInitializationStatus.Succeeded
        };
      }

      // NOTE: If not all adapters have initialized successfully we can not consider
      // this adapter being configured fully.
      this.setConfigurationStatus(types.AdapterConfigurationStatus.Unconfigured);
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit(_classPrivateFieldLooseBase(this, _internalConfiguredStatusChange__)[_internalConfiguredStatusChange__]);
      return {
        initializationStatus: types.AdapterInitializationStatus.Failed
      };
    });
  }
  getIsConfigurationStatus(configurationStatus) {
    return _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus === configurationStatus;
  }
  setConfigurationStatus(nextConfigurationStatus) {
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus = nextConfigurationStatus;
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('statusStateChange', {
      configurationStatus: _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus
    });
  }
  async waitUntilConfigured() {
    return Promise.all(_classPrivateFieldLooseBase(this, _adapters)[_adapters].map(async adapter => {
      var _adapter$waitUntilCon;
      return adapter === null || adapter === void 0 || (_adapter$waitUntilCon = adapter.waitUntilConfigured) === null || _adapter$waitUntilCon === void 0 ? void 0 : _adapter$waitUntilCon.call(adapter);
    }));
  }
}
const adapter = new CombineAdapters();
adapterUtilities.exposeGlobally(adapter);

const version = "13.1.7";

exports["default"] = adapter;
exports.version = version;
