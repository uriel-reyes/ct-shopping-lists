import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import { useAdapterSubscription, ConfigureAdapter, createAdapterContext, AdapterContext, useAdapterContext, selectAdapterConfigurationStatus, getIsFeatureEnabled, getFlagVariation, ToggleFeature as ToggleFeature$1, setDisplayName, wrapDisplayName, DEFAULT_FLAG_PROP_KEY, DEFAULT_FLAGS_PROP_KEY } from '@flopflip/react';
export { ReconfigureAdapter as ReconfigureFlopFlip, useAdapterReconfiguration } from '@flopflip/react';
import { adapterIdentifiers, AdapterSubscriptionStatus, AdapterConfigurationStatus } from '@flopflip/types';
import React, { createContext, useMemo, useCallback, useDebugValue, useContext } from 'react';
import { useSyncExternalStore } from 'use-sync-external-store/shim';

function createStore(initialState) {
  let state = initialState;
  const getSnapshot = () => state;
  const listeners = new Set();
  function setState(fn) {
    state = fn(state);
    listeners.forEach(listener => {
      listener();
    });
  }
  function subscribe(listener) {
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  }
  return {
    getSnapshot,
    setState,
    subscribe
  };
}

const createIntialFlagsContext = (adapterIdentifiers, initialFlags) => Object.fromEntries(Object.values(adapterIdentifiers).map(adapterInterfaceIdentifier => [adapterInterfaceIdentifier, initialFlags]));
const FlagsContext = /*#__PURE__*/createContext(createIntialFlagsContext(adapterIdentifiers, {}));

const store = createStore({
  status: {},
  flags: {}
});
const useFlagsState = _ref => {
  let adapterIdentifiers = _ref.adapterIdentifiers;
  const flags = useSyncExternalStore(store.subscribe, () => store.getSnapshot().flags, () => store.getSnapshot().flags);
  const updateFlags = useCallback(flagsChange => {
    store.setState(prevState => {
      let nextState;
      if (flagsChange.id) {
        nextState = _objectSpread(_objectSpread({}, prevState), {}, {
          flags: _objectSpread(_objectSpread({}, prevState.flags), {}, {
            [flagsChange.id]: _objectSpread(_objectSpread({}, prevState.flags[flagsChange.id]), flagsChange.flags)
          })
        });
        return nextState;
      }
      nextState = _objectSpread(_objectSpread({}, prevState), {}, {
        flags: _objectSpread(_objectSpread({}, prevState.flags), Object.fromEntries(adapterIdentifiers.map(adapterInterfaceIdentifier => [adapterInterfaceIdentifier, _objectSpread(_objectSpread({}, prevState.flags[adapterInterfaceIdentifier]), flagsChange.flags)])))
      });
      return nextState;
    });
  }, [adapterIdentifiers]);
  return [flags, updateFlags];
};
const useStatusState = _ref2 => {
  let adapterIdentifiers = _ref2.adapterIdentifiers;
  const status = useSyncExternalStore(store.subscribe, () => store.getSnapshot().status, () => store.getSnapshot().status);
  const setStatus = useCallback(statusChange => {
    store.setState(prevState => {
      let nextState;
      if (statusChange.id) {
        nextState = _objectSpread(_objectSpread({}, prevState), {}, {
          status: _objectSpread(_objectSpread({}, prevState.status), {}, {
            [statusChange.id]: _objectSpread(_objectSpread({}, prevState.status[statusChange.id]), statusChange.status)
          })
        });
        return nextState;
      }
      nextState = _objectSpread(_objectSpread({}, prevState), {}, {
        status: _objectSpread(_objectSpread({}, prevState.status), Object.fromEntries(adapterIdentifiers.map(adapterInterfaceIdentifier => [adapterInterfaceIdentifier, _objectSpread(_objectSpread({}, prevState.status[adapterInterfaceIdentifier]), statusChange.status)])))
      });
      return nextState;
    });
  }, [adapterIdentifiers]);
  return [status, setStatus];
};
function Configure(props) {
  const adapterIdentifiers = useMemo(() => [props.adapter.id], [props.adapter.id]);
  const _useFlagsState = useFlagsState({
      adapterIdentifiers
    }),
    _useFlagsState2 = _slicedToArray(_useFlagsState, 2),
    flags = _useFlagsState2[0],
    updateFlags = _useFlagsState2[1];
  const _useStatusState = useStatusState({
      adapterIdentifiers
    }),
    _useStatusState2 = _slicedToArray(_useStatusState, 2),
    status = _useStatusState2[0],
    updateStatus = _useStatusState2[1];
  // NOTE:
  //   Using this prevents the callbacks being invoked
  //   which would trigger a setState as a result on an unmounted
  //   component.
  const getHasAdapterSubscriptionStatus = useAdapterSubscription(props.adapter);
  const handleUpdateFlags = useCallback(flagsChange => {
    if (getHasAdapterSubscriptionStatus(AdapterSubscriptionStatus.Unsubscribed)) {
      return;
    }
    updateFlags(flagsChange);
  }, [updateFlags, getHasAdapterSubscriptionStatus]);
  const handleUpdateStatus = useCallback(statusChange => {
    if (getHasAdapterSubscriptionStatus(AdapterSubscriptionStatus.Unsubscribed)) {
      return;
    }
    updateStatus(statusChange);
  }, [updateStatus, getHasAdapterSubscriptionStatus]);
  return /*#__PURE__*/React.createElement(FlagsContext.Provider, {
    value: flags
  }, /*#__PURE__*/React.createElement(ConfigureAdapter, {
    adapter: props.adapter,
    adapterArgs: props.adapterArgs,
    adapterStatus: status,
    defaultFlags: props.defaultFlags,
    shouldDeferAdapterConfiguration: props.shouldDeferAdapterConfiguration,
    onFlagsStateChange: handleUpdateFlags,
    onStatusStateChange: handleUpdateStatus
  }, props.children));
}
Configure.displayName = 'ConfigureFlopflip';
Configure.defaultProps = {
  defaultFlags: {},
  shouldDeferAdapterConfiguration: false
};

const defaultProps = {
  adapterIdentifiers: ['test'],
  status: _objectSpread({}, Object.fromEntries(Object.values(adapterIdentifiers).map(adapterInterfaceIdentifier => [adapterInterfaceIdentifier, {
    subscriptionStatus: AdapterSubscriptionStatus.Subscribed,
    configurationStatus: AdapterConfigurationStatus.Configured
  }])))
};
function TestProvider(props) {
  const adapterContextValue = createAdapterContext(props.adapterIdentifiers, props.reconfigure, props.status);
  const flagsContextValue = createIntialFlagsContext(
  // @ts-expect-error Can not remember. Sorry to myself.
  props.adapterIdentifiers, props.flags);
  return /*#__PURE__*/React.createElement(AdapterContext.Provider, {
    value: adapterContextValue
  }, /*#__PURE__*/React.createElement(FlagsContext.Provider, {
    value: flagsContextValue
  }, props.children));
}
TestProvider.displayName = 'TestProviderFlopFlip';
TestProvider.defaultProps = defaultProps;

function useAdapterStatus() {
  let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    adapterIdentifiers = _ref.adapterIdentifiers;
  const _useAdapterContext = useAdapterContext(),
    status = _useAdapterContext.status;
  const adapterStatus = selectAdapterConfigurationStatus(status, adapterIdentifiers);
  useDebugValue({
    adapterStatus
  });
  return adapterStatus;
}

const useFlagsContext = () => useContext(FlagsContext);

function useFeatureToggle(flagName) {
  let flagVariation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  const adapterContext = useAdapterContext();
  const flagsContext = useFlagsContext();
  const isFeatureEnabled = getIsFeatureEnabled(flagsContext, adapterContext.adapterEffectIdentifiers, flagName, flagVariation);
  useDebugValue({
    flagName,
    flagVariation,
    isEnabled: isFeatureEnabled
  });
  return isFeatureEnabled;
}

function useFeatureToggles(flags) {
  const adapterContext = useAdapterContext();
  const flagsContext = useFlagsContext();
  const requestedFlags = Object.entries(flags).reduce((previousFlags, _ref) => {
    let _ref2 = _slicedToArray(_ref, 2),
      flagName = _ref2[0],
      flagVariation = _ref2[1];
    const isFeatureEnabled = getIsFeatureEnabled(flagsContext, adapterContext.adapterEffectIdentifiers, flagName, flagVariation);
    return [...previousFlags, isFeatureEnabled];
  }, []);
  return requestedFlags;
}

function useFlagVariations(flagNames) {
  const adapterContext = useAdapterContext();
  const flagsContext = useFlagsContext();
  const flagVariations = flagNames.map(requestedVariation => getFlagVariation(flagsContext, adapterContext.adapterEffectIdentifiers, requestedVariation));
  return flagVariations;
}

function useFlagVariation(flagName) {
  const _useFlagVariations = useFlagVariations([flagName]),
    _useFlagVariations2 = _slicedToArray(_useFlagVariations, 1),
    flagVariation = _useFlagVariations2[0];
  return flagVariation;
}

function ToggleFeature(props) {
  const isFeatureEnabled = useFeatureToggle(props.flag, props.variation);

  // @ts-expect-error return type matches
  return /*#__PURE__*/React.createElement(ToggleFeature$1, Object.assign({}, props, {
    isFeatureEnabled: isFeatureEnabled
  }));
}
ToggleFeature.displayName = 'ToggleFeature';

function branchOnFeatureToggle(_ref, UntoggledComponent) {
  let flagName = _ref.flag,
    flagVariation = _ref.variation;
  return ToggledComponent => {
    function WrappedToggledComponent(ownProps) {
      const isFeatureEnabled = useFeatureToggle(flagName, flagVariation);
      if (isFeatureEnabled) return /*#__PURE__*/React.createElement(ToggledComponent, ownProps);
      if (UntoggledComponent) return /*#__PURE__*/React.createElement(UntoggledComponent, ownProps);
      return null;
    }
    return WrappedToggledComponent;
  };
}

function injectFeatureToggle(flagName) {
  let propKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_FLAG_PROP_KEY;
  return Component => {
    function WrappedComponent(ownProps) {
      const _useFlagVariations = useFlagVariations([flagName]),
        _useFlagVariations2 = _slicedToArray(_useFlagVariations, 1),
        flagVariation = _useFlagVariations2[0];
      const props = _objectSpread(_objectSpread({}, ownProps), {}, {
        [propKey]: flagVariation
      });
      return /*#__PURE__*/React.createElement(Component, props);
    }
    setDisplayName(wrapDisplayName(WrappedComponent, 'injectFeatureToggle'));
    return WrappedComponent;
  };
}

function injectFeatureToggles(flagNames) {
  let propKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_FLAGS_PROP_KEY;
  return Component => {
    function WrappedComponent(ownProps) {
      const flagVariations = useFlagVariations(flagNames);
      const flags = Object.fromEntries(flagNames.map((flagName, indexOfFlagName) => [flagName, flagVariations[indexOfFlagName]]));
      const props = _objectSpread(_objectSpread({}, ownProps), {}, {
        [propKey]: flags
      });
      return /*#__PURE__*/React.createElement(Component, props);
    }
    setDisplayName(wrapDisplayName(WrappedComponent, 'injectFeatureToggles'));
    return WrappedComponent;
  };
}

const version = "13.1.7";

export { Configure as ConfigureFlopFlip, TestProvider as TestProviderFlopFlip, ToggleFeature, branchOnFeatureToggle, injectFeatureToggle, injectFeatureToggles, useAdapterStatus, useFeatureToggle, useFeatureToggles, useFlagVariation, useFlagVariations, version };
