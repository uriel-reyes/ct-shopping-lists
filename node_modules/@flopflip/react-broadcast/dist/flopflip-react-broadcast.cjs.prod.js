'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var react = require('@flopflip/react');
var types = require('@flopflip/types');
var React = require('react');
var shim = require('use-sync-external-store/shim');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

function createStore(initialState) {
  let state = initialState;
  const getSnapshot = () => state;
  const listeners = new Set();
  function setState(fn) {
    state = fn(state);
    listeners.forEach(listener => {
      listener();
    });
  }
  function subscribe(listener) {
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  }
  return {
    getSnapshot,
    setState,
    subscribe
  };
}

const createIntialFlagsContext = (adapterIdentifiers, initialFlags) => Object.fromEntries(Object.values(adapterIdentifiers).map(adapterInterfaceIdentifier => [adapterInterfaceIdentifier, initialFlags]));
const FlagsContext = /*#__PURE__*/React.createContext(createIntialFlagsContext(types.adapterIdentifiers, {}));

const store = createStore({
  status: {},
  flags: {}
});
const useFlagsState = _ref => {
  let adapterIdentifiers = _ref.adapterIdentifiers;
  const flags = shim.useSyncExternalStore(store.subscribe, () => store.getSnapshot().flags, () => store.getSnapshot().flags);
  const updateFlags = React.useCallback(flagsChange => {
    store.setState(prevState => {
      let nextState;
      if (flagsChange.id) {
        nextState = _objectSpread(_objectSpread({}, prevState), {}, {
          flags: _objectSpread(_objectSpread({}, prevState.flags), {}, {
            [flagsChange.id]: _objectSpread(_objectSpread({}, prevState.flags[flagsChange.id]), flagsChange.flags)
          })
        });
        return nextState;
      }
      nextState = _objectSpread(_objectSpread({}, prevState), {}, {
        flags: _objectSpread(_objectSpread({}, prevState.flags), Object.fromEntries(adapterIdentifiers.map(adapterInterfaceIdentifier => [adapterInterfaceIdentifier, _objectSpread(_objectSpread({}, prevState.flags[adapterInterfaceIdentifier]), flagsChange.flags)])))
      });
      return nextState;
    });
  }, [adapterIdentifiers]);
  return [flags, updateFlags];
};
const useStatusState = _ref2 => {
  let adapterIdentifiers = _ref2.adapterIdentifiers;
  const status = shim.useSyncExternalStore(store.subscribe, () => store.getSnapshot().status, () => store.getSnapshot().status);
  const setStatus = React.useCallback(statusChange => {
    store.setState(prevState => {
      let nextState;
      if (statusChange.id) {
        nextState = _objectSpread(_objectSpread({}, prevState), {}, {
          status: _objectSpread(_objectSpread({}, prevState.status), {}, {
            [statusChange.id]: _objectSpread(_objectSpread({}, prevState.status[statusChange.id]), statusChange.status)
          })
        });
        return nextState;
      }
      nextState = _objectSpread(_objectSpread({}, prevState), {}, {
        status: _objectSpread(_objectSpread({}, prevState.status), Object.fromEntries(adapterIdentifiers.map(adapterInterfaceIdentifier => [adapterInterfaceIdentifier, _objectSpread(_objectSpread({}, prevState.status[adapterInterfaceIdentifier]), statusChange.status)])))
      });
      return nextState;
    });
  }, [adapterIdentifiers]);
  return [status, setStatus];
};
function Configure(props) {
  const adapterIdentifiers = React.useMemo(() => [props.adapter.id], [props.adapter.id]);
  const _useFlagsState = useFlagsState({
      adapterIdentifiers
    }),
    _useFlagsState2 = _slicedToArray(_useFlagsState, 2),
    flags = _useFlagsState2[0],
    updateFlags = _useFlagsState2[1];
  const _useStatusState = useStatusState({
      adapterIdentifiers
    }),
    _useStatusState2 = _slicedToArray(_useStatusState, 2),
    status = _useStatusState2[0],
    updateStatus = _useStatusState2[1];
  // NOTE:
  //   Using this prevents the callbacks being invoked
  //   which would trigger a setState as a result on an unmounted
  //   component.
  const getHasAdapterSubscriptionStatus = react.useAdapterSubscription(props.adapter);
  const handleUpdateFlags = React.useCallback(flagsChange => {
    if (getHasAdapterSubscriptionStatus(types.AdapterSubscriptionStatus.Unsubscribed)) {
      return;
    }
    updateFlags(flagsChange);
  }, [updateFlags, getHasAdapterSubscriptionStatus]);
  const handleUpdateStatus = React.useCallback(statusChange => {
    if (getHasAdapterSubscriptionStatus(types.AdapterSubscriptionStatus.Unsubscribed)) {
      return;
    }
    updateStatus(statusChange);
  }, [updateStatus, getHasAdapterSubscriptionStatus]);
  return /*#__PURE__*/React__default["default"].createElement(FlagsContext.Provider, {
    value: flags
  }, /*#__PURE__*/React__default["default"].createElement(react.ConfigureAdapter, {
    adapter: props.adapter,
    adapterArgs: props.adapterArgs,
    adapterStatus: status,
    defaultFlags: props.defaultFlags,
    shouldDeferAdapterConfiguration: props.shouldDeferAdapterConfiguration,
    onFlagsStateChange: handleUpdateFlags,
    onStatusStateChange: handleUpdateStatus
  }, props.children));
}
Configure.displayName = 'ConfigureFlopflip';
Configure.defaultProps = {
  defaultFlags: {},
  shouldDeferAdapterConfiguration: false
};

const defaultProps = {
  adapterIdentifiers: ['test'],
  status: _objectSpread({}, Object.fromEntries(Object.values(types.adapterIdentifiers).map(adapterInterfaceIdentifier => [adapterInterfaceIdentifier, {
    subscriptionStatus: types.AdapterSubscriptionStatus.Subscribed,
    configurationStatus: types.AdapterConfigurationStatus.Configured
  }])))
};
function TestProvider(props) {
  const adapterContextValue = react.createAdapterContext(props.adapterIdentifiers, props.reconfigure, props.status);
  const flagsContextValue = createIntialFlagsContext(
  // @ts-expect-error Can not remember. Sorry to myself.
  props.adapterIdentifiers, props.flags);
  return /*#__PURE__*/React__default["default"].createElement(react.AdapterContext.Provider, {
    value: adapterContextValue
  }, /*#__PURE__*/React__default["default"].createElement(FlagsContext.Provider, {
    value: flagsContextValue
  }, props.children));
}
TestProvider.displayName = 'TestProviderFlopFlip';
TestProvider.defaultProps = defaultProps;

function useAdapterStatus() {
  let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    adapterIdentifiers = _ref.adapterIdentifiers;
  const _useAdapterContext = react.useAdapterContext(),
    status = _useAdapterContext.status;
  const adapterStatus = react.selectAdapterConfigurationStatus(status, adapterIdentifiers);
  React.useDebugValue({
    adapterStatus
  });
  return adapterStatus;
}

const useFlagsContext = () => React.useContext(FlagsContext);

function useFeatureToggle(flagName) {
  let flagVariation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  const adapterContext = react.useAdapterContext();
  const flagsContext = useFlagsContext();
  const isFeatureEnabled = react.getIsFeatureEnabled(flagsContext, adapterContext.adapterEffectIdentifiers, flagName, flagVariation);
  React.useDebugValue({
    flagName,
    flagVariation,
    isEnabled: isFeatureEnabled
  });
  return isFeatureEnabled;
}

function useFeatureToggles(flags) {
  const adapterContext = react.useAdapterContext();
  const flagsContext = useFlagsContext();
  const requestedFlags = Object.entries(flags).reduce((previousFlags, _ref) => {
    let _ref2 = _slicedToArray(_ref, 2),
      flagName = _ref2[0],
      flagVariation = _ref2[1];
    const isFeatureEnabled = react.getIsFeatureEnabled(flagsContext, adapterContext.adapterEffectIdentifiers, flagName, flagVariation);
    return [...previousFlags, isFeatureEnabled];
  }, []);
  return requestedFlags;
}

function useFlagVariations(flagNames) {
  const adapterContext = react.useAdapterContext();
  const flagsContext = useFlagsContext();
  const flagVariations = flagNames.map(requestedVariation => react.getFlagVariation(flagsContext, adapterContext.adapterEffectIdentifiers, requestedVariation));
  return flagVariations;
}

function useFlagVariation(flagName) {
  const _useFlagVariations = useFlagVariations([flagName]),
    _useFlagVariations2 = _slicedToArray(_useFlagVariations, 1),
    flagVariation = _useFlagVariations2[0];
  return flagVariation;
}

function ToggleFeature(props) {
  const isFeatureEnabled = useFeatureToggle(props.flag, props.variation);

  // @ts-expect-error return type matches
  return /*#__PURE__*/React__default["default"].createElement(react.ToggleFeature, Object.assign({}, props, {
    isFeatureEnabled: isFeatureEnabled
  }));
}
ToggleFeature.displayName = 'ToggleFeature';

function branchOnFeatureToggle(_ref, UntoggledComponent) {
  let flagName = _ref.flag,
    flagVariation = _ref.variation;
  return ToggledComponent => {
    function WrappedToggledComponent(ownProps) {
      const isFeatureEnabled = useFeatureToggle(flagName, flagVariation);
      if (isFeatureEnabled) return /*#__PURE__*/React__default["default"].createElement(ToggledComponent, ownProps);
      if (UntoggledComponent) return /*#__PURE__*/React__default["default"].createElement(UntoggledComponent, ownProps);
      return null;
    }
    return WrappedToggledComponent;
  };
}

function injectFeatureToggle(flagName) {
  let propKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : react.DEFAULT_FLAG_PROP_KEY;
  return Component => {
    function WrappedComponent(ownProps) {
      const _useFlagVariations = useFlagVariations([flagName]),
        _useFlagVariations2 = _slicedToArray(_useFlagVariations, 1),
        flagVariation = _useFlagVariations2[0];
      const props = _objectSpread(_objectSpread({}, ownProps), {}, {
        [propKey]: flagVariation
      });
      return /*#__PURE__*/React__default["default"].createElement(Component, props);
    }
    react.setDisplayName(react.wrapDisplayName(WrappedComponent, 'injectFeatureToggle'));
    return WrappedComponent;
  };
}

function injectFeatureToggles(flagNames) {
  let propKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : react.DEFAULT_FLAGS_PROP_KEY;
  return Component => {
    function WrappedComponent(ownProps) {
      const flagVariations = useFlagVariations(flagNames);
      const flags = Object.fromEntries(flagNames.map((flagName, indexOfFlagName) => [flagName, flagVariations[indexOfFlagName]]));
      const props = _objectSpread(_objectSpread({}, ownProps), {}, {
        [propKey]: flags
      });
      return /*#__PURE__*/React__default["default"].createElement(Component, props);
    }
    react.setDisplayName(react.wrapDisplayName(WrappedComponent, 'injectFeatureToggles'));
    return WrappedComponent;
  };
}

const version = "13.1.7";

Object.defineProperty(exports, 'ReconfigureFlopFlip', {
  enumerable: true,
  get: function () { return react.ReconfigureAdapter; }
});
Object.defineProperty(exports, 'useAdapterReconfiguration', {
  enumerable: true,
  get: function () { return react.useAdapterReconfiguration; }
});
exports.ConfigureFlopFlip = Configure;
exports.TestProviderFlopFlip = TestProvider;
exports.ToggleFeature = ToggleFeature;
exports.branchOnFeatureToggle = branchOnFeatureToggle;
exports.injectFeatureToggle = injectFeatureToggle;
exports.injectFeatureToggles = injectFeatureToggles;
exports.useAdapterStatus = useAdapterStatus;
exports.useFeatureToggle = useFeatureToggle;
exports.useFeatureToggles = useFeatureToggles;
exports.useFlagVariation = useFlagVariation;
exports.useFlagVariations = useFlagVariations;
exports.version = version;
