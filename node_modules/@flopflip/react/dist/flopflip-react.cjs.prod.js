'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var types = require('@flopflip/types');
var React = require('react');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var warning = require('tiny-warning');
var merge = require('ts-deepmerge');
var reactIs = require('react-is');
var camelCase = require('lodash/camelCase');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefault(React);
var warning__default = /*#__PURE__*/_interopDefault(warning);
var merge__default = /*#__PURE__*/_interopDefault(merge);
var camelCase__default = /*#__PURE__*/_interopDefault(camelCase);

const initialReconfigureAdapter = () => undefined;
const createAdapterContext = (adapterIdentifiers, reconfigure, status) => ({
  adapterEffectIdentifiers: adapterIdentifiers !== null && adapterIdentifiers !== void 0 ? adapterIdentifiers : [],
  reconfigure: reconfigure !== null && reconfigure !== void 0 ? reconfigure : initialReconfigureAdapter,
  status
});
const initialAdapterContext = createAdapterContext();
const AdapterContext = /*#__PURE__*/React.createContext(initialAdapterContext);
function hasEveryAdapterStatus(adapterConfigurationStatus, adaptersStatus, adapterIdentifiers) {
  if (Object.keys(adaptersStatus !== null && adaptersStatus !== void 0 ? adaptersStatus : {}).length === 0) return false;
  if (Array.isArray(adapterIdentifiers)) {
    return adapterIdentifiers.every(adapterIdentifier => {
      var _adaptersStatus$adapt;
      return (adaptersStatus === null || adaptersStatus === void 0 || (_adaptersStatus$adapt = adaptersStatus[adapterIdentifier]) === null || _adaptersStatus$adapt === void 0 ? void 0 : _adaptersStatus$adapt.configurationStatus) === adapterConfigurationStatus;
    });
  }
  return Object.values(adaptersStatus !== null && adaptersStatus !== void 0 ? adaptersStatus : {}).every(adapterStatus => adapterStatus.configurationStatus === adapterConfigurationStatus);
}
const selectAdapterConfigurationStatus = (adaptersStatus, adapterIdentifiers) => {
  const isReady = hasEveryAdapterStatus(types.AdapterConfigurationStatus.Configured, adaptersStatus, adapterIdentifiers);
  const isUnconfigured = hasEveryAdapterStatus(types.AdapterConfigurationStatus.Unconfigured, adaptersStatus, adapterIdentifiers);
  const isConfiguring = hasEveryAdapterStatus(types.AdapterConfigurationStatus.Configuring, adaptersStatus, adapterIdentifiers);
  const isConfigured = hasEveryAdapterStatus(types.AdapterConfigurationStatus.Configured, adaptersStatus, adapterIdentifiers);
  const status = {
    isReady,
    isUnconfigured,
    isConfiguring,
    isConfigured
  };
  return status;
};

const isFunctionChildren = children => typeof children === 'function';
const isEmptyChildren = children => !isFunctionChildren(children) && React.Children.count(children) === 0;
const mergeAdapterArgs = (previousAdapterArgs, _ref) => {
  let nextAdapterArgs = _ref.adapterArgs,
    _ref$options = _ref.options,
    options = _ref$options === void 0 ? {} : _ref$options;
  return options.shouldOverwrite ? nextAdapterArgs : merge__default["default"](previousAdapterArgs, nextAdapterArgs);
};

const AdapterStates = {
  UNCONFIGURED: 'unconfigured',
  CONFIGURING: 'configuring',
  CONFIGURED: 'configured'
};
const useAppliedAdapterArgsState = _ref => {
  let initialAdapterArgs = _ref.initialAdapterArgs;
  const _useState = React.useState(initialAdapterArgs),
    _useState2 = _slicedToArray(_useState, 2),
    appliedAdapterArgs = _useState2[0],
    setAppliedAdapterArgs = _useState2[1];
  const applyAdapterArgs = React.useCallback(nextAdapterArgs => {
    /**
     * NOTE:
     *   We can only unset `pendingAdapterArgs` after we actually perform
     *   a batched `setState` otherwise outdated `adapterArgs` as we loose
     *   the `pendingAdapterArgs` as we unset them too early.
     */
    setAppliedAdapterArgs(nextAdapterArgs);
  }, [setAppliedAdapterArgs]);
  return [appliedAdapterArgs, applyAdapterArgs];
};
const useAdapterStateRef = () => {
  const adapterStateRef = React.useRef(AdapterStates.UNCONFIGURED);
  const setAdapterState = React.useCallback(nextAdapterState => {
    adapterStateRef.current = nextAdapterState;
  }, [adapterStateRef]);
  const getIsAdapterConfigured = React.useCallback(() => adapterStateRef.current === AdapterStates.CONFIGURED, [adapterStateRef]);
  const getDoesAdapterNeedInitialConfiguration = React.useCallback(() => adapterStateRef.current !== AdapterStates.CONFIGURED && adapterStateRef.current !== AdapterStates.CONFIGURING, [adapterStateRef]);
  return [adapterStateRef, setAdapterState, getIsAdapterConfigured, getDoesAdapterNeedInitialConfiguration];
};
const usePendingAdapterArgsRef = appliedAdapterArgs => {
  const pendingAdapterArgsRef = React.useRef(undefined);
  const setPendingAdapterArgs = React.useCallback(nextReconfiguration => {
    var _pendingAdapterArgsRe;
    /**
     * NOTE:
     *    The next reconfiguration is merged into the previous
     *    one instead of maintaining a queue.
     *
     *    The first merge is merged with `appliedAdapter` args
     *    to contain the initial state (through property initializer).
     */
    pendingAdapterArgsRef.current = mergeAdapterArgs((_pendingAdapterArgsRe = pendingAdapterArgsRef.current) !== null && _pendingAdapterArgsRe !== void 0 ? _pendingAdapterArgsRe : appliedAdapterArgs, nextReconfiguration);
  }, [appliedAdapterArgs, pendingAdapterArgsRef]);
  const unsetPendingAdapterArgs = React.useCallback(() => {
    pendingAdapterArgsRef.current = undefined;
  }, [pendingAdapterArgsRef]);

  /**
   * NOTE:
   *    Whenever the adapter delays configuration pending adapterArgs will
   *    be kept on `pendingAdapterArgs`. These can either be populated
   *    from calls to `UNSAFE_componentWillReceiveProps` or through `ReconfigureFlopflip`.
   *    Both cases go through `reconfigureOrQueue`.
   *
   *    In any case, when the adapter should be configured it should either
   *    be passed pending or applied adapterArgs.
   *
   */
  const getAdapterArgsForConfiguration = React.useCallback(() => {
    var _pendingAdapterArgsRe2;
    return (_pendingAdapterArgsRe2 = pendingAdapterArgsRef.current) !== null && _pendingAdapterArgsRe2 !== void 0 ? _pendingAdapterArgsRe2 : appliedAdapterArgs;
  }, [appliedAdapterArgs, pendingAdapterArgsRef]);

  /**
   * NOTE: Clears the pending adapter args when applied adapter args changed.
   */
  React.useEffect(unsetPendingAdapterArgs, [appliedAdapterArgs, unsetPendingAdapterArgs]);
  return [pendingAdapterArgsRef, setPendingAdapterArgs, getAdapterArgsForConfiguration];
};
const useHandleDefaultFlagsCallback = _ref2 => {
  let onFlagsStateChange = _ref2.onFlagsStateChange;
  const handleDefaultFlags = React.useCallback(defaultFlags => {
    if (Object.keys(defaultFlags).length > 0) {
      onFlagsStateChange({
        flags: defaultFlags
      });
    }
  }, [onFlagsStateChange]);
  return handleDefaultFlags;
};
const useConfigurationEffect = _ref3 => {
  let adapter = _ref3.adapter,
    shouldDeferAdapterConfiguration = _ref3.shouldDeferAdapterConfiguration,
    getDoesAdapterNeedInitialConfiguration = _ref3.getDoesAdapterNeedInitialConfiguration,
    setAdapterState = _ref3.setAdapterState,
    onFlagsStateChange = _ref3.onFlagsStateChange,
    onStatusStateChange = _ref3.onStatusStateChange,
    applyAdapterArgs = _ref3.applyAdapterArgs,
    getAdapterArgsForConfiguration = _ref3.getAdapterArgsForConfiguration,
    getIsAdapterConfigured = _ref3.getIsAdapterConfigured,
    pendingAdapterArgsRef = _ref3.pendingAdapterArgsRef,
    appliedAdapterArgs = _ref3.appliedAdapterArgs;
  React.useEffect(() => {
    if (!shouldDeferAdapterConfiguration && getDoesAdapterNeedInitialConfiguration()) {
      setAdapterState(AdapterStates.CONFIGURING);
      adapter.configure(getAdapterArgsForConfiguration(), {
        onFlagsStateChange,
        onStatusStateChange
      }).then(configuration => {
        /**
         * NOTE:
         *    The configuration can be `undefined` then assuming `initializationStatus` to have
         *    succeeded to work with old adapters.
         */
        const isAdapterWithoutInitializationStatus = !(configuration !== null && configuration !== void 0 && configuration.initializationStatus);
        if (isAdapterWithoutInitializationStatus || configuration.initializationStatus === types.AdapterInitializationStatus.Succeeded) {
          setAdapterState(AdapterStates.CONFIGURED);
          if (pendingAdapterArgsRef.current) {
            applyAdapterArgs(pendingAdapterArgsRef.current);
          }
        }
      }).catch(() => {
        warning__default["default"](false, '@flopflip/react: adapter could not be configured.');
      });
    }
    if (getIsAdapterConfigured()) {
      setAdapterState(AdapterStates.CONFIGURING);
      adapter.reconfigure(getAdapterArgsForConfiguration(), {
        onFlagsStateChange,
        onStatusStateChange
      }).then(reconfiguration => {
        /**
         * NOTE:
         *    The configuration can be `undefined` then assuming `initializationStatus` to have
         *    succeeded to work with old adapters.
         */
        const isAdapterWithoutInitializationStatus = !(reconfiguration !== null && reconfiguration !== void 0 && reconfiguration.initializationStatus);
        if (isAdapterWithoutInitializationStatus || reconfiguration.initializationStatus === types.AdapterInitializationStatus.Succeeded) {
          setAdapterState(AdapterStates.CONFIGURED);
        }
      }).catch(() => {
        warning__default["default"](false, '@flopflip/react: adapter could not be reconfigured.');
      });
    }
  }, [adapter, shouldDeferAdapterConfiguration, onFlagsStateChange, onStatusStateChange, applyAdapterArgs, getAdapterArgsForConfiguration, getDoesAdapterNeedInitialConfiguration, getIsAdapterConfigured, setAdapterState, pendingAdapterArgsRef, appliedAdapterArgs]);
};
const useDefaultFlagsEffect = _ref4 => {
  let adapter = _ref4.adapter,
    defaultFlags = _ref4.defaultFlags,
    onFlagsStateChange = _ref4.onFlagsStateChange,
    onStatusStateChange = _ref4.onStatusStateChange,
    setAdapterState = _ref4.setAdapterState,
    pendingAdapterArgsRef = _ref4.pendingAdapterArgsRef,
    shouldDeferAdapterConfiguration = _ref4.shouldDeferAdapterConfiguration,
    applyAdapterArgs = _ref4.applyAdapterArgs,
    getAdapterArgsForConfiguration = _ref4.getAdapterArgsForConfiguration;
  const handleDefaultFlags = useHandleDefaultFlagsCallback({
    onFlagsStateChange
  });
  React.useEffect(() => {
    if (defaultFlags) handleDefaultFlags(defaultFlags);
    if (!shouldDeferAdapterConfiguration) {
      setAdapterState(AdapterStates.CONFIGURING);
      adapter.configure(getAdapterArgsForConfiguration(), {
        onFlagsStateChange,
        onStatusStateChange
      }).then(configuration => {
        /**
         * NOTE:
         *    The configuration can be `undefined` then assuming `initializationStatus` to have
         *    succeeded to work with old adapters.
         */
        const isAdapterWithoutInitializationStatus = !(configuration !== null && configuration !== void 0 && configuration.initializationStatus);
        if (isAdapterWithoutInitializationStatus || configuration.initializationStatus === types.AdapterInitializationStatus.Succeeded) {
          setAdapterState(AdapterStates.CONFIGURED);
          if (pendingAdapterArgsRef.current) {
            applyAdapterArgs(pendingAdapterArgsRef.current);
          }
        }
      }).catch(() => {
        warning__default["default"](false, '@flopflip/react: adapter could not be configured.');
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
};
const usePendingAdapterArgsEffect = _ref5 => {
  let adapterArgs = _ref5.adapterArgs,
    appliedAdapterArgs = _ref5.appliedAdapterArgs,
    applyAdapterArgs = _ref5.applyAdapterArgs,
    getIsAdapterConfigured = _ref5.getIsAdapterConfigured,
    setPendingAdapterArgs = _ref5.setPendingAdapterArgs;
  /**
   * NOTE:
   *   This is passed through the React context (it's a public API).
   *   Internally this component has a `ReconfigureAdapter` type;
   *   this function has two arguments for clarify.
   */
  const reconfigureOrQueue = React.useCallback((nextAdapterArgs, options) => {
    if (getIsAdapterConfigured()) {
      applyAdapterArgs(mergeAdapterArgs(appliedAdapterArgs, {
        adapterArgs: nextAdapterArgs,
        options
      }));
      return;
    }
    setPendingAdapterArgs({
      adapterArgs: nextAdapterArgs,
      options
    });
  }, [appliedAdapterArgs, applyAdapterArgs, getIsAdapterConfigured, setPendingAdapterArgs]);
  React.useEffect(() => {
    if (!getIsAdapterConfigured()) {
      reconfigureOrQueue(adapterArgs, {
        shouldOverwrite: false
      });
    }
  }, [adapterArgs, getIsAdapterConfigured, reconfigureOrQueue]);
  return [reconfigureOrQueue];
};
function ConfigureAdapter(props) {
  var _props$adapter$effect;
  const _useAppliedAdapterArg = useAppliedAdapterArgsState({
      initialAdapterArgs: props.adapterArgs
    }),
    _useAppliedAdapterArg2 = _slicedToArray(_useAppliedAdapterArg, 2),
    appliedAdapterArgs = _useAppliedAdapterArg2[0],
    applyAdapterArgs = _useAppliedAdapterArg2[1];
  const _usePendingAdapterArg = usePendingAdapterArgsRef(appliedAdapterArgs),
    _usePendingAdapterArg2 = _slicedToArray(_usePendingAdapterArg, 3),
    pendingAdapterArgsRef = _usePendingAdapterArg2[0],
    setPendingAdapterArgs = _usePendingAdapterArg2[1],
    getAdapterArgsForConfiguration = _usePendingAdapterArg2[2];
  const _useAdapterStateRef = useAdapterStateRef(),
    _useAdapterStateRef2 = _slicedToArray(_useAdapterStateRef, 4),
    setAdapterState = _useAdapterStateRef2[1],
    getIsAdapterConfigured = _useAdapterStateRef2[2],
    getDoesAdapterNeedInitialConfiguration = _useAdapterStateRef2[3];
  useDefaultFlagsEffect({
    adapter: props.adapter,
    defaultFlags: props.defaultFlags,
    onFlagsStateChange: props.onFlagsStateChange,
    onStatusStateChange: props.onStatusStateChange,
    shouldDeferAdapterConfiguration: props.shouldDeferAdapterConfiguration,
    setAdapterState,
    pendingAdapterArgsRef,
    getAdapterArgsForConfiguration,
    applyAdapterArgs
  });
  const _usePendingAdapterArg3 = usePendingAdapterArgsEffect({
      adapterArgs: props.adapterArgs,
      appliedAdapterArgs,
      applyAdapterArgs,
      getIsAdapterConfigured,
      setPendingAdapterArgs
    }),
    _usePendingAdapterArg4 = _slicedToArray(_usePendingAdapterArg3, 1),
    reconfigureOrQueue = _usePendingAdapterArg4[0];
  useConfigurationEffect({
    adapter: props.adapter,
    shouldDeferAdapterConfiguration: props.shouldDeferAdapterConfiguration,
    onFlagsStateChange: props.onFlagsStateChange,
    onStatusStateChange: props.onStatusStateChange,
    setAdapterState,
    pendingAdapterArgsRef,
    getDoesAdapterNeedInitialConfiguration,
    getAdapterArgsForConfiguration,
    getIsAdapterConfigured,
    applyAdapterArgs,
    appliedAdapterArgs
  });
  const adapterEffectIdentifiers = (_props$adapter$effect = props.adapter.effectIds) !== null && _props$adapter$effect !== void 0 ? _props$adapter$effect : [props.adapter.id];
  return /*#__PURE__*/React__default["default"].createElement(AdapterContext.Provider, {
    value: createAdapterContext(adapterEffectIdentifiers, reconfigureOrQueue, props.adapterStatus)
  }, (() => {
    const isAdapterConfigured = props.adapter.getIsConfigurationStatus(types.AdapterConfigurationStatus.Configured);
    if (isAdapterConfigured) {
      if (typeof props.render === 'function') return props.render();
    }
    if (props.children && isFunctionChildren(props.children)) return props.children({
      isAdapterConfigured
    });
    if (props.children && !isEmptyChildren(props.children)) return React__default["default"].Children.only(props.children);
    return null;
  })());
}
ConfigureAdapter.defaultProps = {
  shouldDeferAdapterConfiguration: false,
  defaultFlags: {},
  children: null,
  render: null
};
ConfigureAdapter.displayName = 'ConfigureAdapter';

const useAdapterContext = () => React.useContext(AdapterContext);

function ReconfigureAdapter(props) {
  const adapterContext = useAdapterContext();
  React.useEffect(() => {
    adapterContext.reconfigure({
      user: props.user
    }, {
      shouldOverwrite: props.shouldOverwrite
    });
  }, [props.user, props.shouldOverwrite, adapterContext]);
  return props.children ? React.Children.only(props.children) : null;
}
ReconfigureAdapter.displayName = 'ReconfigureAdapter';
ReconfigureAdapter.defaultProps = {
  shouldOverwrite: false,
  children: null
};

function ToggleFeature(props) {
  if (props.untoggledComponent) warning__default["default"](reactIs.isValidElementType(props.untoggledComponent), `Invalid prop 'untoggledComponent' supplied to 'ToggleFeature': the prop is not a valid React component`);
  if (props.toggledComponent) warning__default["default"](reactIs.isValidElementType(props.toggledComponent), `Invalid prop 'toggledComponent' supplied to 'ToggleFeature': the prop is not a valid React component`);
  if (props.isFeatureEnabled) {
    if (props.toggledComponent) return /*#__PURE__*/React__default["default"].createElement(props.toggledComponent);
    if (props.children) {
      if (typeof props.children === 'function') return props.children({
        isFeatureEnabled: props.isFeatureEnabled
      });
      return React__default["default"].Children.only(props.children);
    }
    if (typeof props.render === 'function') return props.render();
  }
  if (typeof props.children === 'function') return props.children({
    isFeatureEnabled: props.isFeatureEnabled
  });
  if (props.untoggledComponent) {
    return /*#__PURE__*/React__default["default"].createElement(props.untoggledComponent);
  }
  return null;
}
ToggleFeature.displayName = 'ToggleFeature';

const DEFAULT_FLAG_PROP_KEY = 'isFeatureEnabled';
const DEFAULT_FLAGS_PROP_KEY = 'featureToggles';
const ALL_FLAGS_PROP_KEY = '@flopflip/flags';

const getNormalizedFlagName = flagName => camelCase__default["default"](flagName);

// eslint-disable-next-line no-eq-null, eqeqeq
const isNil = value => value == null;

const getFlagVariation = function (allFlags, adapterIdentifiers) {
  let flagName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_FLAG_PROP_KEY;
  const normalizedFlagName = getNormalizedFlagName(flagName);
  warning__default["default"](normalizedFlagName === flagName, '@flopflip/react: passed flag name does not seem to be normalized which may result in unexpected toggling. Please refer to our readme for more information: https://github.com/tdeekens/flopflip#flag-normalization');
  for (const adapterInterfaceIdentifier of adapterIdentifiers) {
    var _allFlags$adapterInte;
    const flagVariation = (_allFlags$adapterInte = allFlags[adapterInterfaceIdentifier]) === null || _allFlags$adapterInte === void 0 ? void 0 : _allFlags$adapterInte[normalizedFlagName];
    if (!isNil(flagVariation)) {
      return flagVariation;
    }
  }
  return false;
};

const getIsFeatureEnabled = function (allFlags, adapterIdentifiers) {
  let flagName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_FLAG_PROP_KEY;
  let flagVariation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return getFlagVariation(allFlags, adapterIdentifiers, flagName) === flagVariation;
};

var setDisplayName = (nextDisplayName => BaseComponent => {
  BaseComponent.displayName = nextDisplayName;
  return BaseComponent;
});

function wrapDisplayName(BaseComponent, hocName) {
  var _BaseComponent$displa;
  const previousDisplayName = (_BaseComponent$displa = BaseComponent.displayName) !== null && _BaseComponent$displa !== void 0 ? _BaseComponent$displa : BaseComponent.name;
  return `${hocName}(${previousDisplayName !== null && previousDisplayName !== void 0 ? previousDisplayName : 'Component'})`;
}

function useAdapterReconfiguration() {
  const adapterContext = React.useContext(AdapterContext);
  return adapterContext.reconfigure;
}

function useAdapterSubscription(adapter) {
  /**
   * NOTE:
   *    This state needs to be duplicated in a React.ref
   *    as under test multiple instances of flopflip might
   *    be rendered. This yields in them competing in adapter
   *    subscription state (e.g. A unsubscribing and B subscribing
   *    which yields A and B being subscribed as the adapter
   *    is a singleton).
   */
  const useAdapterSubscriptionStatusRef = React.useRef(types.AdapterSubscriptionStatus.Subscribed);
  const subscribe = adapter.subscribe,
    unsubscribe = adapter.unsubscribe;
  React.useEffect(() => {
    if (subscribe) {
      subscribe();
    }
    useAdapterSubscriptionStatusRef.current = types.AdapterSubscriptionStatus.Subscribed;
    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
      useAdapterSubscriptionStatusRef.current = types.AdapterSubscriptionStatus.Unsubscribed;
    };
  }, [subscribe, unsubscribe]);
  return React.useCallback(demandedAdapterSubscriptionStatus => useAdapterSubscriptionStatusRef.current === demandedAdapterSubscriptionStatus, [useAdapterSubscriptionStatusRef]);
}

const version = "13.1.7";

exports.ALL_FLAGS_PROP_KEY = ALL_FLAGS_PROP_KEY;
exports.AdapterContext = AdapterContext;
exports.ConfigureAdapter = ConfigureAdapter;
exports.DEFAULT_FLAGS_PROP_KEY = DEFAULT_FLAGS_PROP_KEY;
exports.DEFAULT_FLAG_PROP_KEY = DEFAULT_FLAG_PROP_KEY;
exports.ReconfigureAdapter = ReconfigureAdapter;
exports.ToggleFeature = ToggleFeature;
exports.createAdapterContext = createAdapterContext;
exports.getFlagVariation = getFlagVariation;
exports.getIsFeatureEnabled = getIsFeatureEnabled;
exports.isNil = isNil;
exports.selectAdapterConfigurationStatus = selectAdapterConfigurationStatus;
exports.setDisplayName = setDisplayName;
exports.useAdapterContext = useAdapterContext;
exports.useAdapterReconfiguration = useAdapterReconfiguration;
exports.useAdapterSubscription = useAdapterSubscription;
exports.version = version;
exports.wrapDisplayName = wrapDisplayName;
