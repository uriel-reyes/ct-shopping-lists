import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _toConsumableArray from '@babel/runtime-corejs3/helpers/esm/toConsumableArray';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _includesInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/includes';
import _concatInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/concat';
import _Symbol$toPrimitive from '@babel/runtime-corejs3/core-js-stable/symbol/to-primitive';
import _objectWithoutProperties from '@babel/runtime-corejs3/helpers/esm/objectWithoutProperties';
import '@babel/runtime-corejs3/core-js-stable/instance/slice';
import _mapInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/map';
import _Object$fromEntries from '@babel/runtime-corejs3/core-js-stable/object/from-entries';
import _Array$isArray from '@babel/runtime-corejs3/core-js-stable/array/is-array';
import _reduceInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/reduce';
import { faker } from '@faker-js/faker';
import { mapValues } from 'lodash';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import _Object$entries from '@babel/runtime-corejs3/core-js-stable/object/entries';

var _excluded = ["name", "__typename"];
function ownKeys$3(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var _context4, _context5; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context4 = ownKeys$3(Object(source), !0)).call(_context4, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context5 = ownKeys$3(Object(source))).call(_context5, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[_Symbol$toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
var isString = function isString(value) {
  return typeof value === 'string';
};
var isBuilderFunction = function isBuilderFunction(value) {
  var _context;
  return _includesInstanceProperty(_context = ['build', 'buildGraphql', 'buildRest']).call(_context, value);
};
var omitOne = function omitOne(entity, prop) {
  var _context2;
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  entity[prop];
    var newState = _objectWithoutProperties(entity, _mapInstanceProperty(_context2 = [prop]).call(_context2, _toPropertyKey));
  return newState;
};
var omitMany = function omitMany(entity) {
  var result = entity;
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }
  _forEachInstanceProperty(props).call(props, function (prop) {
    result = omitOne(result, prop);
  });
  return result;
};
var pickMany = function pickMany(entity) {
  for (var _len2 = arguments.length, props = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    props[_key2 - 1] = arguments[_key2];
  }
  var entries = _mapInstanceProperty(props).call(props, function (prop) {
    return [prop, entity[prop]];
  });
  return _Object$fromEntries(entries);
};
var convertTransformNameToBuildName = function convertTransformNameToBuildName(transformName) {
  switch (transformName) {
    case 'default':
      return 'build';
    case 'graphql':
      return 'buildGraphql';
    case 'rest':
      return 'buildRest';
    default:
      throw new Error("Unknown property build name ".concat(transformName));
  }
};
var toExpandedReference = function toExpandedReference(typeId) {
  return function (data) {
    return typeId && data !== null && data !== void 0 && data.id ? {
      typeId: typeId,
      id: data.id,
      obj: data
    } : null;
  };
};
var toRestPaginatedQueryResult = function toRestPaginatedQueryResult(list) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref$total = _ref.total,
    total = _ref$total === void 0 ? 100 : _ref$total,
    _ref$offset = _ref.offset,
    offset = _ref$offset === void 0 ? 0 : _ref$offset;
  return {
    count: list.length || 0,
    total: total,
    offset: offset,
    results: list
  };
};
var toGraphqlPaginatedQueryResult = function toGraphqlPaginatedQueryResult(list, _ref2) {
  var name = _ref2.name,
    __typename = _ref2.__typename,
    remainingOptions = _objectWithoutProperties(_ref2, _excluded);
  return _objectSpread$3({
    __typename: __typename !== null && __typename !== void 0 ? __typename : "".concat(name, "QueryResult")
  }, toRestPaginatedQueryResult(list, remainingOptions));
};
var buildField = function buildField(builder) {
  var transformName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  var meta = arguments.length > 2 ? arguments[2] : undefined;
  var buildName = convertTransformNameToBuildName(transformName);
  // @ts-ignore: TS does not know about the `Model` being an object.
  var builderField = builder === null || builder === void 0 ? void 0 : builder[buildName];
  // We need to cast this to `() => Model` as otherwise the value is unknown.
  // We know it's a function because of the proxy builder.
  var builderFn = builderField;
  if (!builderFn) {
    var _context3;
    throw new Error(_concatInstanceProperty(_context3 = "Builder with name '".concat(buildName, "' does not exist on field '")).call(_context3, String(meta === null || meta === void 0 ? void 0 : meta.fieldToBuild), "'."));
  }
  return builderFn();
};
var buildFields = function buildFields(builders) {
  var transformName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  var meta = arguments.length > 2 ? arguments[2] : undefined;
  return _mapInstanceProperty(builders).call(builders, function (builder) {
    return buildField(builder, transformName, meta);
  });
};
var buildGraphqlList = function buildGraphqlList(builders, _ref3) {
  var name = _ref3.name,
    total = _ref3.total,
    offset = _ref3.offset,
    __typename = _ref3.__typename;
  return toGraphqlPaginatedQueryResult(buildFields(builders, 'graphql'), {
    name: name,
    __typename: __typename,
    total: total,
    offset: offset
  });
};
var buildRestList = function buildRestList(builders, _ref4) {
  var total = _ref4.total,
    offset = _ref4.offset;
  return toRestPaginatedQueryResult(buildFields(builders, 'rest'), {
    total: total,
    offset: offset
  });
};

function ownKeys$2(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var _context4, _context5; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context4 = ownKeys$2(Object(source), !0)).call(_context4, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context5 = ownKeys$2(Object(source))).call(_context5, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
var CustomProxy = Proxy;

// Internal state object to build up the final model.
var createState = function createState() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    initial = _ref.initial;
  var state = initial ? _objectSpread$2({}, initial) : {};
  return {
    get: function get() {
      return state;
    },
    merge: function merge(update) {
      state = _objectSpread$2(_objectSpread$2({}, state), update);
    },
    set: function set(prop, value) {
      state = _objectSpread$2(_objectSpread$2({}, state), {}, _defineProperty({}, prop, value));
    }
  };
};
function PropertyBuilder(initialProps) {
  var state = createState({
    initial: initialProps
  });
  var builder = new CustomProxy({}, {
    get: function get(_target, prop) {
      switch (prop) {
        case 'get':
          {
            return function () {
              return state.get();
            };
          }
        default:
          {
            return function (fnOrValue) {
              if (isFunction(fnOrValue)) {
                state.merge(fnOrValue(state.get()));
              } else if (isString(prop)) {
                state.set(prop, fnOrValue);
              }
              return builder;
            };
          }
      }
    }
  });
  return builder;
}
function Builder() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    generator = _ref2.generator,
    transformers = _ref2.transformers;
  var applyGeneratorIfExists = function applyGeneratorIfExists() {
    if (!generator) return {};
    return generator.generate();
  };
  var propertyBuilder = PropertyBuilder(applyGeneratorIfExists());
  var builder = {
    proxy: new CustomProxy({}, {
      get: function get(_target, propToSet) {
        var _context;
        // Cypress specs and files that they import are now bundled with
        // webpack starting from Cypress 5 (webpack is now the default preprocessor).
        // This result in non-null check of
        // properties like `__esModule` and `default` to decide what has to be
        // provided as a module export. This means that e.g
        // `empty` in `LocalizedString.presets.empty.en` will be evaluated
        // to the returned function below this check, instead of `Proxy`. To avoid this
        // we need to check against these special properties.
        if (isString(propToSet) && _includesInstanceProperty(_context = ['__esModule', 'default']).call(_context, propToSet)) {
          return builder.proxy;
        }
        if (isBuilderFunction(propToSet)) {
          return function () {
            var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref3$omitFields = _ref3.omitFields,
              omitFields = _ref3$omitFields === void 0 ? [] : _ref3$omitFields,
              _ref3$keepFields = _ref3.keepFields,
              keepFields = _ref3$keepFields === void 0 ? [] : _ref3$keepFields;
            var built = propertyBuilder.get();
            var transformed = built;
            switch (propToSet) {
              case 'build':
                {
                  var _transformers$default, _transformers$default2;
                  transformed = (_transformers$default = transformers === null || transformers === void 0 ? void 0 : (_transformers$default2 = transformers.default) === null || _transformers$default2 === void 0 ? void 0 : _transformers$default2.transform(built)) !== null && _transformers$default !== void 0 ? _transformers$default : built;
                  break;
                }
              case 'buildGraphql':
                {
                  var _transformers$graphql, _transformers$graphql2;
                  transformed = (_transformers$graphql = transformers === null || transformers === void 0 ? void 0 : (_transformers$graphql2 = transformers.graphql) === null || _transformers$graphql2 === void 0 ? void 0 : _transformers$graphql2.transform(built)) !== null && _transformers$graphql !== void 0 ? _transformers$graphql : built;
                  break;
                }
              case 'buildRest':
                {
                  var _transformers$rest$tr, _transformers$rest;
                  transformed = (_transformers$rest$tr = transformers === null || transformers === void 0 ? void 0 : (_transformers$rest = transformers.rest) === null || _transformers$rest === void 0 ? void 0 : _transformers$rest.transform(built)) !== null && _transformers$rest$tr !== void 0 ? _transformers$rest$tr : built;
                  break;
                }
            }
            if (keepFields.length > 0) {
              var _context2;
              return pickMany.apply(void 0, _concatInstanceProperty(_context2 = [transformed]).call(_context2, _toConsumableArray(keepFields)));
            }
            if (omitFields.length > 0) {
              var _context3;
              return omitMany.apply(void 0, _concatInstanceProperty(_context3 = [transformed]).call(_context3, _toConsumableArray(omitFields)));
            }
            return transformed;
          };
        }
        return function (fnOrValue) {
          if (isString(propToSet)) {
            // @ts-ignore: TS does not know about the `Model` being an object.
            var propertyField = propertyBuilder[propToSet];
            var propertyFieldUpdater = propertyField;
            propertyFieldUpdater === null || propertyFieldUpdater === void 0 ? void 0 : propertyFieldUpdater(fnOrValue);
          }
          return builder.proxy;
        };
      }
    })
  };
  return builder.proxy;
}

function ownKeys$1(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys$1(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys$1(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
var isGenerator = function isGenerator(field) {
  if (!field) return false;
  return field.generatorType !== undefined;
};
var identity = function identity(x) {
  return x;
};
var buildTimeTraitsArray = function buildTimeTraitsArray(buildTimeConfig) {
  var _buildTimeConfig$trai = buildTimeConfig.traits,
    traits = _buildTimeConfig$trai === void 0 ? [] : _buildTimeConfig$trai;
  return _Array$isArray(traits) ? traits : [traits];
};
var build = function build(factoryNameOrConfig, configObject) {
  var config = typeof factoryNameOrConfig === 'string' ? configObject : factoryNameOrConfig;
  var sequenceCounter = 0;
  var expandConfigFields = function expandConfigFields(fields) {
    var buildTimeConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var finalBuiltThing = mapValues(fields, function (fieldValue, fieldKey) {
      var overrides = buildTimeConfig.overrides || {};
      var traitsArray = buildTimeTraitsArray(buildTimeConfig);
      var traitOverrides = _reduceInstanceProperty(traitsArray).call(traitsArray, function (overrides, currentTraitKey) {
        var hasTrait = config.traits && config.traits[currentTraitKey];
        if (!hasTrait) {
          console.warn("Warning: trait '".concat(currentTraitKey, "' not found."));
        }
        var traitsConfig = config.traits ? config.traits[currentTraitKey] : {};
        return _objectSpread$1(_objectSpread$1({}, overrides), traitsConfig.overrides || {});
      }, {});
      var valueOrOverride = overrides[fieldKey] || traitOverrides[fieldKey] || fieldValue;

      /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
      return expandConfigField(valueOrOverride);
    });
    return finalBuiltThing;
  };
  var expandConfigField = function expandConfigField(fieldValue) {
    var calculatedValue;
    if (isGenerator(fieldValue)) {
      switch (fieldValue.generatorType) {
        case 'sequence':
          {
            ++sequenceCounter;
            calculatedValue = fieldValue.call(fieldValue.userProvidedFunction, sequenceCounter);
            break;
          }
        case 'faker':
          {
            calculatedValue = fieldValue.call(faker);
            break;
          }
        case 'oneOf':
          {
            calculatedValue = fieldValue.call(fieldValue.options);
            break;
          }
        case 'perBuild':
          {
            calculatedValue = fieldValue.call(fieldValue.func);
            break;
          }
      }
    } else if (_Array$isArray(fieldValue)) {
      calculatedValue = _mapInstanceProperty(fieldValue).call(fieldValue, function (v) {
        return expandConfigField(v);
      });
      return calculatedValue;
    } else if (fieldValue === null || fieldValue === undefined) {
      // has to be before typeof fieldValue === 'object'
      // as typeof null === 'object'
      calculatedValue = fieldValue;
    } else if (typeof fieldValue === 'object') {
      var nestedFieldsObject = fieldValue;
      calculatedValue = expandConfigFields(nestedFieldsObject);
    } else {
      calculatedValue = fieldValue;
    }
    return calculatedValue;
  };
  return function () {
    var buildTimeConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var fieldsToReturn = expandConfigFields(config.fields, buildTimeConfig);
    var traitsArray = buildTimeTraitsArray(buildTimeConfig);
    var traitPostBuilds = _mapInstanceProperty(traitsArray).call(traitsArray, function (traitName) {
      var traitConfig = config.traits && config.traits[traitName] || {};
      var postBuild = traitConfig.postBuild || identity;
      return postBuild;
    });
    var afterTraitPostBuildFields = _reduceInstanceProperty(traitPostBuilds).call(traitPostBuilds, function (fields, traitPostBuild) {
      return traitPostBuild(fields);
    }, fieldsToReturn);
    var postBuild = config.postBuild || identity;
    var buildTimeMapFunc = _mapInstanceProperty(buildTimeConfig) || identity;
    return buildTimeMapFunc(postBuild(afterTraitPostBuildFields));
  };
};
var oneOf = function oneOf() {
  for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
    options[_key] = arguments[_key];
  }
  return {
    generatorType: 'oneOf',
    options: options,
    call: function call(options) {
      var randomIndex = Math.floor(Math.random() * options.length);
      return options[randomIndex];
    }
  };
};
var bool = function bool() {
  return oneOf(true, false);
};
var sequence = function sequence() {
  var userProvidedFunction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (x) {
    return x;
  };
  return {
    generatorType: 'sequence',
    userProvidedFunction: userProvidedFunction,
    call: function call(userProvidedFunction, counter) {
      return userProvidedFunction(counter);
    }
  };
};
var fake = function fake(userDefinedUsage) {
  return {
    generatorType: 'faker',
    call: function call(faker) {
      return userDefinedUsage(faker);
    }
  };
};

function Generator(_ref) {
  var fields = _ref.fields,
    postBuild = _ref.postBuild;
  var originalGenerate = build({
    fields: fields,
    postBuild: postBuild
  });
  return {
    generate: function generate() {
      return originalGenerate();
    }
  };
}

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context2, _context3; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context2 = ownKeys(Object(source), !0)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context3 = ownKeys(Object(source))).call(_context3, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
function Transformer(transformType, transformOptions) {
  function transform(fields) {
    var transformedFields = _objectSpread({}, fields);
    var fieldsReplacer = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.replaceFields;
    var fieldsAdder = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.addFields;
    var fieldsToRemove = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.removeFields;
    var fieldsToBuild = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.buildFields;
    if (fieldsToBuild) {
      _forEachInstanceProperty(fieldsToBuild).call(fieldsToBuild, function (fieldToBuild) {
        var field = transformedFields[fieldToBuild];
        // Build only fields that are not null or undefined
        if (field) {
          transformedFields = _objectSpread(_objectSpread({}, transformedFields), {}, _defineProperty({}, fieldToBuild, _Array$isArray(field) ? buildFields(field, transformType, {
            fieldToBuild: fieldToBuild
          }) : buildField(field, transformType, {
            fieldToBuild: fieldToBuild
          })));
        }
      });
    }

    // The default transformer only allows building nested fields to not
    // allow re-transforming model shape
    if (transformType === 'default') {
      return transformedFields;
    }

    // If this is defined, all other options are ignored, as the transformed value
    // can be anything (object, array, scalar, etc.).
    if (fieldsReplacer) {
      if (fieldsAdder) {
        console.warn("The \"replaceFields\" option takes precedence over the \"addFields\" option, making it unused.");
      }
      if (fieldsToRemove) {
        console.warn("The \"replaceFields\" option takes precedence over the \"removeFields\" option, making it unused.");
      }
      return fieldsReplacer({
        fields: transformedFields
      });
    }
    if (fieldsAdder) {
      var _context;
      var fieldsToAdd = fieldsAdder({
        fields: fields
      });
      _forEachInstanceProperty(_context = _Object$entries(fieldsToAdd)).call(_context, function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          fieldName = _ref2[0],
          fieldValue = _ref2[1];
        // @ts-ignore: TS does not know about the `Model` being an object.
        if (transformedFields[fieldName]) return;
        transformedFields = _objectSpread(_objectSpread({}, transformedFields), {}, _defineProperty({}, fieldName, fieldValue));
      });
    }
    if (fieldsToRemove) {
      _forEachInstanceProperty(fieldsToRemove).call(fieldsToRemove, function (fieldToRemove) {
        delete transformedFields[fieldToRemove];
      });
    }
    return transformedFields;
  }
  return {
    type: transformType,
    transform: transform
  };
}

export { Builder, Generator, Transformer, bool, buildField, buildFields, buildGraphqlList, buildRestList, fake, oneOf, sequence, toExpandedReference, toGraphqlPaginatedQueryResult, toRestPaginatedQueryResult };
