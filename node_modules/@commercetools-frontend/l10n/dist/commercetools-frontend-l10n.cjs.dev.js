'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _startsWithInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/starts-with');
var _findInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/find');
var _concatInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/concat');
var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var PropTypes = require('prop-types');
var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var _slicedToArray = require('@babel/runtime-corejs3/helpers/slicedToArray');
var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
var react = require('react');
var sentry = require('@commercetools-frontend/sentry');
var jsxRuntime = require('@emotion/react/jsx-runtime');
var _reduceInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/reduce');
var _sortInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/sort');
var _mapInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/map');
var _Object$entries = require('@babel/runtime-corejs3/core-js-stable/object/entries');
var _parseFloat = require('@babel/runtime-corejs3/core-js-stable/parse-float');
var moment = require('moment-timezone');
var omit = require('lodash/omit');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _startsWithInstanceProperty__default = /*#__PURE__*/_interopDefault(_startsWithInstanceProperty);
var _findInstanceProperty__default = /*#__PURE__*/_interopDefault(_findInstanceProperty);
var _concatInstanceProperty__default = /*#__PURE__*/_interopDefault(_concatInstanceProperty);
var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var PropTypes__default = /*#__PURE__*/_interopDefault(PropTypes);
var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var _reduceInstanceProperty__default = /*#__PURE__*/_interopDefault(_reduceInstanceProperty);
var _sortInstanceProperty__default = /*#__PURE__*/_interopDefault(_sortInstanceProperty);
var _mapInstanceProperty__default = /*#__PURE__*/_interopDefault(_mapInstanceProperty);
var _Object$entries__default = /*#__PURE__*/_interopDefault(_Object$entries);
var _parseFloat__default = /*#__PURE__*/_interopDefault(_parseFloat);
var moment__default = /*#__PURE__*/_interopDefault(moment);
var omit__default = /*#__PURE__*/_interopDefault(omit);

// NOTE: This string will be replaced on build time with the package version.
var version = "22.13.0";

// https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros
const supportedLocales = ["en", "de", "es", "fr-FR", "pt-BR", "zh-CN"];
const mapLocaleToIntlLocale = locale => {
  if (_startsWithInstanceProperty__default["default"](locale).call(locale, 'de')) return 'de';
  if (_startsWithInstanceProperty__default["default"](locale).call(locale, 'es')) return 'es';
  if (_startsWithInstanceProperty__default["default"](locale).call(locale, 'fr')) return 'fr-FR';
  if (locale === 'pt-BR') return 'pt-BR';
  if (locale === 'zh-CN') return 'zh-CN';
  return 'en';
};
const defaultLocale = 'en';
function getSupportedLocales() {
  return supportedLocales;
}

// Given a locale, return the locale only if it's supported.
// If not, return a default locale.
function getSupportedLocale(locale) {
  const isSupported = _findInstanceProperty__default["default"](supportedLocales).call(supportedLocales, supportedLocale => _startsWithInstanceProperty__default["default"](locale).call(locale, supportedLocale));
  return isSupported ? locale : defaultLocale;
}

// given a currenyCode and a list of currencies with the following shape
// [{ label, symbol }], we return the symbol.
const getSymbolFromCurrency = (currencyCode, currencies) => {
  if (currencies[currencyCode] && currencies[currencyCode].symbol) {
    return currencies[currencyCode].symbol;
  }
  return '';
};

// From https://github.com/acdlite/recompose/blob/master/src/packages/recompose/getDisplayName.js
const getDisplayName = Component => {
  if (typeof Component === 'string') {
    return Component;
  }
  if (!Component) {
    return undefined;
  }
  return Component.displayName || Component.name || 'Component';
};
const getPrimaryLocale = locale => locale.split('-')[0];
const formatLocalizedFallbackHint = (value, locale) => {
  var _context;
  return _concatInstanceProperty__default["default"](_context = "".concat(value, " (")).call(_context, locale.toUpperCase(), ")");
};
const findFallbackLocale = (localizedString, fallbackOrder) => {
  var _context2;
  return _findInstanceProperty__default["default"](_context2 = _concatInstanceProperty__default["default"](fallbackOrder).call(fallbackOrder, _Object$keys__default["default"](localizedString))).call(_context2, lang => Boolean(localizedString[lang]));
};

function ownKeys$2(e, r) { var t = _Object$keys__default["default"](e); if (_Object$getOwnPropertySymbols__default["default"]) { var o = _Object$getOwnPropertySymbols__default["default"](e); r && (o = _filterInstanceProperty__default["default"](o).call(o, function (r) { return _Object$getOwnPropertyDescriptor__default["default"](e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var _context2, _context3; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty__default["default"](_context2 = ownKeys$2(Object(t), !0)).call(_context2, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](e, _Object$getOwnPropertyDescriptors__default["default"](t)) : _forEachInstanceProperty__default["default"](_context3 = ownKeys$2(Object(t))).call(_context3, function (r) { _Object$defineProperty__default["default"](e, r, _Object$getOwnPropertyDescriptor__default["default"](t, r)); }); } return e; }
const initialState = {
  isLoading: true,
  // Keep it as an empty object, for backwards compatibility
  data: {}
};
function reducer() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  let action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case 'loading':
      return _objectSpread$2(_objectSpread$2({}, state), {}, {
        isLoading: true,
        data: {}
      });
    case 'ok':
      return _objectSpread$2(_objectSpread$2({}, state), {}, {
        isLoading: false,
        data: action.data
      });
    case 'error':
      return _objectSpread$2(_objectSpread$2({}, state), {}, {
        isLoading: false,
        error: action.error
      });
    default:
      return state;
  }
}
function createL10NHook(loadLocale) {
  return locale => {
    const _useReducer = react.useReducer(reducer, initialState),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      data = _useReducer2[0],
      dispatch = _useReducer2[1];
    react.useEffect(() => {
      let cleaning = false;
      dispatch({
        type: 'loading'
      });
      async function run() {
        try {
          const data = await loadLocale(locale);
          if (!cleaning) {
            dispatch({
              type: 'ok',
              data
            });
          }
        } catch (error) {
          if (error instanceof Error) {
            sentry.reportErrorToSentry(error);
            if (!cleaning) {
              dispatch({
                type: 'error',
                error
              });
            }
          }
        }
      }
      run();
      return () => {
        cleaning = true;
      };
    }, [locale]);
    return data;
  };
}
function createL10NInjector(_ref) {
  let displayName = _ref.displayName,
    propKey = _ref.propKey,
    propLoadingKey = _ref.propLoadingKey,
    loadLocale = _ref.loadLocale;
  return function createHOC(mapPropsToLocale) {
    const useL10n = createL10NHook(loadLocale);
    return WrappedComponent => {
      var _context;
      const L10NComponent = props => {
        const state = useL10n(mapPropsToLocale(props));
        return jsxRuntime.jsx(WrappedComponent, _objectSpread$2(_objectSpread$2({}, props), {}, {
          [propLoadingKey]: state.isLoading,
          [propKey]: state.data
        }));
      };
      L10NComponent.displayName = _concatInstanceProperty__default["default"](_context = "".concat(displayName, "(")).call(_context, getDisplayName(WrappedComponent), ")");
      return L10NComponent;
    };
  };
}

const getImportChunk$3 = locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "country-data-de" */'./de-d39b5241.cjs.dev.js'); });
    case 'es':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "country-data-es" */'./es-8c811c5d.cjs.dev.js'); });
    case 'fr-FR':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "country-data-fr-FR" */'./fr-FR-25212b0c.cjs.dev.js'); });
    case 'pt-BR':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "country-data-pt-BR" */'./pt-BR-069d8608.cjs.dev.js'); });
    case 'zh-CN':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "country-data-zh-CN" */'./zh-CN-7b011ecd.cjs.dev.js'); });
    default:
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "country-data-en" */'./en-e789e674.cjs.dev.js'); });
  }
};
const countriesShape = PropTypes__default["default"].objectOf(PropTypes__default["default"].string);

/**
 * If running through webpack, code splitting makes `getCountriesForLocale`
 * a function that asynchronously loads the country data.
 */
const getCountriesForLocale = async locale => {
  const supportedLocale = getSupportedLocale(locale);
  // Use default webpackMode (lazy) so that we generate one file per locale.
  // The files are named like "country-data-en-json.chunk.js" after compilation
  // https://webpack.js.org/api/module-methods/#import-
  const countries = await getImportChunk$3(supportedLocale);
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  return countries.default || countries;
};
const withCountries = createL10NInjector({
  displayName: 'withCountries',
  propKey: 'countries',
  propLoadingKey: 'isLoadingCountries',
  loadLocale: getCountriesForLocale
});
const useCountries = createL10NHook(getCountriesForLocale);

const getImportChunk$2 = locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "currency-data-de" */'./de-ca036c44.cjs.dev.js'); });
    case 'es':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "currency-data-es" */'./es-4397451e.cjs.dev.js'); });
    case 'fr-FR':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "currency-data-fr-FR" */'./fr-FR-21bff82c.cjs.dev.js'); });
    case 'pt-BR':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "currency-data-pt-BR" */'./pt-BR-56b9a070.cjs.dev.js'); });
    case 'zh-CN':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "currency-data-zh-CN" */'./zh-CN-eb69d16d.cjs.dev.js'); });
    default:
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "currency-data-en" */'./en-dd33a580.cjs.dev.js'); });
  }
};
PropTypes__default["default"].objectOf(PropTypes__default["default"].shape({
  label: PropTypes__default["default"].string,
  symbol: PropTypes__default["default"].string
}));

/**
 * If running through webpack, code splitting makes `getCurrenciesForLocale`
 * a function that asynchronously loads the country data.
 */
const getCurrenciesForLocale = async locale => {
  const supportedLocale = getSupportedLocale(locale);
  // Use default webpackMode (lazy) so that we generate one file per locale.
  // The files are named like "currency-data-en-json.chunk.js" after compilation
  // https://webpack.js.org/api/module-methods/#import-
  const currencies = await getImportChunk$2(supportedLocale);
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  return currencies.default || currencies;
};
const withCurrencies = createL10NInjector({
  displayName: 'withCurrencies',
  propKey: 'currencies',
  propLoadingKey: 'isLoadingCurrencies',
  loadLocale: getCurrenciesForLocale
});
const useCurrencies = createL10NHook(getCurrenciesForLocale);

const getImportChunk$1 = locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "language-data-de" */'./de-c40e9304.cjs.dev.js'); });
    case 'es':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "language-data-es" */'./es-6548a7f6.cjs.dev.js'); });
    case 'fr-FR':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "language-data-fr-FR" */'./fr-FR-92e1c6b8.cjs.dev.js'); });
    case 'pt-BR':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "language-data-pt-BR" */'./pt-BR-795175d5.cjs.dev.js'); });
    case 'zh-CN':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "language-data-zh-CN" */'./zh-CN-b4b12694.cjs.dev.js'); });
    default:
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "language-data-en" */'./en-a3711289.cjs.dev.js'); });
  }
};
const languagesShape = PropTypes__default["default"].objectOf(PropTypes__default["default"].shape({
  country: PropTypes__default["default"].string,
  language: PropTypes__default["default"].string.isRequired
}));

/**
 * If running through webpack, code splitting makes `getLanguagesForLocale`
 * a function that asynchronously loads the country data.
 */
const getLanguagesForLocale = async locale => {
  const supportedLocale = getSupportedLocale(locale);
  // Use default webpackMode (lazy) so that we generate one file per locale.
  // The files are named like "language-data-en-json.chunk.js" after compilation
  // https://webpack.js.org/api/module-methods/#import-
  const languages = await getImportChunk$1(supportedLocale);
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  return languages.default || languages;
};
const withLanguages = createL10NInjector({
  displayName: 'withLanguages',
  propKey: 'languages',
  propLoadingKey: 'isLoadingLanguages',
  loadLocale: getLanguagesForLocale
});
const useLanguages = createL10NHook(getLanguagesForLocale);

function ownKeys$1(e, r) { var t = _Object$keys__default["default"](e); if (_Object$getOwnPropertySymbols__default["default"]) { var o = _Object$getOwnPropertySymbols__default["default"](e); r && (o = _filterInstanceProperty__default["default"](o).call(o, function (r) { return _Object$getOwnPropertyDescriptor__default["default"](e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var _context4, _context5; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty__default["default"](_context4 = ownKeys$1(Object(t), !0)).call(_context4, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](e, _Object$getOwnPropertyDescriptors__default["default"](t)) : _forEachInstanceProperty__default["default"](_context5 = ownKeys$1(Object(t))).call(_context5, function (r) { _Object$defineProperty__default["default"](e, r, _Object$getOwnPropertyDescriptor__default["default"](t, r)); }); } return e; }
const getTranslationsMapChunk = async () => {
  const translationsMapChunk = await Promise.resolve().then(function () { return require( /* webpackChunkName: "time-zone-translations-map" */'./translations-map-0e2bd91e.cjs.dev.js'); });
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  return translationsMapChunk.default || translationsMapChunk;
};

/**
 * Build offset and abbreviation data for each timezone at runtime from moment-timezone
 * in order to return accurate offset values for timezones that have daylight time.
 */
const augmentTimeZoneData = async timeZones => {
  var _context, _context2, _context3;
  const translationsMap = await getTranslationsMapChunk();
  return _reduceInstanceProperty__default["default"](_context = _sortInstanceProperty__default["default"](_context2 = _mapInstanceProperty__default["default"](_context3 = _Object$entries__default["default"](timeZones)).call(_context3, _ref => {
    let _ref2 = _slicedToArray(_ref, 2),
      id = _ref2[0],
      name = _ref2[1];
    return {
      id,
      name,
      abbr: moment__default["default"]().tz(id).zoneAbbr(),
      offset: moment__default["default"]().tz(id).format('Z'),
      translationFor: translationsMap[id]
    };
  })).call(_context2, (a, b) => _parseFloat__default["default"](a.offset.replace(':', '.')) - _parseFloat__default["default"](b.offset.replace(':', '.')))).call(_context, (previousTimeZones, timeZone) => _objectSpread$1(_objectSpread$1({}, previousTimeZones), {}, {
    [timeZone.id]: timeZone
  }), {});
};
const getImportChunk = locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "timezone-data-de" */'./de-a35429c3.cjs.dev.js'); });
    case 'es':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "timezone-data-es" */'./es-dac5d844.cjs.dev.js'); });
    case 'fr-FR':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "timezone-data-fr-FR" */'./fr-FR-0bcee641.cjs.dev.js'); });
    case 'pt-BR':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "timezone-data-pt-BR" */'./pt-BR-0dac9697.cjs.dev.js'); });
    case 'zh-CN':
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "timezone-data-zh-CN" */'./zh-CN-e4b0166a.cjs.dev.js'); });
    default:
      return Promise.resolve().then(function () { return require( /* webpackChunkName: "timezone-data-en" */'./en-c5d0a319.cjs.dev.js'); });
  }
};
const timeZonesShape = PropTypes__default["default"].objectOf(PropTypes__default["default"].shape({
  label: PropTypes__default["default"].string,
  abbr: PropTypes__default["default"].string,
  offset: PropTypes__default["default"].string,
  translationFor: PropTypes__default["default"].array
}));

/**
 * If running through webpack, code splitting makes `getTimeZonesForLocale`
 * a function that asynchronously loads the country data.
 */
const getTimeZonesForLocale = async locale => {
  const supportedLocale = getSupportedLocale(locale);
  // Use default webpackMode (lazy) so that we generate one file per locale.
  // The files are named like "time-zone-data-en-json.chunk.js" after compilation
  // https://webpack.js.org/api/module-methods/#import-
  const timeZonesChunk = await getImportChunk(supportedLocale);
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  const timeZones = timeZonesChunk.default || timeZonesChunk;

  // create time zone object with abbreviations and offsets
  const timeZoneData = await augmentTimeZoneData(timeZones);
  return timeZoneData;
};
const withTimeZones = createL10NInjector({
  displayName: 'withTimeZones',
  propKey: 'timeZones',
  propLoadingKey: 'isLoadingTimeZones',
  loadLocale: getTimeZonesForLocale
});
const useTimeZones = createL10NHook(getTimeZonesForLocale);

function ownKeys(e, r) { var t = _Object$keys__default["default"](e); if (_Object$getOwnPropertySymbols__default["default"]) { var o = _Object$getOwnPropertySymbols__default["default"](e); r && (o = _filterInstanceProperty__default["default"](o).call(o, function (r) { return _Object$getOwnPropertyDescriptor__default["default"](e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context2, _context3; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty__default["default"](_context2 = ownKeys(Object(t), !0)).call(_context2, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](e, _Object$getOwnPropertyDescriptors__default["default"](t)) : _forEachInstanceProperty__default["default"](_context3 = ownKeys(Object(t))).call(_context3, function (r) { _Object$defineProperty__default["default"](e, r, _Object$getOwnPropertyDescriptor__default["default"](t, r)); }); } return e; }

/**
 * Transforms a list of `LocalizedField` into a `LocalizedString` object
 * [{ locale: 'sv', value: 'Hej' }] -> { sv: 'Hej' }
 */
const transformLocalizedFieldToLocalizedString = localizedFields => {
  if (!localizedFields || localizedFields.length === 0) return null;
  return _reduceInstanceProperty__default["default"](localizedFields).call(localizedFields, (nexLocalizedString, field) => _objectSpread(_objectSpread({}, nexLocalizedString), {}, {
    [field.locale]: field.value
  }), {});
};

/**
 * Transforms a `LocalizedString` object into a list of `LocalizedField`
 *
 * { sv: 'Hej' } -> [{ locale: 'sv', value: 'Hej' }]
 */
const transformLocalizedStringToLocalizedField = localizedString => {
  var _context;
  if (!localizedString || _Object$keys__default["default"](localizedString).length === 0) return [];
  const sorted = _sortInstanceProperty__default["default"](_context = _Object$keys__default["default"](localizedString)).call(_context);
  return _reduceInstanceProperty__default["default"](sorted).call(sorted, (updatedLocalizedField, locale) => [...updatedLocalizedField, {
    locale,
    value: localizedString[locale]
  }], []);
};

/**
 * Given a list of localized field names to map, replace the fields in the
 * format of `LocalizedField` to a `LocalizedString` object.
 * The existing "localized" fields (the list version) will be removed.
 *
 * @param objectWithLocalizedFields
 * the object with `LocalizedField` fields
 * that need to be transformed into `LocalizedString`s
 * @param fieldNames
 * An array of objects with following shape:
 *   * `from`: the field to transform and to remove after
 *   * `to`: the target field to write the transformed shape
 */
const applyTransformedLocalizedFields = (objectWithLocalizedFields, fieldNames) => {
  const transformedFieldDefinitions = _reduceInstanceProperty__default["default"](fieldNames).call(fieldNames, (nextTransformed, fieldName) => _objectSpread(_objectSpread({}, nextTransformed), {}, {
    [fieldName.to]: transformLocalizedFieldToLocalizedString(objectWithLocalizedFields[fieldName.from])
  }), {});
  const namesToOmit = _mapInstanceProperty__default["default"](fieldNames).call(fieldNames, fieldName => fieldName.from);
  const objectWithouLocalizedFields = omit__default["default"](objectWithLocalizedFields, namesToOmit);
  return _objectSpread(_objectSpread({}, objectWithouLocalizedFields), transformedFieldDefinitions);
};

/**
 * Given a list of localized string names to map, replace the fields in the
 * format of `LocalizedString` to a `LocalizedField` object.
 * The existing "localized" strings (the list version) will be removed.
 *
 * @param objectWithLocalizedStrings
 * the object with `LocalizedString` fields
 * that need to be transformed into `LocalizedField`s
 * @param fieldNames
 * An array of objects with following shape:
 *   * `from`: the field to transform and to remove after
 *   * `to`: the target field to write the transformed shape
 */
const applyTransformedLocalizedStrings = (objectWithLocalizedStrings, fieldNames) => {
  const transformedFieldDefinitions = _reduceInstanceProperty__default["default"](fieldNames).call(fieldNames, (nextTransformed, fieldName) => _objectSpread(_objectSpread({}, nextTransformed), {}, {
    [fieldName.to]: transformLocalizedStringToLocalizedField(objectWithLocalizedStrings[fieldName.from])
  }), {});
  const namesToOmit = _mapInstanceProperty__default["default"](fieldNames).call(fieldNames, fieldName => fieldName.from);
  const objectWithouLocalizedFields = omit__default["default"](objectWithLocalizedStrings, namesToOmit);
  return _objectSpread(_objectSpread({}, objectWithouLocalizedFields), transformedFieldDefinitions);
};

/**
 * Translates a localized string on an entity.
 *
 * The `localize` function receives a complete entity that can have several
 * localized fields.
 *
 * Arguments
 *  - `obj`: that entity
 *  - `key`: the field within `obj` that might contain a localized strings
 *  - `locale`: the language key that should be the first choice to show
 *  - `fallbackOrder`: an array of language keys which will be tried in the
 *     provided order for any set value
 *  - `fallback`: the final fallback that should be displayed as a last resort.
 *     This fallback will also be shown in case the field does not exist on the
 *     provided object.
 *
 * Before `fallback` kicks in, the following is tried to display a meaningful value:
 *  - if `locale` is `<language>-<extlang>`, eg. `de-AT`, try if `de` is set
 *  - if not, iterate through all languages of project-settings
 *    (passed as `fallbackOrder`) and pick the first one with a value
 *  - if nothing is found, go through all the languages in provided localized
 *    string an pick the first with a value
 *  - if still no value is found display `fallback`
 *
 * NOTE: It is known that this might lead to strings displayed in different
 *       languages within the same page. This is an accepted downside.
 *
 * NOTE: A missing field is treated like a localied string with no translations:
 *       let a = formatLocalizedString({ name: { en: '', de: '' } }, { locale: 'en' })
 *       let b = formatLocalizedString({}, { locale: 'en' })
 *       let c = formatLocalizedString(undefined, { locale: 'en' })
 *       a === b && a === c -> true
 */
const formatLocalizedString = (entity, _ref) => {
  let _ref$key = _ref.key,
    key = _ref$key === void 0 ? '' : _ref$key,
    locale = _ref.locale,
    _ref$fallbackOrder = _ref.fallbackOrder,
    fallbackOrder = _ref$fallbackOrder === void 0 ? [] : _ref$fallbackOrder,
    _ref$fallback = _ref.fallback,
    fallback = _ref$fallback === void 0 ? '' : _ref$fallback;
  if (!entity || !entity[key]) return fallback;
  const localizedString = entity[key];
  const fallbackLocale = findFallbackLocale(localizedString, fallbackOrder);
  const formattedLocalizedFallback = fallbackLocale ? formatLocalizedFallbackHint(localizedString[fallbackLocale], fallbackLocale) : fallback;

  // GIVEN no `locale`
  // THEN return formattedFallback by fallbackOrder
  if (!locale) return formattedLocalizedFallback;

  // GIVEN locale
  // AND there is a value on `localizedString`
  // THEN return value
  if (localizedString[locale]) return localizedString[locale];

  // GIVEN locale
  // AND there is a value on primary locale
  // THEN return value on primary locale
  const primaryLocale = locale && getPrimaryLocale(locale);
  if (localizedString[primaryLocale]) return localizedString[primaryLocale];

  // use formattedFallback by fallbackOrder as last resort
  return formattedLocalizedFallback;
};

exports.applyTransformedLocalizedFields = applyTransformedLocalizedFields;
exports.applyTransformedLocalizedStrings = applyTransformedLocalizedStrings;
exports.countriesShape = countriesShape;
exports.formatLocalizedString = formatLocalizedString;
exports.getSupportedLocale = getSupportedLocale;
exports.getSupportedLocales = getSupportedLocales;
exports.getSymbolFromCurrency = getSymbolFromCurrency;
exports.languagesShape = languagesShape;
exports.timeZonesShape = timeZonesShape;
exports.transformLocalizedFieldToLocalizedString = transformLocalizedFieldToLocalizedString;
exports.transformLocalizedStringToLocalizedField = transformLocalizedStringToLocalizedField;
exports.useCountries = useCountries;
exports.useCurrencies = useCurrencies;
exports.useLanguages = useLanguages;
exports.useTimeZones = useTimeZones;
exports.version = version;
exports.withCountries = withCountries;
exports.withCurrencies = withCurrencies;
exports.withLanguages = withLanguages;
exports.withTimeZones = withTimeZones;
