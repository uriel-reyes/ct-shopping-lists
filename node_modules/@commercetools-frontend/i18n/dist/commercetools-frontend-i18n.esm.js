import _pt from 'prop-types';
import { useState, useEffect, useCallback } from 'react';
import { reportErrorToSentry } from '@commercetools-frontend/sentry';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import _includesInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/includes';
import _reduceInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/reduce';
import _Object$entries from '@babel/runtime-corejs3/core-js-stable/object/entries';
import _Object$assign from '@babel/runtime-corejs3/core-js-stable/object/assign';
import _startsWithInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/starts-with';
import { jsx, Fragment } from '@emotion/react/jsx-runtime';
import { defineMessages } from 'react-intl';

// NOTE: This string will be replaced on build time with the package version.
var version = "22.13.0";

// @ts-nocheck
/* THIS IS A GENERATED FILE */

async function loadMomentLocales(locale) {
  const lowercaseLocale = locale.toLowerCase();
  switch (lowercaseLocale) {
    case 'de':
      await import('moment/dist/locale/de');
      break;
    case 'de-at':
      await import('moment/dist/locale/de-at');
      break;
    case 'de-be':
      await import('moment/dist/locale/de');
      break;
    case 'de-ch':
      await import('moment/dist/locale/de-ch');
      break;
    case 'de-de':
      await import('moment/dist/locale/de');
      break;
    case 'de-li':
      await import('moment/dist/locale/de');
      break;
    case 'de-lu':
      await import('moment/dist/locale/de');
      break;
    case 'en-au':
      await import('moment/dist/locale/en-au');
      break;
    case 'en-ca':
      await import('moment/dist/locale/en-ca');
      break;
    case 'en-gb':
      await import('moment/dist/locale/en-gb');
      break;
    case 'en-ie':
      await import('moment/dist/locale/en-ie');
      break;
    case 'en-in':
      await import('moment/dist/locale/en-in');
      break;
    case 'en-nz':
      await import('moment/dist/locale/en-nz');
      break;
    case 'en-sg':
      await import('moment/dist/locale/en-sg');
      break;
    case 'es':
      await import('moment/dist/locale/es');
      break;
    case 'es-ar':
      await import('moment/dist/locale/es');
      break;
    case 'es-bo':
      await import('moment/dist/locale/es');
      break;
    case 'es-cl':
      await import('moment/dist/locale/es');
      break;
    case 'es-co':
      await import('moment/dist/locale/es');
      break;
    case 'es-cr':
      await import('moment/dist/locale/es');
      break;
    case 'es-cu':
      await import('moment/dist/locale/es');
      break;
    case 'es-do':
      await import('moment/dist/locale/es-do');
      break;
    case 'es-ea':
      await import('moment/dist/locale/es');
      break;
    case 'es-ec':
      await import('moment/dist/locale/es');
      break;
    case 'es-es':
      await import('moment/dist/locale/es');
      break;
    case 'es-gq':
      await import('moment/dist/locale/es');
      break;
    case 'es-gt':
      await import('moment/dist/locale/es');
      break;
    case 'es-hn':
      await import('moment/dist/locale/es');
      break;
    case 'es-ic':
      await import('moment/dist/locale/es');
      break;
    case 'es-mx':
      await import('moment/dist/locale/es-mx');
      break;
    case 'es-ni':
      await import('moment/dist/locale/es');
      break;
    case 'es-pa':
      await import('moment/dist/locale/es');
      break;
    case 'es-pe':
      await import('moment/dist/locale/es');
      break;
    case 'es-pr':
      await import('moment/dist/locale/es');
      break;
    case 'es-py':
      await import('moment/dist/locale/es');
      break;
    case 'es-sv':
      await import('moment/dist/locale/es');
      break;
    case 'es-uy':
      await import('moment/dist/locale/es');
      break;
    case 'es-ve':
      await import('moment/dist/locale/es');
      break;
    case 'fr-fr':
      await import('moment/dist/locale/fr');
      break;
    case 'pt-br':
      await import('moment/dist/locale/pt-br');
      break;
    case 'zh-cn':
      await import('moment/dist/locale/zh-cn');
      break;
  }
}

function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context2, _context3; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context2 = ownKeys(Object(t), !0)).call(_context2, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context3 = ownKeys(Object(t))).call(_context3, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
const extractLanguageTagFromLocale = locale => _includesInstanceProperty(locale).call(locale, '-') ? locale.split('-')[0] : locale;
const isStructuredJson = message => (message === null || message === void 0 ? void 0 : message.string) !== undefined;
const parseChunkImport = chunkImport => {
  var _context;
  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  const contents = chunkImport.default || chunkImport;
  return _reduceInstanceProperty(_context = _Object$entries(contents)).call(_context, (messages, _ref) => {
    let _ref2 = _slicedToArray(_ref, 2),
      messageKey = _ref2[0],
      messageValue = _ref2[1];
    const messageAsString = isStructuredJson(messageValue) ? messageValue.string : messageValue;
    return _objectSpread(_objectSpread({}, messages), {}, {
      [messageKey]: messageAsString
    });
  }, {});
};
const mergeMessages = function () {
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  return _Object$assign({}, ...messages);
};
const mapLocaleToIntlLocale = locale => {
  if (_startsWithInstanceProperty(locale).call(locale, 'de')) return 'de';
  if (_startsWithInstanceProperty(locale).call(locale, 'es')) return 'es';
  if (_startsWithInstanceProperty(locale).call(locale, 'fr')) return 'fr-FR';
  if (locale === 'pt-BR') return 'pt-BR';
  if (locale === 'zh-CN') return 'zh-CN';
  return 'en';
};

const getUiKitChunkImport = locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return import( /* webpackChunkName: "i18n-ui-kit-locale-de" */'@commercetools-uikit/i18n/compiled-data/de.json');
    case 'es':
      return import( /* webpackChunkName: "i18n-ui-kit-locale-es" */'@commercetools-uikit/i18n/compiled-data/es.json');
    case 'fr-FR':
      return import( /* webpackChunkName: "i18n-ui-kit-locale-fr-FR" */'@commercetools-uikit/i18n/compiled-data/fr-FR.json');
    case 'pt-BR':
      return import( /* webpackChunkName: "i18n-ui-kit-locale-pt-BR" */'@commercetools-uikit/i18n/compiled-data/pt-BR.json');
    case 'zh-CN':
      return import( /* webpackChunkName: "i18n-ui-kit-locale-zh-CN" */'@commercetools-uikit/i18n/compiled-data/zh-CN.json');
    default:
      return import( /* webpackChunkName: "i18n-ui-kit-locale-en" */'@commercetools-uikit/i18n/compiled-data/en.json');
  }
};
const getAppKitChunkImport = locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return import( /* webpackChunkName: "i18n-app-kit-locale-de" */'./de-13be183b.esm.js');
    case 'es':
      return import( /* webpackChunkName: "i18n-app-kit-locale-es" */'./es-ccf7ea0a.esm.js');
    case 'fr-FR':
      return import( /* webpackChunkName: "i18n-app-kit-locale-fr-FR" */'./fr-FR-90be0bdd.esm.js');
    case 'pt-BR':
      return import( /* webpackChunkName: "i18n-app-kit-locale-pt-BR" */'./pt-BR-e9217a48.esm.js');
    case 'zh-CN':
      return import( /* webpackChunkName: "i18n-app-kit-locale-zh-CN" */'./zh-CN-964437b0.esm.js');
    default:
      return import( /* webpackChunkName: "i18n-app-kit-locale-en" */'./en-718ebd9c.esm.js');
  }
};
const getCommunityKitChunkImport = async locale => {
  const intlLocale = mapLocaleToIntlLocale(locale);
  switch (intlLocale) {
    case 'de':
      return await import( /* webpackChunkName: "i18n-community-kit-locale-de" */'@commercetools-community-kit/i18n/compiled-data/de.json');
    case 'es':
      return await import( /* webpackChunkName: "i18n-community-kit-locale-es" */'@commercetools-community-kit/i18n/compiled-data/es.json');
    case 'fr-FR':
      return await import( /* webpackChunkName: "i18n-community-kit-locale-fr-FR" */'@commercetools-community-kit/i18n/compiled-data/fr-FR.json');
    case 'zh-CN':
      return await import( /* webpackChunkName: "i18n-community-kit-locale-zh-CN" */'@commercetools-community-kit/i18n/compiled-data/zh-CN.json');
    default:
      return await import( /* webpackChunkName: "i18n-community-kit-locale-en" */'@commercetools-community-kit/i18n/compiled-data/en.json');
  }
};

// Use default (lazy) so that we will receive one chunk per
// locale. https://webpack.js.org/api/module-methods/#import-
async function loadI18n(locale) {
  // Load moment localizations
  await loadMomentLocales(locale);

  // Load ui-kit translations
  const uiKitChunkImport = await getUiKitChunkImport(locale);

  // Load app-kit translations
  const appKitChunkImport = await getAppKitChunkImport(locale);

  // Load community-kit translations
  const communityKitChunkImport = await getCommunityKitChunkImport(locale);

  // Prefer loading `default` (for ESM bundles) and
  // fall back to normal import (for CJS bundles).
  return mergeMessages(parseChunkImport(uiKitChunkImport), parseChunkImport(appKitChunkImport), parseChunkImport(communityKitChunkImport));
}

const initialState = {
  isLoading: true,
  messages: undefined,
  error: undefined
};

// Low level hook to load messages for a specific locale. The loading is async
// because it's assumed that the translation files are dynamically imported (code splitted).
const useAsyncIntlMessages = _ref => {
  let locale = _ref.locale,
    loader = _ref.loader;
  const _useState = useState(initialState),
    _useState2 = _slicedToArray(_useState, 2),
    state = _useState2[0],
    setState = _useState2[1];
  useEffect(() => {
    let _isUnmounting = false;
    async function load(_locale) {
      try {
        if (!_isUnmounting) {
          const messages = await loader(_locale);
          setState({
            isLoading: false,
            messages
          });
        }
      } catch (error) {
        if (error instanceof Error) {
          setState({
            isLoading: false,
            error
          });
        }
      }
    }
    if (locale) load(locale);
    return () => {
      _isUnmounting = true;
    };
  }, [locale, loader]);
  return state;
};

const getMessagesForLocale = (data, locale) => {
  if (!data || !locale) return {};
  if (data[locale]) return data[locale];
  const fallbackLanguage = extractLanguageTagFromLocale(locale);
  return data[fallbackLanguage];
};
const useAsyncLocaleData = _ref => {
  var _messagesFromKitResul, _applicationMessagesR, _messagesFromKitResul2;
  let locale = _ref.locale,
    applicationMessages = _ref.applicationMessages;
  const loadApplicationMessages = useCallback(async locale => {
    if (typeof applicationMessages === 'function') {
      return await applicationMessages(locale);
    }
    return getMessagesForLocale(applicationMessages, locale);
  },
  // NOTE: we assume that the `applicationMessages` argument never changes.
  // Therefore, we disable the dependency array to not depend on that argument.
  // This is important, to avoid potential infinite loops.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  const messagesFromKitResult = useAsyncIntlMessages({
    locale,
    loader: loadI18n
  });
  const applicationMessagesResult = useAsyncIntlMessages({
    locale,
    loader: loadApplicationMessages
  });

  // Merge the loaded messages into one
  return {
    isLoading: messagesFromKitResult.isLoading || applicationMessagesResult.isLoading,
    messages: mergeMessages((_messagesFromKitResul = messagesFromKitResult.messages) !== null && _messagesFromKitResul !== void 0 ? _messagesFromKitResul : {}, (_applicationMessagesR = applicationMessagesResult.messages) !== null && _applicationMessagesR !== void 0 ? _applicationMessagesR : {}),
    error: (_messagesFromKitResul2 = messagesFromKitResult.error) !== null && _messagesFromKitResul2 !== void 0 ? _messagesFromKitResul2 : applicationMessagesResult.error
  };
};
const AsyncLocaleData = props => {
  const _useAsyncLocaleData = useAsyncLocaleData(props),
    isLoading = _useAsyncLocaleData.isLoading,
    messages = _useAsyncLocaleData.messages,
    error = _useAsyncLocaleData.error;
  useEffect(() => {
    if (error) reportErrorToSentry(error, {});
  }, [error]);
  return jsx(Fragment, {
    children: props.children({
      isLoading,
      locale: isLoading ? undefined : props.locale,
      messages: error ? undefined : messages
    })
  });
};
AsyncLocaleData.propTypes = {
  locale: _pt.string,
  applicationMessages: _pt.oneOfType([_pt.objectOf(_pt.any), _pt.func]).isRequired,
  children: _pt.func.isRequired
};

// TODO: move it to its own package, so that other people can also use it?

// Selection of shared messages, to avoid duplicating translations.
// Avoid changing the message id, otherwise you need to translate them again in Transifex.
const messages = defineMessages({
  cancel: {
    id: 'AppKit.Shared.cancel',
    defaultMessage: 'Cancel'
  },
  revert: {
    id: 'AppKit.Shared.revert',
    defaultMessage: 'Revert'
  },
  confirm: {
    id: 'AppKit.Shared.confirm',
    defaultMessage: 'Confirm'
  },
  save: {
    id: 'AppKit.Shared.save',
    defaultMessage: 'Save'
  },
  update: {
    id: 'AppKit.Shared.update',
    defaultMessage: 'Update'
  },
  create: {
    id: 'AppKit.Shared.create',
    defaultMessage: 'Create'
  },
  delete: {
    id: 'AppKit.Shared.delete',
    defaultMessage: 'Delete'
  },
  add: {
    id: 'AppKit.Shared.add',
    defaultMessage: 'Add'
  },
  remove: {
    id: 'AppKit.Shared.remove',
    defaultMessage: 'Remove'
  },
  close: {
    id: 'AppKit.Shared.close',
    defaultMessage: 'Close'
  },
  edit: {
    id: 'AppKit.Shared.edit',
    defaultMessage: 'Edit'
  },
  open: {
    id: 'AppKit.Shared.open',
    defaultMessage: 'Open'
  },
  activate: {
    id: 'AppKit.Shared.activate',
    defaultMessage: 'Activate'
  },
  deactivate: {
    id: 'AppKit.Shared.deactivate',
    defaultMessage: 'Deactivate'
  },
  active: {
    id: 'AppKit.Shared.active',
    defaultMessage: 'Active'
  },
  inactive: {
    id: 'AppKit.Shared.inactive',
    defaultMessage: 'Inactive'
  },
  enable: {
    id: 'AppKit.Shared.enable',
    defaultMessage: 'Enable'
  },
  disable: {
    id: 'AppKit.Shared.disable',
    defaultMessage: 'Disable'
  }
});

export { AsyncLocaleData, isStructuredJson, mapLocaleToIntlLocale, mergeMessages, parseChunkImport, messages as sharedMessages, useAsyncIntlMessages, useAsyncLocaleData, version };
