import flatten from 'lodash.flatten';
import isEqual from 'lodash.isequal';
import isNil from 'lodash.isnil';
import forEach from 'lodash.foreach';
import uniqWith from 'lodash.uniqwith';
import intersection from 'lodash.intersection';
import without from 'lodash.without';
import sortBy from 'lodash.sortby';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var _excluded$1 = ["prices"];

function applyOnBeforeDiff(before, now, fn) {
  return fn && typeof fn === 'function' ? fn(before, now) : [before, now];
}

var createPriceComparator = function createPriceComparator(price) {
  return {
    value: {
      currencyCode: price.value.currencyCode
    },
    channel: price.channel,
    country: price.country,
    customerGroup: price.customerGroup,
    validFrom: price.validFrom,
    validUntil: price.validUntil
  };
};

function arePricesStructurallyEqual(oldPrice, newPrice) {
  var oldPriceComparison = createPriceComparator(oldPrice);
  var newPriceComparison = createPriceComparator(newPrice);
  return isEqual(newPriceComparison, oldPriceComparison);
}

function extractPriceFromPreviousVariant(newPrice, previousVariant) {
  if (!previousVariant) return null;
  var price = previousVariant.prices.find(function (oldPrice) {
    return arePricesStructurallyEqual(oldPrice, newPrice);
  });
  return price || null;
}

function injectMissingPriceIds(nextVariants, previousVariants) {
  return nextVariants.map(function (newVariant) {
    var prices = newVariant.prices,
        restOfVariant = _objectWithoutProperties(newVariant, _excluded$1);

    if (!prices) return restOfVariant;
    var oldVariant = previousVariants.find(function (previousVariant) {
      return !isNil(previousVariant.id) && previousVariant.id === newVariant.id || !isNil(previousVariant.key) && previousVariant.key === newVariant.key || !isNil(previousVariant.sku) && previousVariant.sku === newVariant.sku;
    });
    return _objectSpread2(_objectSpread2({}, restOfVariant), {}, {
      prices: prices.map(function (price) {
        var newPrice = _objectSpread2({}, price);

        var oldPrice = extractPriceFromPreviousVariant(price, oldVariant);

        if (oldPrice) {
          // copy ID if not provided
          if (!newPrice.id) newPrice.id = oldPrice.id;
          if (isNil(newPrice.value.type)) newPrice.value.type = oldPrice.value.type;
          if (isNil(newPrice.value.fractionDigits)) newPrice.value.fractionDigits = oldPrice.value.fractionDigits;
        }

        return newPrice;
      })
    });
  });
}

function createBuildActions(differ, doMapActions, onBeforeDiff) {
  var buildActionsConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return function buildActions(now, before) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!now || !before) throw new Error('Missing either `newObj` or `oldObj` ' + 'in order to build update actions');

    var _applyOnBeforeDiff = applyOnBeforeDiff(before, now, onBeforeDiff),
        _applyOnBeforeDiff2 = _slicedToArray(_applyOnBeforeDiff, 2),
        processedBefore = _applyOnBeforeDiff2[0],
        processedNow = _applyOnBeforeDiff2[1];

    if (processedNow.variants && processedBefore.variants) processedNow.variants = injectMissingPriceIds(processedNow.variants, processedBefore.variants);
    var diffed = differ(processedBefore, processedNow);
    if (!buildActionsConfig.withHints && !diffed) return [];
    return doMapActions(diffed, processedNow, processedBefore, options);
  };
}

// Array of action groups which need to be allowed or ignored.
// Example:
// [
//   { type: 'base', group: 'ignore' },
//   { type: 'prices', group: 'allow' },
//   { type: 'variants', group: 'ignore' },
// ]
function createMapActionGroup() {
  var actionGroups = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return function mapActionGroup(type, fn) {
    if (!Object.keys(actionGroups).length) return fn();
    var found = actionGroups.find(function (c) {
      return c.type === type;
    });
    if (!found) return []; // Keep `black` for backwards compatibility.

    if (found.group === 'ignore' || found.group === 'black') return []; // Keep `white` for backwards compatibility.

    if (found.group === 'allow' || found.group === 'white') return fn();
    throw new Error("Action group '".concat(found.group, "' not supported. Use either \"allow\" or \"ignore\"."));
  };
}

// jsondiffpatch does not yet handle minified UMD builds
// with es6 modules so we use require instead below
// TODO create an issue here https://github.com/benjamine/jsondiffpatch/issues/new
var DiffPatcher = require('jsondiffpatch').DiffPatcher;

function objectHash(obj, index) {
  var objIndex = "$$index:".concat(index);
  return _typeof(obj) === 'object' && obj !== null ? obj.id || obj.name || obj.url || objIndex : objIndex;
}
var diffpatcher = new DiffPatcher({
  objectHash: objectHash,
  arrays: {
    // detect items moved inside the array
    detectMove: true,
    // value of items moved is not included in deltas
    includeValueOnMove: false
  },
  textDiff: {
    /**
     * jsondiffpatch uses a very fine-grained diffing algorithm for long strings to easily identify
     * what changed between strings. However, we don't actually care about what changed, just
     * if the string changed at all. So we set the minimum length to diff to a very large number to avoid
     * using the very slow algorithm.
     * See https://github.com/benjamine/jsondiffpatch/blob/master/docs/deltas.md#text-diffs.
     */
    minLength: Number.MAX_SAFE_INTEGER
  }
});
function diff(oldObj, newObj) {
  return diffpatcher.diff(oldObj, newObj);
}
function patch(obj, delta) {
  return diffpatcher.patch(obj, delta);
}
function getDeltaValue(arr, originalObject) {
  if (!Array.isArray(arr)) throw new Error('Expected array to extract delta value');
  if (arr.length === 1) return arr[0]; // new

  if (arr.length === 2) return arr[1]; // update

  if (arr.length === 3 && arr[2] === 0) return undefined; // delete

  if (arr.length === 3 && arr[2] === 2) {
    // text diff
    if (!originalObject) throw new Error('Cannot apply patch to long text diff. Missing original object.'); // try to apply patch to given object based on delta value

    return patch(originalObject, arr);
  }

  if (arr.length === 3 && arr[2] === 3) // array move
    throw new Error('Detected an array move, it should not happen as ' + '`includeValueOnMove` should be set to false');
  throw new Error("Got unsupported number ".concat(arr[2], " in delta value"));
}

var _excluded = ["actions"];
var Actions = {
  setCustomType: 'setCustomType',
  setCustomField: 'setCustomField'
};

var hasSingleCustomFieldChanged = function hasSingleCustomFieldChanged(diff) {
  return Array.isArray(diff.custom);
};

var haveMultipleCustomFieldsChanged = function haveMultipleCustomFieldsChanged(diff) {
  return Boolean(diff.custom.fields);
};

var hasCustomTypeChanged = function hasCustomTypeChanged(diff) {
  return Boolean(diff.custom.type);
};

var extractCustomType = function extractCustomType(diff, previousObject) {
  return Array.isArray(diff.custom.type) ? getDeltaValue(diff.custom.type, previousObject) : diff.custom.type;
};

var extractTypeId = function extractTypeId(type, nextObject) {
  return Array.isArray(type.id) ? getDeltaValue(type.id) : nextObject.custom.type.id;
};

var extractTypeKey = function extractTypeKey(type, nextObject) {
  return Array.isArray(type.key) ? getDeltaValue(type.key) : nextObject.custom.type.key;
};

var extractTypeFields = function extractTypeFields(diffedFields, nextFields) {
  return Array.isArray(diffedFields) ? getDeltaValue(diffedFields) : nextFields;
};

var extractFieldValue = function extractFieldValue(newFields, fieldName) {
  return newFields[fieldName];
};

function actionsMapCustom(diff, newObj, oldObj) {
  var customProps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
    actions: {}
  };
  var actions = [];

  var customPropsActions = customProps.actions,
      options = _objectWithoutProperties(customProps, _excluded);

  var actionGroup = _objectSpread2(_objectSpread2({}, Actions), customPropsActions);

  if (!diff.custom) return actions;

  if (hasSingleCustomFieldChanged(diff)) {
    // If custom is not defined on the new or old category
    var custom = getDeltaValue(diff.custom, oldObj);
    actions.push(_objectSpread2(_objectSpread2({
      action: actionGroup.setCustomType
    }, options), custom));
  } else if (hasCustomTypeChanged(diff)) {
    // If custom is set to an empty object on the new or old category
    var type = extractCustomType(diff, oldObj);
    if (!type) actions.push(_objectSpread2({
      action: actionGroup.setCustomType
    }, options));else if (type.id) actions.push(_objectSpread2(_objectSpread2({
      action: actionGroup.setCustomType
    }, options), {}, {
      type: {
        typeId: 'type',
        id: extractTypeId(type, newObj)
      },
      fields: extractTypeFields(diff.custom.fields, newObj.custom.fields)
    }));else if (type.key) actions.push(_objectSpread2(_objectSpread2({
      action: actionGroup.setCustomType
    }, options), {}, {
      type: {
        typeId: 'type',
        key: extractTypeKey(type, newObj)
      },
      fields: extractTypeFields(diff.custom.fields, newObj.custom.fields)
    }));
  } else if (haveMultipleCustomFieldsChanged(diff)) {
    var customFieldsActions = Object.keys(diff.custom.fields).map(function (name) {
      return _objectSpread2(_objectSpread2({
        action: actionGroup.setCustomField
      }, options), {}, {
        name: name,
        value: extractFieldValue(newObj.custom.fields, name)
      });
    });
    actions.push.apply(actions, _toConsumableArray(customFieldsActions));
  }

  return actions;
}

var REGEX_NUMBER$4 = new RegExp(/^\d+$/);
var REGEX_UNDERSCORE_NUMBER$4 = new RegExp(/^_\d+$/);
var ADD_ACTIONS = 'create';
var REMOVE_ACTIONS = 'remove';
var CHANGE_ACTIONS = 'change';
/**
 * Tests a delta to see if it represents a create action.
 * eg. delta:
 * {
 *   0: [ { foo: 'bar' } ]
 * }
 *
 * @param  {object}  obj The delta generated by the diffpatcher
 * @param  {string}  key key of generated delta to examine
 * @return {Boolean}     Returns true if delta represents a create action,
 *   false otherwise
 */

function isCreateAction(obj, key) {
  return REGEX_NUMBER$4.test(key) && Array.isArray(obj[key]) && obj[key].length === 1;
}
/**
 * Tests a delta to see if it represents a change action.
 * eg. delta:
 *
 * {
 *   0: {
 *     foo: ['bar', 'baz']
 *   }
 * }
 * @param  {object}  obj The delta generated by the diffpatcher
 * @param  {string}  key key of generated delta to examine
 * @return {Boolean}     Returns true if delta represents a change action,
 *   false otherwise
 */


function isChangeAction(obj, key) {
  return REGEX_NUMBER$4.test(key) && (_typeof(obj[key]) === 'object' || typeof obj[key] === 'string');
}
/**
 * Tests a delta to see if it represents a remove action.
 * eg. delta:
 *
 * {
 *   _0: [ 'foo', 0, 0 ]
 * }
 * @param  {object}  obj The delta generated by the diffpatcher
 * @param  {string}  key key of generated delta to examine
 * @return {Boolean}     Returns true if delta represents a remove action,
 *   false otherwise
 */


function isRemoveAction$1(obj, key) {
  return REGEX_UNDERSCORE_NUMBER$4.test(key) && Array.isArray(obj[key]) && obj[key].length === 3 && (_typeof(obj[key][0]) === 'object' || typeof obj[key][0] === 'string') && obj[key][1] === 0 && obj[key][2] === 0;
}
/**
 * Generate + configure a function to build actions for nested objects
 * @param  {string} key    key of the attribute containing the array of
 *   nested objects
 * @param  {object} config configuration object that can contain the keys
 *   [ADD_ACTIONS, REMOVE_ACTIONS, CHANGE_ACTIONS], each of
 *   which is a function. The function should accept the old + new arrays and
 *   return an action object.
 * @return {Array}        The generated array of actions
 */


function createBuildArrayActions(key, config) {
  return function buildArrayActions(diff, oldObj, newObj) {
    var addActions = [];
    var removeActions = [];
    var changeActions = [];

    if (diff[key]) {
      var arrayDelta = diff[key];
      Object.keys(arrayDelta).forEach(function (index) {
        if (config[ADD_ACTIONS] && isCreateAction(arrayDelta, index)) {
          var actionGenerator = config[ADD_ACTIONS]; // When adding a new element you don't need the oldObj

          var action = actionGenerator(newObj[key][index], parseInt(index, 10));
          if (action) addActions.push(action);
        } else if (config[CHANGE_ACTIONS] && isChangeAction(arrayDelta, index)) {
          var _actionGenerator = config[CHANGE_ACTIONS]; // When changing an existing element you need both old + new

          var _action = _actionGenerator(oldObj[key][index], newObj[key][index], parseInt(index, 10));

          if (_action) changeActions.push(_action);
        } else if (config[REMOVE_ACTIONS] && isRemoveAction$1(arrayDelta, index)) {
          var realIndex = index.replace('_', '');
          var _actionGenerator2 = config[REMOVE_ACTIONS]; // When removing an existing element you don't need the newObj

          var _action2 = _actionGenerator2(oldObj[key][realIndex], parseInt(realIndex, 10));

          if (_action2) removeActions.push(_action2);
        }
      });
    }

    return changeActions.concat(removeActions, addActions);
  };
}

function toAssetIdentifier$1(asset) {
  var assetIdentifier = asset.id ? {
    assetId: asset.id
  } : {
    assetKey: asset.key
  };
  return assetIdentifier;
}

function actionsMapAssets$1(diff, oldObj, newObj) {
  var _createBuildArrayActi;

  var handler = createBuildArrayActions('assets', (_createBuildArrayActi = {}, _defineProperty(_createBuildArrayActi, ADD_ACTIONS, function (newAsset) {
    return {
      action: 'addAsset',
      asset: newAsset
    };
  }), _defineProperty(_createBuildArrayActi, REMOVE_ACTIONS, function (oldAsset) {
    return _objectSpread2({
      action: 'removeAsset'
    }, toAssetIdentifier$1(oldAsset));
  }), _defineProperty(_createBuildArrayActi, CHANGE_ACTIONS, function (oldAsset, newAsset) {
    return (// here we could use more atomic update actions (e.g. changeAssetName)
      // but for now we use the simpler approach to first remove and then
      // re-add the asset - which reduces the code complexity
      [_objectSpread2({
        action: 'removeAsset'
      }, toAssetIdentifier$1(oldAsset)), {
        action: 'addAsset',
        asset: newAsset
      }]
    );
  }), _createBuildArrayActi));
  return handler(diff, oldObj, newObj);
}

function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

var normalizeValue = function normalizeValue(value) {
  return typeof value === 'string' ? value.trim() : value;
};

var createIsEmptyValue = function createIsEmptyValue(emptyValues) {
  return function (value) {
    return emptyValues.some(function (emptyValue) {
      return emptyValue === normalizeValue(value);
    });
  };
};
/**
 * Builds actions for simple object properties, given a list of actions
 * E.g. [{ action: `changeName`, key: 'name' }]
 *
 * @param  {Array} options.actions - a list of actions to be built
 * based on the given property
 * @param  {Object} options.diff - the diff object
 * @param  {Object} options.oldObj - the object that needs to be updated
 * @param  {Object} options.newObj - the new representation of the object
 * @param {Boolean} options.shouldOmitEmptyString - a flag to determine if we should treat an empty string a NON-value
 */

function buildBaseAttributesActions(_ref) {
  var actions = _ref.actions,
      diff = _ref.diff,
      oldObj = _ref.oldObj,
      newObj = _ref.newObj,
      shouldOmitEmptyString = _ref.shouldOmitEmptyString;
  var isEmptyValue = createIsEmptyValue(shouldOmitEmptyString ? [undefined, null, ''] : [undefined, null]);
  return actions.map(function (item) {
    var key = item.key; // e.g.: name, description, ...

    var actionKey = item.actionKey || item.key;
    var delta = diff[key];
    var before = oldObj[key];
    var now = newObj[key];
    var isNotDefinedBefore = isEmptyValue(oldObj[key]);
    var isNotDefinedNow = isEmptyValue(newObj[key]);
    if (!delta) return undefined;
    if (isNotDefinedNow && isNotDefinedBefore) return undefined;
    if (!isNotDefinedNow && isNotDefinedBefore) // no value previously set
      return _defineProperty({
        action: item.action
      }, actionKey, now);
    /* no new value */

    if (isNotDefinedNow && !{}.hasOwnProperty.call(newObj, key)) return undefined;
    if (isNotDefinedNow && {}.hasOwnProperty.call(newObj, key)) // value unset
      return {
        action: item.action
      }; // We need to clone `before` as `patch` will mutate it

    var patched = patch(clone(before), delta);
    return _defineProperty({
      action: item.action
    }, actionKey, patched);
  }).filter(function (action) {
    return !isNil(action);
  });
}
/**
 * Builds actions for simple reference objects, given a list of actions
 * E.g. [{ action: `setTaxCategory`, key: 'taxCategory' }]
 *
 * @param  {Array} options.actions - a list of actions to be built
 * based on the given property
 * @param  {Object} options.diff - the diff object
 * @param  {Object} options.oldObj - the object that needs to be updated
 * @param  {Object} options.newObj - the new representation of the object
 */

function buildReferenceActions(_ref4) {
  var actions = _ref4.actions,
      diff = _ref4.diff,
      newObj = _ref4.newObj;
  return actions.map(function (item) {
    var action = item.action;
    var key = item.key;

    if (diff[key] && ( // The `key` value was added or removed
    Array.isArray(diff[key]) || // The `key` value id changed
    diff[key].id)) {
      var newValue = Array.isArray(diff[key]) ? getDeltaValue(diff[key]) : newObj[key];
      if (!newValue) return {
        action: action
      }; // When the `id` of the object is undefined

      if (!newValue.id) {
        return _defineProperty({
          action: action
        }, key, {
          typeId: newValue.typeId,
          key: newValue.key
        });
      }

      return _defineProperty({
        action: action
      }, key, {
        typeId: newValue.typeId,
        id: newValue.id
      });
    }

    return undefined;
  }).filter(function (action) {
    return action;
  });
}

var baseActionsList$k = [{
  action: 'changeName',
  key: 'name'
}, {
  action: 'changeSlug',
  key: 'slug'
}, {
  action: 'setDescription',
  key: 'description'
}, {
  action: 'changeOrderHint',
  key: 'orderHint'
}, {
  action: 'setExternalId',
  key: 'externalId'
}, {
  action: 'setKey',
  key: 'key'
}];
var metaActionsList$1 = [{
  action: 'setMetaTitle',
  key: 'metaTitle'
}, {
  action: 'setMetaKeywords',
  key: 'metaKeywords'
}, {
  action: 'setMetaDescription',
  key: 'metaDescription'
}];
var referenceActionsList$3 = [{
  action: 'changeParent',
  key: 'parent'
}];
/**
 * SYNC FUNCTIONS
 */

function actionsMapBase$k(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$k,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}
function actionsMapReferences$3(diff, oldObj, newObj) {
  return buildReferenceActions({
    actions: referenceActionsList$3,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj
  });
}
function actionsMapMeta$1(diff, oldObj, newObj) {
  return buildBaseAttributesActions({
    actions: metaActionsList$1,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj
  });
}

var CUSTOM = 'custom';
/**
 * @function copyEmptyArrayProps
 * @description Create new key with empty array value on `newobj` for the arrays exist on `oldObj` and doesnt exist on `newobj`
 * One use case is to easily compare two object without generating this error `Cannot read property '0' of undefined`
 * @param {Object} oldObj
 * @param {Object} newObj
 * @returns {Array} Ordered Array [oldObj, newObj]
 */

function copyEmptyArrayProps() {
  var oldObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var newObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!isNil(oldObj) && !isNil(newObj)) {
    var nextObjectWithEmptyArray = Object.entries(oldObj).reduce(function (merged, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      // Ignore CUSTOM key as this object is dynamic and its up to the user to dynamically change it
      // todo, it would be better if we pass it as ignored keys param
      if (key === CUSTOM) return merged;

      if (Array.isArray(value) && newObj[key] && newObj[key].length >= 1) {
        /* eslint-disable no-plusplus */
        var hashMapValue = value.reduce(function (acc, val) {
          acc[val.id] = val;
          return acc;
        }, {});

        for (var i = 0; i < newObj[key].length; i++) {
          if (!isNil(newObj[key][i]) && _typeof(newObj[key][i]) === 'object' && !isNil(newObj[key][i].id)) {
            // Since its unordered array elements then check if the element on `oldObj` exists by id
            var foundObject = hashMapValue[newObj[key][i].id];

            if (!isNil(foundObject)) {
              var _copyEmptyArrayProps = copyEmptyArrayProps(foundObject, newObj[key][i]),
                  _copyEmptyArrayProps2 = _slicedToArray(_copyEmptyArrayProps, 2),
                  nestedObject = _copyEmptyArrayProps2[1];

              if (Object.isFrozen(merged[key])) {
                /* eslint-disable no-param-reassign */
                merged[key] = merged[key].slice();
              }
              /* eslint-disable no-param-reassign */


              merged[key][i] = nestedObject;
            }
          }
        }

        return merged;
      }

      if (Array.isArray(value)) {
        merged[key] = isNil(newObj[key]) ? [] : newObj[key];
        return merged;
      }

      if (!isNil(newObj[key]) && _typeof(value) === 'object' && // Ignore Date as this will create invalid object since typeof date === 'object' return true
      // ex: {date: new Date()} will result {date: {}}
      !(value instanceof Date)) {
        var _copyEmptyArrayProps3 = copyEmptyArrayProps(value, newObj[key]),
            _copyEmptyArrayProps4 = _slicedToArray(_copyEmptyArrayProps3, 2),
            _nestedObject = _copyEmptyArrayProps4[1];

        merged[key] = _nestedObject;
        return merged;
      }

      return merged;
    }, _objectSpread2({}, newObj));
    return [oldObj, nextObjectWithEmptyArray];
  }

  return [oldObj, newObj];
}

function createCategoryMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$k(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('references', function () {
      return actionsMapReferences$3(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('meta', function () {
      return actionsMapMeta$1(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, newObj, oldObj);
    }));
    allActions.push(mapActionGroup('assets', function () {
      return actionsMapAssets$1(diff, oldObj, newObj);
    }));
    return flatten(allActions);
  };
}

var categories = (function (actionGroupList, syncActionConfig) {
  // actionGroupList contains information about which action groups
  // are allowed or ignored
  // createMapActionGroup returns function 'mapActionGroup' that takes params:
  // - action group name
  // - callback function that should return a list of actions that correspond
  //    to the for the action group
  // this resulting function mapActionGroup will call the callback function
  // for allowed action groups and return the return value of the callback
  // It will return an empty array for ignored action groups
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createCategoryMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions, copyEmptyArrayProps);
  return {
    buildActions: buildActions
  };
});

var isEmptyValue = createIsEmptyValue([undefined, null, '']);
var baseActionsList$j = [{
  action: 'setSalutation',
  key: 'salutation'
}, {
  action: 'changeEmail',
  key: 'email'
}, {
  action: 'setFirstName',
  key: 'firstName'
}, {
  action: 'setLastName',
  key: 'lastName'
}, {
  action: 'setMiddleName',
  key: 'middleName'
}, {
  action: 'setTitle',
  key: 'title'
}, {
  action: 'setCustomerNumber',
  key: 'customerNumber'
}, {
  action: 'setExternalId',
  key: 'externalId'
}, {
  action: 'setCompanyName',
  key: 'companyName'
}, {
  action: 'setDateOfBirth',
  key: 'dateOfBirth'
}, {
  action: 'setLocale',
  key: 'locale'
}, {
  action: 'setVatId',
  key: 'vatId'
}, {
  action: 'setStores',
  key: 'stores'
}, {
  action: 'setKey',
  key: 'key'
}];
var setDefaultBaseActionsList = [{
  action: 'setDefaultBillingAddress',
  key: 'defaultBillingAddressId',
  actionKey: 'addressId'
}, {
  action: 'setDefaultShippingAddress',
  key: 'defaultShippingAddressId',
  actionKey: 'addressId'
}];
var referenceActionsList$2 = [{
  action: 'setCustomerGroup',
  key: 'customerGroup'
}];
var authenticationModeActionsList = [{
  action: 'setAuthenticationMode',
  key: 'authenticationMode',
  value: 'password'
}];
/**
 * SYNC FUNCTIONS
 */

function actionsMapBase$j(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$j,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}
function actionsMapSetDefaultBase(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: setDefaultBaseActionsList,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}
function actionsMapReferences$2(diff, oldObj, newObj) {
  return buildReferenceActions({
    actions: referenceActionsList$2,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj
  });
}
function actionsMapAddresses(diff, oldObj, newObj) {
  var _createBuildArrayActi;

  var handler = createBuildArrayActions('addresses', (_createBuildArrayActi = {}, _defineProperty(_createBuildArrayActi, ADD_ACTIONS, function (newObject) {
    return {
      action: 'addAddress',
      address: newObject
    };
  }), _defineProperty(_createBuildArrayActi, REMOVE_ACTIONS, function (objectToRemove) {
    return {
      action: 'removeAddress',
      addressId: objectToRemove.id
    };
  }), _defineProperty(_createBuildArrayActi, CHANGE_ACTIONS, function (oldObject, updatedObject) {
    return {
      action: 'changeAddress',
      addressId: oldObject.id,
      address: updatedObject
    };
  }), _createBuildArrayActi));
  return handler(diff, oldObj, newObj);
}
function actionsMapBillingAddresses(diff, oldObj, newObj) {
  var _createBuildArrayActi2;

  var handler = createBuildArrayActions('billingAddressIds', (_createBuildArrayActi2 = {}, _defineProperty(_createBuildArrayActi2, ADD_ACTIONS, function (addressId) {
    return {
      action: 'addBillingAddressId',
      addressId: addressId
    };
  }), _defineProperty(_createBuildArrayActi2, REMOVE_ACTIONS, function (addressId) {
    return {
      action: 'removeBillingAddressId',
      addressId: addressId
    };
  }), _createBuildArrayActi2));
  return handler(diff, oldObj, newObj);
}
function actionsMapShippingAddresses(diff, oldObj, newObj) {
  var _createBuildArrayActi3;

  var handler = createBuildArrayActions('shippingAddressIds', (_createBuildArrayActi3 = {}, _defineProperty(_createBuildArrayActi3, ADD_ACTIONS, function (addressId) {
    return {
      action: 'addShippingAddressId',
      addressId: addressId
    };
  }), _defineProperty(_createBuildArrayActi3, REMOVE_ACTIONS, function (addressId) {
    return {
      action: 'removeShippingAddressId',
      addressId: addressId
    };
  }), _createBuildArrayActi3));
  return handler(diff, oldObj, newObj);
}
function actionsMapAuthenticationModes(diff, oldObj, newObj) {
  // eslint-disable-next-line no-use-before-define
  return buildAuthenticationModeActions({
    actions: authenticationModeActionsList,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj
  });
}

function buildAuthenticationModeActions(_ref) {
  var actions = _ref.actions,
      diff = _ref.diff,
      oldObj = _ref.oldObj,
      newObj = _ref.newObj;
  return actions.map(function (item) {
    var key = item.key;
    var value = item.value || item.key;
    var delta = diff[key];
    var before = oldObj[key];
    var now = newObj[key];
    var isNotDefinedBefore = isEmptyValue(oldObj[key]);
    var isNotDefinedNow = isEmptyValue(newObj[key]);
    var authenticationModes = ['Password', 'ExternalAuth'];
    if (!delta) return undefined;
    if (isNotDefinedNow && isNotDefinedBefore) return undefined;
    if (newObj.authenticationMode === 'Password' && !newObj.password) throw new Error('Cannot set to Password authentication mode without password');
    if ('authenticationMode' in newObj && !authenticationModes.includes(newObj.authenticationMode)) throw new Error('Invalid Authentication Mode');

    if (!isNotDefinedNow && isNotDefinedBefore) {
      // no value previously set
      if (newObj.authenticationMode === 'ExternalAuth') return {
        action: item.action,
        authMode: now
      };
      return _defineProperty({
        action: item.action,
        authMode: now
      }, value, newObj.password);
    }
    /* no new value */


    if (isNotDefinedNow && !{}.hasOwnProperty.call(newObj, key)) return undefined;
    if (isNotDefinedNow && {}.hasOwnProperty.call(newObj, key)) // value unset
      return undefined; // We need to clone `before` as `patch` will mutate it

    var patched = patch(clone(before), delta);
    if (newObj.authenticationMode === 'ExternalAuth') return {
      action: item.action,
      authMode: patched
    };
    return _defineProperty({
      action: item.action,
      authMode: patched
    }, value, newObj.password);
  }).filter(function (action) {
    return !isNil(action);
  });
}

function createCustomerMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$j(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('references', function () {
      return actionsMapReferences$2(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('addresses', function () {
      return actionsMapAddresses(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('base', function () {
      return actionsMapSetDefaultBase(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('billingAddressIds', function () {
      return actionsMapBillingAddresses(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('shippingAddressIds', function () {
      return actionsMapShippingAddresses(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, newObj, oldObj);
    }));
    allActions.push(mapActionGroup('authenticationModes', function () {
      return actionsMapAuthenticationModes(diff, oldObj, newObj);
    }));
    return flatten(allActions);
  };
}

var customers = (function (actionGroupList, syncActionConfig) {
  // actionGroupList contains information about which action groups
  // are allowed or ignored
  // createMapActionGroup returns function 'mapActionGroup' that takes params:
  // - action group name
  // - callback function that should return a list of actions that correspond
  //    to the for the action group
  // this resulting function mapActionGroup will call the callback function
  // for allowed action groups and return the return value of the callback
  // It will return an empty array for ignored action groups
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createCustomerMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions, copyEmptyArrayProps);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$i = [{
  action: 'changeQuantity',
  key: 'quantityOnStock',
  actionKey: 'quantity'
}, {
  action: 'setRestockableInDays',
  key: 'restockableInDays'
}, {
  action: 'setExpectedDelivery',
  key: 'expectedDelivery'
}];
var referenceActionsList$1 = [{
  action: 'setSupplyChannel',
  key: 'supplyChannel'
}];
/**
 * SYNC FUNCTIONS
 */

function actionsMapBase$i(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$i,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}
function actionsMapReferences$1(diff, oldObj, newObj) {
  return buildReferenceActions({
    actions: referenceActionsList$1,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj
  });
}

function createInventoryMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$i(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('references', function () {
      return actionsMapReferences$1(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, newObj, oldObj);
    }));
    return flatten(allActions);
  };
}

var inventories = (function (actionGroupList, syncActionConfig) {
  // actionGroupList contains information about which action groups
  // are allowed or ignored
  // createMapActionGroup returns function 'mapActionGroup' that takes params:
  // - action group name
  // - callback function that should return a list of actions that correspond
  //    to the for the action group
  // this resulting function mapActionGroup will call the callback function
  // for allowed action groups and return the return value of the callback
  // It will return an empty array for ignored action groups
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createInventoryMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

function extractMatchingPairs(hashMap, key, before, now) {
  var oldObjPos;
  var newObjPos;
  var oldObj;
  var newObj;

  if (hashMap[key]) {
    oldObjPos = hashMap[key][0];
    newObjPos = hashMap[key][1];
    if (before && before[oldObjPos]) oldObj = before[oldObjPos];
    if (now && now[newObjPos]) newObj = now[newObjPos];
  }

  return {
    oldObj: oldObj,
    newObj: newObj
  };
}

var REGEX_NUMBER$3 = new RegExp(/^\d+$/);
var REGEX_UNDERSCORE_NUMBER$3 = new RegExp(/^_\d+$/);

function preProcessCollection() {
  var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var identifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';
  return collection.reduce(function (acc, currentValue, currentIndex) {
    acc.refByIndex[String(currentIndex)] = currentValue[identifier];
    acc.refByIdentifier[currentValue[identifier]] = String(currentIndex);
    return acc;
  }, {
    refByIndex: {},
    refByIdentifier: {}
  });
} // creates a hash of a location of an item in collection1 and collection2


function findMatchingPairs(diff) {
  var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var now = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var identifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'id';
  var result = {};

  var _preProcessCollection = preProcessCollection(before, identifier),
      beforeObjRefByIdentifier = _preProcessCollection.refByIdentifier,
      beforeObjRefByIndex = _preProcessCollection.refByIndex;

  var _preProcessCollection2 = preProcessCollection(now, identifier),
      nowObjRefByIdentifier = _preProcessCollection2.refByIdentifier,
      nowObjRefByIndex = _preProcessCollection2.refByIndex;

  forEach(diff, function (item, key) {
    if (REGEX_NUMBER$3.test(key)) {
      var matchingIdentifier = nowObjRefByIndex[key];
      result[key] = [beforeObjRefByIdentifier[matchingIdentifier], key];
    } else if (REGEX_UNDERSCORE_NUMBER$3.test(key)) {
      var index = key.substring(1);
      var _matchingIdentifier = beforeObjRefByIndex[index];
      result[key] = [index, nowObjRefByIdentifier[_matchingIdentifier]];
    }
  });
  return result;
}

var REGEX_NUMBER$2 = new RegExp(/^\d+$/);
var REGEX_UNDERSCORE_NUMBER$2 = new RegExp(/^_\d+$/);
var baseActionsList$h = [{
  action: 'changeName',
  key: 'name'
}, {
  action: 'changeSlug',
  key: 'slug'
}, {
  action: 'setDescription',
  key: 'description'
}, {
  action: 'setSearchKeywords',
  key: 'searchKeywords'
}, {
  action: 'setKey',
  key: 'key'
}, {
  action: 'setPriceMode',
  key: 'priceMode'
}];
var baseAssetActionsList = [{
  action: 'setAssetKey',
  key: 'key',
  actionKey: 'assetKey'
}, {
  action: 'changeAssetName',
  key: 'name'
}, {
  action: 'setAssetDescription',
  key: 'description'
}, {
  action: 'setAssetTags',
  key: 'tags'
}, {
  action: 'setAssetSources',
  key: 'sources'
}];
var metaActionsList = [{
  action: 'setMetaTitle',
  key: 'metaTitle'
}, {
  action: 'setMetaDescription',
  key: 'metaDescription'
}, {
  action: 'setMetaKeywords',
  key: 'metaKeywords'
}];
var referenceActionsList = [{
  action: 'setTaxCategory',
  key: 'taxCategory'
}, {
  action: 'transitionState',
  key: 'state'
}];
/**
 * HELPER FUNCTIONS
 */

var getIsAddAction = function getIsAddAction(key, resource) {
  return REGEX_NUMBER$2.test(key) && Array.isArray(resource) && resource.length;
};

var getIsUpdateAction = function getIsUpdateAction(key, resource) {
  return REGEX_NUMBER$2.test(key) && Object.keys(resource).length;
};

var getIsRemoveAction = function getIsRemoveAction(key, resource) {
  return REGEX_UNDERSCORE_NUMBER$2.test(key) && Number(resource[2]) === 0;
};

var getIsItemMovedAction = function getIsItemMovedAction(key, resource) {
  return REGEX_UNDERSCORE_NUMBER$2.test(key) && Number(resource[2]) === 3;
};

function _buildSkuActions(variantDiff, oldVariant) {
  if ({}.hasOwnProperty.call(variantDiff, 'sku')) {
    var newValue = getDeltaValue(variantDiff.sku);
    if (!newValue && !oldVariant.sku) return null;
    return {
      action: 'setSku',
      variantId: oldVariant.id,
      sku: newValue || null
    };
  }

  return null;
}

function _buildKeyActions(variantDiff, oldVariant) {
  if ({}.hasOwnProperty.call(variantDiff, 'key')) {
    var newValue = getDeltaValue(variantDiff.key);
    if (!newValue && !oldVariant.key) return null;
    return {
      action: 'setProductVariantKey',
      variantId: oldVariant.id,
      key: newValue || null
    };
  }

  return null;
}

function _buildNewSetAttributeAction(id, el, sameForAllAttributeNames) {
  var attributeName = el && el.name;
  if (!attributeName) return undefined;
  var action = {
    action: 'setAttribute',
    variantId: id,
    name: attributeName,
    value: el.value
  };

  if (sameForAllAttributeNames.indexOf(attributeName) !== -1) {
    action = _objectSpread2(_objectSpread2({}, action), {}, {
      action: 'setAttributeInAllVariants'
    });
    delete action.variantId;
  }

  return action;
}

function _buildSetAttributeAction(diffedValue, oldVariant, attribute, sameForAllAttributeNames) {
  if (!attribute) return undefined;
  var action = {
    action: 'setAttribute',
    variantId: oldVariant.id,
    name: attribute.name
  }; // Used as original object for patching long diff text

  var oldAttribute = oldVariant.attributes.find(function (a) {
    return a.name === attribute.name;
  }) || {};

  if (sameForAllAttributeNames.indexOf(attribute.name) !== -1) {
    action = _objectSpread2(_objectSpread2({}, action), {}, {
      action: 'setAttributeInAllVariants'
    });
    delete action.variantId;
  }

  if (Array.isArray(diffedValue)) action.value = getDeltaValue(diffedValue, oldAttribute.value);else if (typeof diffedValue === 'string') // LText: value: {en: "", de: ""}
    // Enum: value: {key: "foo", label: "Foo"}
    // LEnum: value: {key: "foo", label: {en: "Foo", de: "Foo"}}
    // Money: value: {centAmount: 123, currencyCode: ""}
    // *: value: ""
    // normal
    action.value = getDeltaValue(diffedValue, oldAttribute.value);else if (diffedValue.centAmount || diffedValue.currencyCode) // Money
    action.value = {
      centAmount: diffedValue.centAmount ? getDeltaValue(diffedValue.centAmount) : attribute.value.centAmount,
      currencyCode: diffedValue.currencyCode ? getDeltaValue(diffedValue.currencyCode) : attribute.value.currencyCode
    };else if (diffedValue.key) // Enum / LEnum (use only the key)
    action.value = getDeltaValue(diffedValue.key);else if (_typeof(diffedValue) === 'object') if ({}.hasOwnProperty.call(diffedValue, '_t') && diffedValue._t === 'a') {
    // set-typed attribute
    action = _objectSpread2(_objectSpread2({}, action), {}, {
      value: attribute.value
    });
  } else {
    // LText
    var updatedValue = Object.keys(diffedValue).reduce(function (acc, lang) {
      var patchedValue = getDeltaValue(diffedValue[lang], acc[lang]);
      return Object.assign(acc, _defineProperty({}, lang, patchedValue));
    }, _objectSpread2({}, oldAttribute.value));
    action.value = updatedValue;
  }
  return action;
}

function _buildVariantImagesAction(diffedImages) {
  var oldVariant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var newVariant = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var actions = []; // generate a hashMap to be able to reference the right image from both ends

  var matchingImagePairs = findMatchingPairs(diffedImages, oldVariant.images, newVariant.images, 'url');
  forEach(diffedImages, function (image, key) {
    var _extractMatchingPairs = extractMatchingPairs(matchingImagePairs, key, oldVariant.images, newVariant.images),
        oldObj = _extractMatchingPairs.oldObj,
        newObj = _extractMatchingPairs.newObj;

    if (REGEX_NUMBER$2.test(key)) {
      // New image
      if (Array.isArray(image) && image.length) actions.push({
        action: 'addExternalImage',
        variantId: oldVariant.id,
        image: getDeltaValue(image)
      });else if (_typeof(image) === 'object') if ({}.hasOwnProperty.call(image, 'url') && image.url.length === 2) {
        // There is a new image, remove the old one first.
        actions.push({
          action: 'removeImage',
          variantId: oldVariant.id,
          imageUrl: oldObj.url
        });
        actions.push({
          action: 'addExternalImage',
          variantId: oldVariant.id,
          image: newObj
        });
      } else if ({}.hasOwnProperty.call(image, 'label') && (image.label.length === 1 || image.label.length === 2)) actions.push({
        action: 'setImageLabel',
        variantId: oldVariant.id,
        imageUrl: oldObj.url,
        label: getDeltaValue(image.label)
      });
    } else if (REGEX_UNDERSCORE_NUMBER$2.test(key)) if (Array.isArray(image) && image.length === 3) {
      if (Number(image[2]) === 3) // image position changed
        actions.push({
          action: 'moveImageToPosition',
          variantId: oldVariant.id,
          imageUrl: oldObj.url,
          position: Number(image[1])
        });else if (Number(image[2]) === 0) // image removed
        actions.push({
          action: 'removeImage',
          variantId: oldVariant.id,
          imageUrl: oldObj.url
        });
    }
  });
  return actions;
}

function _buildVariantPricesAction(diffedPrices) {
  var oldVariant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var newVariant = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var enableDiscounted = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var addPriceActions = [];
  var changePriceActions = [];
  var removePriceActions = []; // generate a hashMap to be able to reference the right image from both ends

  var matchingPricePairs = findMatchingPairs(diffedPrices, oldVariant.prices, newVariant.prices);
  forEach(diffedPrices, function (price, key) {
    var _extractMatchingPairs2 = extractMatchingPairs(matchingPricePairs, key, oldVariant.prices, newVariant.prices),
        oldObj = _extractMatchingPairs2.oldObj,
        newObj = _extractMatchingPairs2.newObj;

    if (getIsAddAction(key, price)) {
      // Remove read-only fields
      var patchedPrice = price.map(function (p) {
        var shallowClone = _objectSpread2({}, p);

        if (enableDiscounted !== true) delete shallowClone.discounted;
        return shallowClone;
      });
      addPriceActions.push({
        action: 'addPrice',
        variantId: oldVariant.id,
        price: getDeltaValue(patchedPrice)
      });
      return;
    }

    if (getIsUpdateAction(key, price)) {
      // Remove the discounted field and make sure that the price
      // still has other values, otherwise simply return
      var filteredPrice = _objectSpread2({}, price);

      if (enableDiscounted !== true) delete filteredPrice.discounted;

      if (Object.keys(filteredPrice).length) {
        // At this point price should have changed, simply pick the new one
        var newPrice = _objectSpread2({}, newObj);

        if (enableDiscounted !== true) delete newPrice.discounted;
        changePriceActions.push({
          action: 'changePrice',
          priceId: oldObj.id,
          price: newPrice
        });
      }

      return;
    }

    if (getIsRemoveAction(key, price)) {
      // price removed
      removePriceActions.push({
        action: 'removePrice',
        priceId: oldObj.id
      });
    }
  });
  return [addPriceActions, changePriceActions, removePriceActions];
}

function _buildVariantAttributesActions(attributes, oldVariant, newVariant, sameForAllAttributeNames) {
  var actions = [];
  if (!attributes) return actions;
  forEach(attributes, function (value, key) {
    if (REGEX_NUMBER$2.test(key)) {
      if (Array.isArray(value)) {
        var id = oldVariant.id;
        var deltaValue = getDeltaValue(value);

        var setAction = _buildNewSetAttributeAction(id, deltaValue, sameForAllAttributeNames);

        if (setAction) actions.push(setAction);
      } else if (newVariant.attributes) {
        var _setAction = _buildSetAttributeAction(value.value, oldVariant, newVariant.attributes[key], sameForAllAttributeNames);

        if (_setAction) actions.push(_setAction);
      }
    } else if (REGEX_UNDERSCORE_NUMBER$2.test(key)) if (Array.isArray(value)) {
      // Ignore pure array moves!
      if (value.length === 3 && value[2] === 3) return;
      var _id = oldVariant.id;

      var _deltaValue = getDeltaValue(value);

      if (!_deltaValue) if (value[0] && value[0].name) // unset attribute if
        _deltaValue = {
          name: value[0].name
        };else _deltaValue = undefined;

      var _setAction2 = _buildNewSetAttributeAction(_id, _deltaValue, sameForAllAttributeNames);

      if (_setAction2) actions.push(_setAction2);
    } else {
      var index = key.substring(1);

      if (newVariant.attributes) {
        var _setAction3 = _buildSetAttributeAction(value.value, oldVariant, newVariant.attributes[index], sameForAllAttributeNames);

        if (_setAction3) actions.push(_setAction3);
      }
    }
  });
  return actions;
}

function toAssetIdentifier(asset) {
  var assetIdentifier = asset.id ? {
    assetId: asset.id
  } : {
    assetKey: asset.key
  };
  return assetIdentifier;
}

function toVariantIdentifier(variant) {
  var id = variant.id,
      sku = variant.sku;
  return id ? {
    variantId: id
  } : {
    sku: sku
  };
}

function _buildVariantChangeAssetOrderAction(diffAssets, oldVariant, newVariant) {
  var isAssetOrderChanged = Object.entries(diffAssets).find(function (entry) {
    return getIsItemMovedAction(entry[0], entry[1]);
  });

  if (!isAssetOrderChanged) {
    return [];
  }

  var assetIdsBefore = oldVariant.assets.map(function (_) {
    return _.id;
  });
  var assetIdsCurrent = newVariant.assets.map(function (_) {
    return _.id;
  }).filter(function (_) {
    return _ !== undefined;
  });
  var assetIdsToKeep = intersection(assetIdsCurrent, assetIdsBefore);
  var assetIdsToRemove = without.apply(void 0, [assetIdsBefore].concat(_toConsumableArray(assetIdsToKeep)));

  var changeAssetOrderAction = _objectSpread2({
    action: 'changeAssetOrder',
    assetOrder: assetIdsToKeep.concat(assetIdsToRemove)
  }, toVariantIdentifier(oldVariant));

  return [changeAssetOrderAction];
}

function _buildVariantAssetsActions(diffAssets, oldVariant, newVariant) {
  var assetActions = []; // generate a hashMap to be able to reference the right asset from both ends

  var matchingAssetPairs = findMatchingPairs(diffAssets, oldVariant.assets, newVariant.assets);
  forEach(diffAssets, function (asset, key) {
    var _extractMatchingPairs3 = extractMatchingPairs(matchingAssetPairs, key, oldVariant.assets, newVariant.assets),
        oldAsset = _extractMatchingPairs3.oldObj,
        newAsset = _extractMatchingPairs3.newObj;

    if (getIsAddAction(key, asset)) {
      assetActions.push(_objectSpread2(_objectSpread2({
        action: 'addAsset',
        asset: getDeltaValue(asset)
      }, toVariantIdentifier(newVariant)), {}, {
        position: Number(key)
      }));
      return;
    }

    if (getIsUpdateAction(key, asset)) {
      // todo add changeAssetOrder
      var basicActions = buildBaseAttributesActions({
        actions: baseAssetActionsList,
        diff: asset,
        oldObj: oldAsset,
        newObj: newAsset
      }).map(function (action) {
        // in case of 'setAssetKey' then the identifier will be only 'assetId'
        if (action.action === 'setAssetKey') {
          return _objectSpread2(_objectSpread2(_objectSpread2({}, action), toVariantIdentifier(oldVariant)), {}, {
            assetId: oldAsset.id
          });
        }

        return _objectSpread2(_objectSpread2(_objectSpread2({}, action), toVariantIdentifier(oldVariant)), toAssetIdentifier(oldAsset));
      });
      assetActions.push.apply(assetActions, _toConsumableArray(basicActions));

      if (asset.custom) {
        var customActions = actionsMapCustom(asset, newAsset, oldAsset, _objectSpread2(_objectSpread2({
          actions: {
            setCustomType: 'setAssetCustomType',
            setCustomField: 'setAssetCustomField'
          }
        }, toVariantIdentifier(oldVariant)), toAssetIdentifier(oldAsset)));
        assetActions.push.apply(assetActions, _toConsumableArray(customActions));
      }

      return;
    }

    if (getIsRemoveAction(key, asset)) {
      assetActions.push(_objectSpread2(_objectSpread2({
        action: 'removeAsset'
      }, toAssetIdentifier(oldAsset)), toVariantIdentifier(oldVariant)));
    }
  });

  var changedAssetOrderAction = _buildVariantChangeAssetOrderAction(diffAssets, oldVariant, newVariant);

  return [].concat(_toConsumableArray(changedAssetOrderAction), assetActions);
}
/**
 * SYNC FUNCTIONS
 */


function actionsMapBase$h(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$h,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}
function actionsMapMeta(diff, oldObj, newObj) {
  return buildBaseAttributesActions({
    actions: metaActionsList,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj
  });
}
function actionsMapAddVariants(diff, oldObj, newObj) {
  var handler = createBuildArrayActions('variants', _defineProperty({}, ADD_ACTIONS, function (newObject) {
    return _objectSpread2(_objectSpread2({}, newObject), {}, {
      action: 'addVariant'
    });
  }));
  return handler(diff, oldObj, newObj);
}
function actionsMapRemoveVariants(diff, oldObj, newObj) {
  var handler = createBuildArrayActions('variants', _defineProperty({}, REMOVE_ACTIONS, function (_ref) {
    var id = _ref.id;
    return {
      action: 'removeVariant',
      id: id
    };
  }));
  return handler(diff, oldObj, newObj);
}
function actionsMapReferences(diff, oldObj, newObj) {
  return buildReferenceActions({
    actions: referenceActionsList,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj
  });
}
function actionsMapCategories(diff) {
  var actions = [];
  if (!diff.categories) return actions;
  var addToCategoryActions = [];
  var removeFromCategoryActions = [];
  forEach(diff.categories, function (category) {
    if (Array.isArray(category)) {
      var action = {
        category: category[0]
      };

      if (category.length === 3) {
        // Ignore pure array moves!
        if (category[2] !== 3) {
          action.action = 'removeFromCategory';
          removeFromCategoryActions.push(action);
        }
      } else if (category.length === 1) {
        action.action = 'addToCategory';
        addToCategoryActions.push(action);
      }
    }
  }); // Make sure `removeFromCategory` actions come first

  return removeFromCategoryActions.concat(addToCategoryActions);
}
function actionsMapCategoryOrderHints(diff) {
  if (!diff.categoryOrderHints) return []; // Ignore this pattern as its means no changes happened [{},0,0]

  if (Array.isArray(diff.categoryOrderHints)) return [];
  return Object.keys(diff.categoryOrderHints).map(function (categoryId) {
    var hintChange = diff.categoryOrderHints[categoryId];
    var action = {
      action: 'setCategoryOrderHint',
      categoryId: categoryId
    };
    if (hintChange.length === 1) // item was added
      action.orderHint = hintChange[0];else if (hintChange.length === 2 && hintChange[1] !== 0) // item was changed
      action.orderHint = hintChange[1]; // else item was removed -> do not set 'orderHint' property

    return action;
  });
}
function actionsMapAssets(diff, oldObj, newObj, variantHashMap) {
  var allAssetsActions = [];
  var variants = diff.variants;
  if (variants) forEach(variants, function (variant, key) {
    var _extractMatchingPairs4 = extractMatchingPairs(variantHashMap, key, oldObj.variants, newObj.variants),
        oldVariant = _extractMatchingPairs4.oldObj,
        newVariant = _extractMatchingPairs4.newObj;

    if (variant.assets && (REGEX_UNDERSCORE_NUMBER$2.test(key) || REGEX_NUMBER$2.test(key))) {
      var assetActions = _buildVariantAssetsActions(variant.assets, oldVariant, newVariant);

      allAssetsActions = allAssetsActions.concat(assetActions);
    }
  });
  return allAssetsActions;
}
function actionsMapAttributes$1(diff, oldObj, newObj) {
  var sameForAllAttributeNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var variantHashMap = arguments.length > 4 ? arguments[4] : undefined;
  var actions = [];
  var variants = diff.variants;
  if (variants) forEach(variants, function (variant, key) {
    var _extractMatchingPairs5 = extractMatchingPairs(variantHashMap, key, oldObj.variants, newObj.variants),
        oldVariant = _extractMatchingPairs5.oldObj,
        newVariant = _extractMatchingPairs5.newObj;

    if (REGEX_NUMBER$2.test(key) && !Array.isArray(variant)) {
      var skuAction = _buildSkuActions(variant, oldVariant);

      var keyAction = _buildKeyActions(variant, oldVariant);

      if (skuAction) actions.push(skuAction);
      if (keyAction) actions.push(keyAction);
      var attributes = variant.attributes;

      var attrActions = _buildVariantAttributesActions(attributes, oldVariant, newVariant, sameForAllAttributeNames);

      actions = actions.concat(attrActions);
    }
  }); // Ensure that an action is unique.
  // This is especially necessary for SFA attributes.

  return uniqWith(actions, function (a, b) {
    return a.action === b.action && a.name === b.name && a.variantId === b.variantId;
  });
}
function actionsMapImages(diff, oldObj, newObj, variantHashMap) {
  var actions = [];
  var variants = diff.variants;
  if (variants) forEach(variants, function (variant, key) {
    var _extractMatchingPairs6 = extractMatchingPairs(variantHashMap, key, oldObj.variants, newObj.variants),
        oldVariant = _extractMatchingPairs6.oldObj,
        newVariant = _extractMatchingPairs6.newObj;

    if (REGEX_UNDERSCORE_NUMBER$2.test(key) || REGEX_NUMBER$2.test(key)) {
      var vActions = _buildVariantImagesAction(variant.images, oldVariant, newVariant);

      actions = actions.concat(vActions);
    }
  });
  return actions;
}
function actionsMapPrices(diff, oldObj, newObj, variantHashMap, enableDiscounted) {
  var addPriceActions = [];
  var changePriceActions = [];
  var removePriceActions = [];
  var variants = diff.variants;
  if (variants) forEach(variants, function (variant, key) {
    var _extractMatchingPairs7 = extractMatchingPairs(variantHashMap, key, oldObj.variants, newObj.variants),
        oldVariant = _extractMatchingPairs7.oldObj,
        newVariant = _extractMatchingPairs7.newObj;

    if (REGEX_UNDERSCORE_NUMBER$2.test(key) || REGEX_NUMBER$2.test(key)) {
      var _buildVariantPricesAc = _buildVariantPricesAction(variant.prices, oldVariant, newVariant, enableDiscounted),
          _buildVariantPricesAc2 = _slicedToArray(_buildVariantPricesAc, 3),
          addPriceAction = _buildVariantPricesAc2[0],
          changePriceAction = _buildVariantPricesAc2[1],
          removePriceAction = _buildVariantPricesAc2[2];

      addPriceActions = addPriceActions.concat(addPriceAction);
      changePriceActions = changePriceActions.concat(changePriceAction);
      removePriceActions = removePriceActions.concat(removePriceAction);
    }
  }); // price actions need to be in this below order

  return changePriceActions.concat(removePriceActions).concat(addPriceActions);
}
function actionsMapPricesCustom(diff, oldObj, newObj, variantHashMap) {
  var actions = [];
  var variants = diff.variants;
  if (variants) forEach(variants, function (variant, key) {
    var _extractMatchingPairs8 = extractMatchingPairs(variantHashMap, key, oldObj.variants, newObj.variants),
        oldVariant = _extractMatchingPairs8.oldObj,
        newVariant = _extractMatchingPairs8.newObj;

    if (variant && variant.prices && (REGEX_UNDERSCORE_NUMBER$2.test(key) || REGEX_NUMBER$2.test(key))) {
      var priceHashMap = findMatchingPairs(variant.prices, oldVariant.prices, newVariant.prices);
      forEach(variant.prices, function (price, index) {
        var _extractMatchingPairs9 = extractMatchingPairs(priceHashMap, index, oldVariant.prices, newVariant.prices),
            oldPrice = _extractMatchingPairs9.oldObj,
            newPrice = _extractMatchingPairs9.newObj;

        if (price.custom && (REGEX_UNDERSCORE_NUMBER$2.test(index) || REGEX_NUMBER$2.test(index))) {
          var generatedActions = actionsMapCustom(price, newPrice, oldPrice, {
            actions: {
              setCustomType: 'setProductPriceCustomType',
              setCustomField: 'setProductPriceCustomField'
            },
            priceId: oldPrice.id
          });
          actions = actions.concat(generatedActions);
        }
      });
    }
  });
  return actions;
}
function actionsMapMasterVariant(oldObj, newObj) {
  var createChangeMasterVariantAction = function createChangeMasterVariantAction(variantId) {
    return {
      action: 'changeMasterVariant',
      variantId: variantId
    };
  };

  var extractMasterVariantId = function extractMasterVariantId(fromObj) {
    var variants = Array.isArray(fromObj.variants) ? fromObj.variants : [];
    return variants[0] ? variants[0].id : undefined;
  };

  var newMasterVariantId = extractMasterVariantId(newObj);
  var oldMasterVariantId = extractMasterVariantId(oldObj); // Old and new master master variant differ and a new master variant id exists

  if (newMasterVariantId && oldMasterVariantId !== newMasterVariantId) return [createChangeMasterVariantAction(newMasterVariantId)];
  return [];
}

function createProductMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var allActions = [];
    var sameForAllAttributeNames = options.sameForAllAttributeNames,
        enableDiscounted = options.enableDiscounted;
    var publish = newObj.publish,
        staged = newObj.staged;
    var variantHashMap = findMatchingPairs(diff.variants, oldObj.variants, newObj.variants);
    allActions.push(mapActionGroup('attributes', function () {
      return actionsMapAttributes$1(diff, oldObj, newObj, sameForAllAttributeNames || [], variantHashMap);
    }));
    allActions.push(mapActionGroup('variants', function () {
      return actionsMapAddVariants(diff, oldObj, newObj);
    }));
    allActions.push(actionsMapMasterVariant(oldObj, newObj));
    allActions.push(mapActionGroup('variants', function () {
      return actionsMapRemoveVariants(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$h(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('meta', function () {
      return actionsMapMeta(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('references', function () {
      return actionsMapReferences(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('images', function () {
      return actionsMapImages(diff, oldObj, newObj, variantHashMap);
    }));
    allActions.push(mapActionGroup('pricesCustom', function () {
      return actionsMapPricesCustom(diff, oldObj, newObj, variantHashMap);
    }));
    allActions.push(mapActionGroup('prices', function () {
      return actionsMapPrices(diff, oldObj, newObj, variantHashMap, enableDiscounted);
    }));
    allActions.push(mapActionGroup('categories', function () {
      return actionsMapCategories(diff);
    }));
    allActions.push(mapActionGroup('categories', function () {
      return actionsMapCategoryOrderHints(diff);
    }));
    allActions.push(mapActionGroup('assets', function () {
      return actionsMapAssets(diff, oldObj, newObj, variantHashMap);
    }));
    if (publish === true || staged === false) return flatten(allActions).map(function (action) {
      return _objectSpread2(_objectSpread2({}, action), {}, {
        staged: false
      });
    });
    return flatten(allActions);
  };
}

function moveMasterVariantsIntoVariants(before, now) {
  var _copyEmptyArrayProps = copyEmptyArrayProps(before, now),
      _copyEmptyArrayProps2 = _slicedToArray(_copyEmptyArrayProps, 2),
      beforeCopy = _copyEmptyArrayProps2[0],
      nowCopy = _copyEmptyArrayProps2[1];

  var move = function move(obj) {
    return _objectSpread2(_objectSpread2({}, obj), {}, {
      masterVariant: undefined,
      variants: [obj.masterVariant].concat(_toConsumableArray(obj.variants || []))
    });
  };

  var hasMasterVariant = function hasMasterVariant(obj) {
    return obj && obj.masterVariant;
  };

  return [hasMasterVariant(beforeCopy) ? move(beforeCopy) : beforeCopy, hasMasterVariant(nowCopy) ? move(nowCopy) : nowCopy];
}

var products = (function (actionGroupList, syncActionConfig) {
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createProductMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions, moveMasterVariantsIntoVariants);
  return {
    buildActions: buildActions
  };
});

var REGEX_NUMBER$1 = new RegExp(/^\d+$/);
var REGEX_UNDERSCORE_NUMBER$1 = new RegExp(/^_\d+$/);

var isAddAction = function isAddAction(key, resource) {
  return REGEX_NUMBER$1.test(key) && Array.isArray(resource) && resource.length;
};

var isRemoveAction = function isRemoveAction(key, resource) {
  return REGEX_UNDERSCORE_NUMBER$1.test(key) && Number(resource[2]) === 0;
};

var baseActionsList$g = [{
  action: 'changeOrderState',
  key: 'orderState'
}, {
  action: 'changePaymentState',
  key: 'paymentState'
}, {
  action: 'changeShipmentState',
  key: 'shipmentState'
}];
/**
 * SYNC FUNCTIONS
 */

function actionsMapBase$g(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$g,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}
function actionsMapDeliveries(diff, oldObj, newObj) {
  var deliveriesDiff = diff.shippingInfo;
  if (!deliveriesDiff) return [];
  var handler = createBuildArrayActions('deliveries', _defineProperty({}, ADD_ACTIONS, function (newObject) {
    return {
      action: 'addDelivery',
      items: newObject.items,
      parcels: newObject.parcels
    };
  }));
  return handler(deliveriesDiff, oldObj.shippingInfo, newObj.shippingInfo);
}

function _buildDeliveryParcelsAction(diffedParcels) {
  var oldDelivery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var newDelivery = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var addParcelActions = [];
  var removeParcelActions = []; // generate a hashMap to be able to reference the right image from both ends

  var matchingParcelPairs = findMatchingPairs(diffedParcels, oldDelivery.parcels, newDelivery.parcels);
  forEach(diffedParcels, function (parcel, key) {
    var _extractMatchingPairs = extractMatchingPairs(matchingParcelPairs, key, oldDelivery.parcels, newDelivery.parcels),
        oldObj = _extractMatchingPairs.oldObj;

    if (isAddAction(key, parcel)) {
      addParcelActions.push(_objectSpread2({
        action: 'addParcelToDelivery',
        deliveryId: oldDelivery.id
      }, getDeltaValue(parcel)));
      return;
    }

    if (isRemoveAction(key, parcel)) {
      removeParcelActions.push({
        action: 'removeParcelFromDelivery',
        parcelId: oldObj.id
      });
    }
  });
  return [addParcelActions, removeParcelActions];
}

function _buildDeliveryItemsAction(diffedItems) {
  var newDelivery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var setDeliveryItemsAction = []; // If there is a diff it means that there were changes (update, adds or removes)
  // over the items, which means that `setDeliveryItems` change has happened over
  // the delivery

  if (diffedItems && Object.keys(diffedItems).length > 0) {
    setDeliveryItemsAction.push({
      action: 'setDeliveryItems',
      deliveryId: newDelivery.id,
      deliveryKey: newDelivery.key,
      items: newDelivery.items
    });
  }

  return [setDeliveryItemsAction];
}

function actionsMapParcels(diff, oldObj, newObj, deliveryHashMap) {
  var shippingInfo = diff.shippingInfo;
  if (!shippingInfo) return [];
  var deliveries = shippingInfo.deliveries;
  if (!deliveries) return [];
  var addParcelActions = [];
  var removeParcelActions = [];
  if (deliveries) forEach(deliveries, function (delivery, key) {
    var _extractMatchingPairs2 = extractMatchingPairs(deliveryHashMap, key, oldObj.shippingInfo.deliveries, newObj.shippingInfo.deliveries),
        oldDelivery = _extractMatchingPairs2.oldObj,
        newDelivery = _extractMatchingPairs2.newObj;

    if (REGEX_UNDERSCORE_NUMBER$1.test(key) || REGEX_NUMBER$1.test(key)) {
      var _buildDeliveryParcels = _buildDeliveryParcelsAction(delivery.parcels, oldDelivery, newDelivery),
          _buildDeliveryParcels2 = _slicedToArray(_buildDeliveryParcels, 2),
          addParcelAction = _buildDeliveryParcels2[0],
          removeParcelAction = _buildDeliveryParcels2[1];

      addParcelActions = addParcelActions.concat(addParcelAction);
      removeParcelActions = removeParcelActions.concat(removeParcelAction);
    }
  });
  return removeParcelActions.concat(addParcelActions);
}
function actionsMapDeliveryItems(diff, oldObj, newObj, deliveryHashMap) {
  var shippingInfo = diff.shippingInfo;
  if (!shippingInfo) return [];
  var deliveries = shippingInfo.deliveries;
  if (!deliveries) return [];
  var setDeliveryItemsActions = [];
  forEach(deliveries, function (delivery, key) {
    var _extractMatchingPairs3 = extractMatchingPairs(deliveryHashMap, key, oldObj.shippingInfo.deliveries, newObj.shippingInfo.deliveries),
        newDelivery = _extractMatchingPairs3.newObj;

    if (REGEX_UNDERSCORE_NUMBER$1.test(key) || REGEX_NUMBER$1.test(key)) {
      var _buildDeliveryItemsAc = _buildDeliveryItemsAction(delivery.items, newDelivery),
          _buildDeliveryItemsAc2 = _slicedToArray(_buildDeliveryItemsAc, 1),
          setDeliveryItemsAction = _buildDeliveryItemsAc2[0];

      setDeliveryItemsActions = setDeliveryItemsActions.concat(setDeliveryItemsAction);
    }
  });
  return setDeliveryItemsActions;
}
function actionsMapReturnsInfo(diff, oldObj, newObj) {
  var _createBuildArrayActi2;

  var returnInfoDiff = diff.returnInfo;
  if (!returnInfoDiff) return [];
  var handler = createBuildArrayActions('returnInfo', (_createBuildArrayActi2 = {}, _defineProperty(_createBuildArrayActi2, ADD_ACTIONS, function (newReturnInfo) {
    if (newReturnInfo.items) {
      return [_objectSpread2({
        action: 'addReturnInfo'
      }, newReturnInfo)];
    }

    return [];
  }), _defineProperty(_createBuildArrayActi2, CHANGE_ACTIONS, function (oldSReturnInfo, newReturnInfo, key) {
    var _returnInfoDiff$key$i = returnInfoDiff[key].items,
        items = _returnInfoDiff$key$i === void 0 ? {} : _returnInfoDiff$key$i;

    if (Object.keys(items).length === 0) {
      return [];
    }

    return Object.keys(items).reduce(function (actions, index) {
      var item = newReturnInfo.items[index];

      if (items[index].shipmentState) {
        actions.push({
          action: 'setReturnShipmentState',
          returnItemId: item.id,
          shipmentState: item.shipmentState
        });
      }

      if (items[index].paymentState) {
        actions.push({
          action: 'setReturnPaymentState',
          returnItemId: item.id,
          paymentState: item.paymentState
        });
      }

      return actions;
    }, []);
  }), _createBuildArrayActi2));
  return handler(diff, oldObj, newObj);
}

function createOrderMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    var deliveryHashMap;

    if (diff.shippingInfo && diff.shippingInfo.deliveries) {
      deliveryHashMap = findMatchingPairs(diff.shippingInfo.deliveries, oldObj.shippingInfo.deliveries, newObj.shippingInfo.deliveries);
    }

    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$g(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('deliveries', function () {
      return actionsMapDeliveries(diff, oldObj, newObj);
    }));
    allActions.push(mapActionGroup('parcels', function () {
      return actionsMapParcels(diff, oldObj, newObj, deliveryHashMap);
    }));
    allActions.push(mapActionGroup('items', function () {
      return actionsMapDeliveryItems(diff, oldObj, newObj, deliveryHashMap);
    }));
    allActions.push(flatten(mapActionGroup('returnInfo', function () {
      return actionsMapReturnsInfo(diff, oldObj, newObj);
    })));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, newObj, oldObj);
    }));
    return flatten(allActions);
  };
}

var orders = (function (actionGroupList, syncActionConfig) {
  // actionGroupList contains information about which action groups
  // are allowed or ignored
  // createMapActionGroup returns function 'mapActionGroup' that takes params:
  // - action group name
  // - callback function that should return a list of actions that correspond
  //    to the for the action group
  // this resulting function mapActionGroup will call the callback function
  // for allowed action groups and return the return value of the callback
  // It will return an empty array for ignored action groups
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createOrderMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$f = [{
  action: 'changeIsActive',
  key: 'isActive'
}, {
  action: 'changeName',
  key: 'name'
}, {
  action: 'changePredicate',
  key: 'predicate'
}, {
  action: 'changeSortOrder',
  key: 'sortOrder'
}, {
  action: 'changeValue',
  key: 'value'
}, {
  action: 'setDescription',
  key: 'description'
}, {
  action: 'setValidFrom',
  key: 'validFrom'
}, {
  action: 'setValidUntil',
  key: 'validUntil'
}, {
  action: 'setKey',
  key: 'key'
}];
function actionsMapBase$f(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$f,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}

var validityActions = ['setValidFrom', 'setValidUntil'];

var isValidityActions = function isValidityActions(actionName) {
  return validityActions.includes(actionName);
};

function combineValidityActions() {
  var actions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var _actions$filter = actions.filter(function (item) {
    return isValidityActions(item.action);
  }),
      _actions$filter2 = _slicedToArray(_actions$filter, 2),
      setValidFromAction = _actions$filter2[0],
      setValidUntilAction = _actions$filter2[1];

  if (setValidFromAction && setValidUntilAction) {
    return [].concat(_toConsumableArray(actions.filter(function (item) {
      return !isValidityActions(item.action);
    })), [{
      action: 'setValidFromAndUntil',
      validFrom: setValidFromAction.validFrom,
      validUntil: setValidUntilAction.validUntil
    }]);
  }

  return actions;
}

function createProductDiscountsMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$f(diff, oldObj, newObj, syncActionConfig);
    }));
    return combineValidityActions(flatten(allActions));
  };
}

var productDiscounts = (function (actionGroupList) {
  var syncActionConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createProductDiscountsMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$e = [{
  action: 'changeIsActive',
  key: 'isActive'
}, {
  action: 'setName',
  key: 'name'
}, {
  action: 'setDescription',
  key: 'description'
}, {
  action: 'setCartPredicate',
  key: 'cartPredicate'
}, {
  action: 'setMaxApplications',
  key: 'maxApplications'
}, {
  action: 'setMaxApplicationsPerCustomer',
  key: 'maxApplicationsPerCustomer'
}, {
  action: 'changeCartDiscounts',
  key: 'cartDiscounts'
}, {
  action: 'setValidFrom',
  key: 'validFrom'
}, {
  action: 'setValidUntil',
  key: 'validUntil'
}, {
  action: 'changeGroups',
  key: 'groups'
}];
function actionsMapBase$e(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$e,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}

function createDiscountCodesMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$e(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, newObj, oldObj);
    }));
    return combineValidityActions(flatten(allActions));
  };
}

var discountCodes = (function (actionGroupList) {
  var syncActionConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // actionGroupList contains information about which action groups
  // are allowed or ignored
  // createMapActionGroup returns function 'mapActionGroup' that takes params:
  // - action group name
  // - callback function that should return a list of actions that correspond
  //    to the for the action group
  // this resulting function mapActionGroup will call the callback function
  // for allowed action groups and return the return value of the callback
  // It will return an empty array for ignored action groups
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createDiscountCodesMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$d = [{
  action: 'changeName',
  key: 'name'
}, {
  action: 'setKey',
  key: 'key'
}];
function actionsMapBase$d(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$d,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}

function createCustomerGroupMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$d(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, newObj, oldObj);
    }));
    return flatten(allActions);
  };
}

var customerGroup = (function (actionGroupList) {
  var syncActionConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createCustomerGroupMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$c = [{
  action: 'changeIsActive',
  key: 'isActive'
}, {
  action: 'changeName',
  key: 'name'
}, {
  action: 'changeCartPredicate',
  key: 'cartPredicate'
}, {
  action: 'changeSortOrder',
  key: 'sortOrder'
}, {
  action: 'changeValue',
  key: 'value'
}, {
  action: 'changeRequiresDiscountCode',
  key: 'requiresDiscountCode'
}, {
  action: 'changeTarget',
  key: 'target'
}, {
  action: 'setDescription',
  key: 'description'
}, {
  action: 'setValidFrom',
  key: 'validFrom'
}, {
  action: 'setValidUntil',
  key: 'validUntil'
}, {
  action: 'changeStackingMode',
  key: 'stackingMode'
}, {
  action: 'setKey',
  key: 'key'
}];
function actionsMapBase$c(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$c,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}

function createCartDiscountsMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$c(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, newObj, oldObj);
    }));
    return combineValidityActions(flatten(allActions));
  };
}

var cartDiscounts = (function (actionGroupList) {
  var syncActionConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createCartDiscountsMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$b = [{
  action: 'changeName',
  key: 'name'
}, {
  action: 'setKey',
  key: 'key'
}, {
  action: 'setDescription',
  key: 'description'
}];
function actionsMapBase$b(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$b,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}
function actionsMapRates(diff, oldObj, newObj) {
  var _createBuildArrayActi;

  var handler = createBuildArrayActions('rates', (_createBuildArrayActi = {}, _defineProperty(_createBuildArrayActi, ADD_ACTIONS, function (newObject) {
    return {
      action: 'addTaxRate',
      taxRate: newObject
    };
  }), _defineProperty(_createBuildArrayActi, REMOVE_ACTIONS, function (objectToRemove) {
    return {
      action: 'removeTaxRate',
      taxRateId: objectToRemove.id
    };
  }), _defineProperty(_createBuildArrayActi, CHANGE_ACTIONS, function (oldObject, updatedObject) {
    return {
      action: 'replaceTaxRate',
      taxRateId: oldObject.id === updatedObject.id ? oldObject.id : updatedObject.id,
      taxRate: updatedObject
    };
  }), _createBuildArrayActi));
  return handler(diff, oldObj, newObj);
}

function createTaxCategoriesMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$b(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('rates', function () {
      return actionsMapRates(diff, oldObj, newObj);
    }));
    return flatten(allActions);
  };
}

var taxCategories = (function (actionGroupList, syncActionConfig) {
  // config contains information about which action groups
  // are allowed or ignored
  // createMapActionGroup returns function 'mapActionGroup' that takes params:
  // - action group name
  // - callback function that should return a list of actions that correspond
  //    to the for the action group
  // this resulting function mapActionGroup will call the callback function
  // for allowed action groups and return the return value of the callback
  // It will return an empty array for ignored action groups
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createTaxCategoriesMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$a = [{
  action: 'changeName',
  key: 'name'
}, {
  action: 'setDescription',
  key: 'description'
}, {
  action: 'setKey',
  key: 'key'
}];

var hasLocation = function hasLocation(locations, otherLocation) {
  return locations.some(function (location) {
    return location.country === otherLocation.country;
  });
};

function actionsMapBase$a(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$a,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}
function actionsMapLocations(diff, oldObj, newObj) {
  var _createBuildArrayActi;

  var handler = createBuildArrayActions('locations', (_createBuildArrayActi = {}, _defineProperty(_createBuildArrayActi, ADD_ACTIONS, function (newLocation) {
    return {
      action: 'addLocation',
      location: newLocation
    };
  }), _defineProperty(_createBuildArrayActi, REMOVE_ACTIONS, function (oldLocation) {
    return (// We only add the action if the location is not included in the new object.
      !hasLocation(newObj.locations, oldLocation) ? {
        action: 'removeLocation',
        location: oldLocation
      } : null
    );
  }), _defineProperty(_createBuildArrayActi, CHANGE_ACTIONS, function (oldLocation, newLocation) {
    var result = []; // We only remove the location in case that the oldLocation is not
    // included in the new object

    if (!hasLocation(newObj.locations, oldLocation)) result.push({
      action: 'removeLocation',
      location: oldLocation
    }); // We only add the location in case that the newLocation was not
    // included in the old object

    if (!hasLocation(oldObj.locations, newLocation)) result.push({
      action: 'addLocation',
      location: newLocation
    });
    return result;
  }), _createBuildArrayActi));
  return handler(diff, oldObj, newObj);
}

function createZonesMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$a(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(flatten(mapActionGroup('locations', function () {
      return actionsMapLocations(diff, oldObj, newObj);
    })));
    return flatten(allActions);
  };
}

var zones = (function (actionGroupList, syncActionConfig) {
  // config contains information about which action groups
  // are allowed or ignored
  // createMapActionGroup returns function 'mapActionGroup' that takes params:
  // - action group name
  // - callback function that should return a list of actions that correspond
  //    to the for the action group
  // this resulting function mapActionGroup will call the callback function
  // for allowed action groups and return the return value of the callback
  // It will return an empty array for ignored action groups
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createZonesMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$9 = [{
  action: 'setKey',
  key: 'key'
}, {
  action: 'changeName',
  key: 'name'
}, {
  action: 'setLocalizedName',
  key: 'localizedName'
}, {
  action: 'setDescription',
  key: 'description'
}, {
  action: 'setLocalizedDescription',
  key: 'localizedDescription'
}, {
  action: 'changeIsDefault',
  key: 'isDefault'
}, {
  action: 'setPredicate',
  key: 'predicate'
}, {
  action: 'changeTaxCategory',
  key: 'taxCategory'
}];
function actionsMapBase$9(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$9,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}

var addShippingRates = function addShippingRates(newZoneRate) {
  return newZoneRate.shippingRates ? newZoneRate.shippingRates.map(function (shippingRate) {
    return {
      action: 'addShippingRate',
      zone: newZoneRate.zone,
      shippingRate: shippingRate
    };
  }) : [];
};

function actionsMapZoneRatesShippingRates(diff, oldObj, newObj) {
  var _createBuildArrayActi;

  var handler = createBuildArrayActions('shippingRates', (_createBuildArrayActi = {}, _defineProperty(_createBuildArrayActi, ADD_ACTIONS, function (newShippingRate) {
    return {
      action: 'addShippingRate',
      zone: newObj.zone,
      shippingRate: newShippingRate
    };
  }), _defineProperty(_createBuildArrayActi, REMOVE_ACTIONS, function (oldShippingRate) {
    return {
      action: 'removeShippingRate',
      zone: oldObj.zone,
      shippingRate: oldShippingRate
    };
  }), _defineProperty(_createBuildArrayActi, CHANGE_ACTIONS, function (oldShippingRate, newShippingRate) {
    return [{
      action: 'removeShippingRate',
      zone: oldObj.zone,
      shippingRate: oldShippingRate
    }, {
      action: 'addShippingRate',
      zone: newObj.zone,
      shippingRate: newShippingRate
    }];
  }), _createBuildArrayActi));
  return handler(diff, oldObj, newObj);
}

function actionsMapZoneRates(diff, oldObj, newObj) {
  var _createBuildArrayActi2;

  var handler = createBuildArrayActions('zoneRates', (_createBuildArrayActi2 = {}, _defineProperty(_createBuildArrayActi2, ADD_ACTIONS, function (newZoneRate) {
    return [{
      action: 'addZone',
      zone: newZoneRate.zone
    }].concat(_toConsumableArray(addShippingRates(newZoneRate)));
  }), _defineProperty(_createBuildArrayActi2, REMOVE_ACTIONS, function (oldZoneRate) {
    return {
      action: 'removeZone',
      zone: oldZoneRate.zone
    };
  }), _defineProperty(_createBuildArrayActi2, CHANGE_ACTIONS, function (oldZoneRate, newZoneRate) {
    var hasZoneActions = false;
    var shippingRateActions = Object.keys(diff.zoneRates).reduce(function (actions, key) {
      if (diff.zoneRates[key].zone) hasZoneActions = true;
      if (diff.zoneRates[key].shippingRates) return [].concat(_toConsumableArray(actions), _toConsumableArray(actionsMapZoneRatesShippingRates(diff.zoneRates[key], oldZoneRate, newZoneRate)));
      return actions;
    }, []);
    return flatten(hasZoneActions ? [].concat(_toConsumableArray(shippingRateActions), [{
      action: 'removeZone',
      zone: oldZoneRate.zone
    }, {
      action: 'addZone',
      zone: newZoneRate.zone
    }]) : shippingRateActions);
  }), _createBuildArrayActi2));
  return handler(diff, oldObj, newObj);
}

function createShippingMethodsMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$9(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(flatten(mapActionGroup('zoneRates', function () {
      return actionsMapZoneRates(diff, oldObj, newObj);
    })));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, newObj, oldObj);
    }));
    return flatten(allActions);
  };
}

var shippingMethods = (function (actionGroupList, syncActionConfig) {
  // actionGroupList contains information about which action groups
  // are allowed or ignored
  // createMapActionGroup returns function 'mapActionGroup' that takes params:
  // - action group name
  // - callback function that should return a list of actions that correspond
  //    to the for the action group
  // this resulting function mapActionGroup will call the callback function
  // for allowed action groups and return the return value of the callback
  // It will return an empty array for ignored action groups
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createShippingMethodsMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';
var keys = Object.keys;
/**
 * are the values passed strictly equal or both NaN
 *
 * @param a the value to compare against
 * @param b the value to test
 * @returns are the values equal by the SameValueZero principle
 */

function sameValueZeroEqual(a, b) {
  return a === b || a !== a && b !== b;
}
/**
 * is the value a plain object
 *
 * @param value the value to test
 * @returns is the value a plain object
 */


function isPlainObject(value) {
  return value.constructor === Object || value.constructor == null;
}
/**
 * is the value promise-like (meaning it is thenable)
 *
 * @param value the value to test
 * @returns is the value promise-like
 */


function isPromiseLike(value) {
  return !!value && typeof value.then === 'function';
}
/**
 * is the value passed a react element
 *
 * @param value the value to test
 * @returns is the value a react element
 */


function isReactElement(value) {
  return !!(value && value.$$typeof);
}
/**
 * in cases where WeakSet is not supported, creates a new custom
 * object that mimics the necessary API aspects for cache purposes
 *
 * @returns the new cache object
 */


function getNewCacheFallback() {
  var values = [];
  return {
    add: function add(value) {
      values.push(value);
    },
    has: function has(value) {
      return values.indexOf(value) !== -1;
    }
  };
}
/**
 * get a new cache object to prevent circular references
 *
 * @returns the new cache object
 */


var getNewCache = function (canUseWeakMap) {
  if (canUseWeakMap) {
    return function _getNewCache() {
      return new WeakSet();
    };
  }

  return getNewCacheFallback;
}(HAS_WEAKSET_SUPPORT);
/**
 * create a custom isEqual handler specific to circular objects
 *
 * @param [isEqual] the isEqual comparator to use instead of isDeepEqual
 * @returns the method to create the `isEqual` function
 */


function createCircularEqualCreator(isEqual) {
  return function createCircularEqual(comparator) {
    var _comparator = isEqual || comparator;

    return function circularEqual(a, b, cache) {
      if (cache === void 0) {
        cache = getNewCache();
      }

      var isCacheableA = !!a && _typeof(a) === 'object';
      var isCacheableB = !!b && _typeof(b) === 'object';

      if (isCacheableA || isCacheableB) {
        var hasA = isCacheableA && cache.has(a);
        var hasB = isCacheableB && cache.has(b);

        if (hasA || hasB) {
          return hasA && hasB;
        }

        if (isCacheableA) {
          cache.add(a);
        }

        if (isCacheableB) {
          cache.add(b);
        }
      }

      return _comparator(a, b, cache);
    };
  };
}
/**
 * are the arrays equal in value
 *
 * @param a the array to test
 * @param b the array to test against
 * @param isEqual the comparator to determine equality
 * @param meta the meta object to pass through
 * @returns are the arrays equal
 */


function areArraysEqual(a, b, isEqual, meta) {
  var index = a.length;

  if (b.length !== index) {
    return false;
  }

  while (index-- > 0) {
    if (!isEqual(a[index], b[index], meta)) {
      return false;
    }
  }

  return true;
}
/**
 * are the maps equal in value
 *
 * @param a the map to test
 * @param b the map to test against
 * @param isEqual the comparator to determine equality
 * @param meta the meta map to pass through
 * @returns are the maps equal
 */


function areMapsEqual(a, b, isEqual, meta) {
  var isValueEqual = a.size === b.size;

  if (isValueEqual && a.size) {
    var matchedIndices_1 = {};
    a.forEach(function (aValue, aKey) {
      if (isValueEqual) {
        var hasMatch_1 = false;
        var matchIndex_1 = 0;
        b.forEach(function (bValue, bKey) {
          if (!hasMatch_1 && !matchedIndices_1[matchIndex_1]) {
            hasMatch_1 = isEqual(aKey, bKey, meta) && isEqual(aValue, bValue, meta);

            if (hasMatch_1) {
              matchedIndices_1[matchIndex_1] = true;
            }
          }

          matchIndex_1++;
        });
        isValueEqual = hasMatch_1;
      }
    });
  }

  return isValueEqual;
}

var OWNER = '_owner';
var hasOwnProperty = Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);
/**
 * are the objects equal in value
 *
 * @param a the object to test
 * @param b the object to test against
 * @param isEqual the comparator to determine equality
 * @param meta the meta object to pass through
 * @returns are the objects equal
 */

function areObjectsEqual(a, b, isEqual, meta) {
  var keysA = keys(a);
  var index = keysA.length;

  if (keys(b).length !== index) {
    return false;
  }

  if (index) {
    var key = void 0;

    while (index-- > 0) {
      key = keysA[index];

      if (key === OWNER) {
        var reactElementA = isReactElement(a);
        var reactElementB = isReactElement(b);

        if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {
          return false;
        }
      }

      if (!hasOwnProperty(b, key) || !isEqual(a[key], b[key], meta)) {
        return false;
      }
    }
  }

  return true;
}
/**
 * are the regExps equal in value
 *
 * @param a the regExp to test
 * @param b the regExp to test agains
 * @returns are the regExps equal
 */


function areRegExpsEqual(a, b) {
  return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.unicode === b.unicode && a.sticky === b.sticky && a.lastIndex === b.lastIndex;
}
/**
 * are the sets equal in value
 *
 * @param a the set to test
 * @param b the set to test against
 * @param isEqual the comparator to determine equality
 * @param meta the meta set to pass through
 * @returns are the sets equal
 */


function areSetsEqual(a, b, isEqual, meta) {
  var isValueEqual = a.size === b.size;

  if (isValueEqual && a.size) {
    var matchedIndices_2 = {};
    a.forEach(function (aValue) {
      if (isValueEqual) {
        var hasMatch_2 = false;
        var matchIndex_2 = 0;
        b.forEach(function (bValue) {
          if (!hasMatch_2 && !matchedIndices_2[matchIndex_2]) {
            hasMatch_2 = isEqual(aValue, bValue, meta);

            if (hasMatch_2) {
              matchedIndices_2[matchIndex_2] = true;
            }
          }

          matchIndex_2++;
        });
        isValueEqual = hasMatch_2;
      }
    });
  }

  return isValueEqual;
}

var HAS_MAP_SUPPORT = typeof Map === 'function';
var HAS_SET_SUPPORT = typeof Set === 'function';

function createComparator(createIsEqual) {
  var isEqual =
  /* eslint-disable no-use-before-define */
  typeof createIsEqual === 'function' ? createIsEqual(comparator) : comparator;
  /* eslint-enable */

  /**
   * compare the value of the two objects and return true if they are equivalent in values
   *
   * @param a the value to test against
   * @param b the value to test
   * @param [meta] an optional meta object that is passed through to all equality test calls
   * @returns are a and b equivalent in value
   */

  function comparator(a, b, meta) {
    if (a === b) {
      return true;
    }

    if (a && b && _typeof(a) === 'object' && _typeof(b) === 'object') {
      if (isPlainObject(a) && isPlainObject(b)) {
        return areObjectsEqual(a, b, isEqual, meta);
      }

      var aShape = Array.isArray(a);
      var bShape = Array.isArray(b);

      if (aShape || bShape) {
        return aShape === bShape && areArraysEqual(a, b, isEqual, meta);
      }

      aShape = a instanceof Date;
      bShape = b instanceof Date;

      if (aShape || bShape) {
        return aShape === bShape && sameValueZeroEqual(a.getTime(), b.getTime());
      }

      aShape = a instanceof RegExp;
      bShape = b instanceof RegExp;

      if (aShape || bShape) {
        return aShape === bShape && areRegExpsEqual(a, b);
      }

      if (isPromiseLike(a) || isPromiseLike(b)) {
        return a === b;
      }

      if (HAS_MAP_SUPPORT) {
        aShape = a instanceof Map;
        bShape = b instanceof Map;

        if (aShape || bShape) {
          return aShape === bShape && areMapsEqual(a, b, isEqual, meta);
        }
      }

      if (HAS_SET_SUPPORT) {
        aShape = a instanceof Set;
        bShape = b instanceof Set;

        if (aShape || bShape) {
          return aShape === bShape && areSetsEqual(a, b, isEqual, meta);
        }
      }

      return areObjectsEqual(a, b, isEqual, meta);
    }

    return a !== a && b !== b;
  }

  return comparator;
}

var deepEqual = createComparator();
createComparator(function () {
  return sameValueZeroEqual;
});
createComparator(createCircularEqualCreator());
createComparator(createCircularEqualCreator(sameValueZeroEqual));

var baseActionsList$8 = [{
  action: 'changeName',
  key: 'name'
}, {
  action: 'setKey',
  key: 'key'
}, {
  action: 'changeDescription',
  key: 'description'
}];
function actionsMapBase$8(diff, previous, next) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // when `diff` is undefined, then the underlying `buildActions` has returned any diff
  // which given in product-types would mean that `buildActions` has run with `nestedValuesChanges` applied
  // To allow continuation of update-action generation, we let this pass..
  if (!diff) return [];
  return buildBaseAttributesActions({
    diff: diff,
    actions: baseActionsList$8,
    oldObj: previous,
    newObj: next,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
} // this is nearly similar to `buildBaseAttributesActions`, however with a significant difference.
// `buildBasAttributesActions` generates update-actions with help of `diff`,
// which is an object consisting of flags which indicates different operations.
// `generateBaseFieldsUpdateActions` only generate based on `previous` and `next`.

var generateBaseFieldsUpdateActions = function generateBaseFieldsUpdateActions(previous, next, actionDefinition) {
  var isEmpty = createIsEmptyValue([undefined, null, '']);
  return Object.entries(actionDefinition).reduce(function (nextUpdateActions, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        field = _ref2[0],
        actionFieldDefinition = _ref2[1];

    if (isEmpty(previous[field]) && isEmpty(next[field])) return nextUpdateActions;
    if (!isEmpty(previous[field]) && isEmpty(next[field])) return [].concat(_toConsumableArray(nextUpdateActions), [actionFieldDefinition]);

    if (!deepEqual(previous[field], next[field])) {
      switch (field) {
        // BEWARE that this is generates update-action only for key of enum attribute value,
        // not key of product type. If we need to re-factor `product-types` sync actions to use
        // `generateBaseFieldsUpdateActions`, we need to extract the following logic so we could
        // cover both entity types.
        case 'key':
          return [].concat(_toConsumableArray(nextUpdateActions), [// Another option is to have explicit name of `field` e.g `enumKey`, which we could use to
          // generate appropriate update-action for respective entity type.
          // An outline of this on the top of my head:
          // ```js
          // case 'enumKey':
          //   return [
          //     ...nextUpdateActions,
          //     {
          //       action: actionFieldDefinition.action,
          //       attributeName: actionFieldDefinition.attributeName,
          //       key: previous.key,
          //       newKey: next.key,
          //     },
          //   ]
          // case 'productTypeKey':
          //   return [
          //     ...nextUpdateActions,
          //     {
          //       action: actionFieldDefinition.action,
          //       key: next.key
          //     },
          //   ]
          // ```
          {
            action: actionFieldDefinition.action,
            attributeName: actionFieldDefinition.attributeName,
            key: previous[field],
            newKey: next[field]
          }]);
        // attribute

        case 'attributeConstraint':
        case 'inputHint':
          return [].concat(_toConsumableArray(nextUpdateActions), [{
            action: actionFieldDefinition.action,
            attributeName: actionFieldDefinition.attributeName,
            newValue: next[field]
          }]);

        default:
          return [].concat(_toConsumableArray(nextUpdateActions), [_defineProperty({
            action: actionFieldDefinition.action,
            attributeName: actionFieldDefinition.attributeName
          }, field, next[field])]);
      }
    }

    return nextUpdateActions;
  }, []);
};

var generateUpdateActionsForAttributeDefinitions = function generateUpdateActionsForAttributeDefinitions() {
  var attributeDefinitions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var removedAttributeDefinitions = attributeDefinitions.filter(function (attributeDefinition) {
    return attributeDefinition.previous && !attributeDefinition.next;
  });
  var updatedAttributeDefinitions = attributeDefinitions.filter(function (attributeDefinition) {
    return attributeDefinition.previous && attributeDefinition.next;
  });
  var addedAttributeDefinitions = attributeDefinitions.filter(function (attributeDefinition) {
    return !attributeDefinition.previous && attributeDefinition.next;
  });
  return [].concat(_toConsumableArray(removedAttributeDefinitions.map(function (attributeDef) {
    return {
      action: 'removeAttributeDefinition',
      name: attributeDef.previous.name
    };
  })), _toConsumableArray(flatten(updatedAttributeDefinitions.map(function (updatedAttributeDefinition) {
    return generateBaseFieldsUpdateActions(updatedAttributeDefinition.previous, updatedAttributeDefinition.next, {
      label: {
        action: 'changeLabel',
        attributeName: updatedAttributeDefinition.previous.name
      },
      inputTip: {
        action: 'setInputTip',
        attributeName: updatedAttributeDefinition.previous.name
      },
      inputHint: {
        action: 'changeInputHint',
        attributeName: updatedAttributeDefinition.previous.name
      },
      isSearchable: {
        action: 'changeIsSearchable',
        attributeName: updatedAttributeDefinition.previous.name
      },
      attributeConstraint: {
        action: 'changeAttributeConstraint',
        attributeName: updatedAttributeDefinition.previous.name
      }
    });
  }))), _toConsumableArray(addedAttributeDefinitions.map(function (attributeDef) {
    return {
      action: 'addAttributeDefinition',
      attribute: attributeDef.next
    };
  })));
};

var generateUpdateActionsForAttributeEnumValues = function generateUpdateActionsForAttributeEnumValues() {
  var attributeEnumValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var removedAttributeEnumValues = attributeEnumValues.filter(function (attributeEnumValue) {
    return attributeEnumValue.previous && !attributeEnumValue.next;
  });
  var updatedAttributeEnumValues = attributeEnumValues.filter(function (attributeEnumValue) {
    return attributeEnumValue.next && attributeEnumValue.previous;
  });
  var addedAttributeEnumValues = attributeEnumValues.filter(function (attributeEnumValue) {
    return !attributeEnumValue.previous && attributeEnumValue.next;
  });
  return [].concat(_toConsumableArray(Object.values(removedAttributeEnumValues.reduce(function (nextEnumUpdateActions, removedAttributeEnumValue) {
    var removedAttributeEnumValueOfSameAttributeName = nextEnumUpdateActions[removedAttributeEnumValue.hint.attributeName] || {
      keys: [],
      attributeName: removedAttributeEnumValue.hint.attributeName,
      action: 'removeEnumValues'
    };
    return _objectSpread2(_objectSpread2({}, nextEnumUpdateActions), {}, _defineProperty({}, removedAttributeEnumValue.hint.attributeName, _objectSpread2(_objectSpread2({}, removedAttributeEnumValueOfSameAttributeName), {}, {
      keys: [].concat(_toConsumableArray(removedAttributeEnumValueOfSameAttributeName.keys), [removedAttributeEnumValue.previous.key])
    })));
  }, {}))), _toConsumableArray(flatten(updatedAttributeEnumValues.map(function (updatedAttributeEnumValue) {
    var updateActions = generateBaseFieldsUpdateActions(updatedAttributeEnumValue.previous, updatedAttributeEnumValue.next, {
      key: {
        action: 'changeEnumKey',
        attributeName: updatedAttributeEnumValue.hint.attributeName
      }
    });

    if (!deepEqual(updatedAttributeEnumValue.previous.label, updatedAttributeEnumValue.next.label)) {
      if (updatedAttributeEnumValue.hint.isLocalized) {
        return [].concat(_toConsumableArray(updateActions), [{
          action: 'changeLocalizedEnumValueLabel',
          attributeName: updatedAttributeEnumValue.hint.attributeName,
          newValue: updatedAttributeEnumValue.next
        }]);
      }

      return [].concat(_toConsumableArray(updateActions), [{
        action: 'changePlainEnumValueLabel',
        attributeName: updatedAttributeEnumValue.hint.attributeName,
        newValue: updatedAttributeEnumValue.next
      }]);
    }

    return updateActions;
  }))), _toConsumableArray(addedAttributeEnumValues.map(function (addedAttributeEnumValue) {
    return {
      action: addedAttributeEnumValue.hint.isLocalized ? 'addLocalizedEnumValue' : 'addPlainEnumValue',
      attributeName: addedAttributeEnumValue.hint.attributeName,
      value: addedAttributeEnumValue.next
    };
  })));
};

var generateChangeAttributeOrderAction = function generateChangeAttributeOrderAction() {
  var attrsOld = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var attrsNew = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var updateActions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  if (!attrsOld.length || !attrsNew.length) return null;
  var newAttributesOrder = attrsNew.map(function (attribute) {
    return attribute.name;
  });
  var removedAttributeNames = updateActions.filter(function (action) {
    return action.action === 'removeAttributeDefinition';
  }).map(function (action) {
    return action.name;
  });
  var addedAttributeNames = updateActions.filter(function (action) {
    return action.action === 'addAttributeDefinition';
  }).map(function (action) {
    return action.attribute.name;
  }); // changeAttributeOrder action will be sent to CTP API as the last action so we have to
  // calculate how the productType will look like after adding/removing attributes

  var patchedOldAttributesOrder = attrsOld.map(function (attribute) {
    return attribute.name;
  }).filter(function (name) {
    return !removedAttributeNames.includes(name);
  }).concat(addedAttributeNames);
  if (newAttributesOrder.join(',') !== patchedOldAttributesOrder.join(',')) return {
    action: 'changeAttributeOrderByName',
    attributeNames: newAttributesOrder
  };
  return null;
};

var actionsMapForHints = function actionsMapForHints() {
  var nestedValuesChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var ptOld = arguments.length > 1 ? arguments[1] : undefined;
  var ptNew = arguments.length > 2 ? arguments[2] : undefined;
  var updateActions = [].concat(_toConsumableArray(generateUpdateActionsForAttributeDefinitions(nestedValuesChanges.attributeDefinitions)), _toConsumableArray(generateUpdateActionsForAttributeEnumValues(nestedValuesChanges.attributeEnumValues)));
  var changeAttributeOrderAction = generateChangeAttributeOrderAction(ptOld.attributes, ptNew.attributes, updateActions);
  if (changeAttributeOrderAction) updateActions.push(changeAttributeOrderAction);
  return updateActions;
};

function createProductTypeMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, next, previous, options) {
    return flatten([// we support only base fields for the product type,
    // for attributes, applying hints would be recommended
    mapActionGroup('base', function () {
      return actionsMapBase$8(diff, previous, next, syncActionConfig);
    }), actionsMapForHints(options.nestedValuesChanges, previous, next)]);
  };
}

var productTypes = (function (actionGroupList, syncActionConfig) {
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createProductTypeMapActions(mapActionGroup, syncActionConfig);
  var onBeforeApplyingDiff = null;
  var buildActions = createBuildActions(diff, doMapActions, onBeforeApplyingDiff, {
    withHints: true
  });
  return {
    buildActions: buildActions
  };
});

var baseActionsList$7 = [{
  action: 'changeKey',
  key: 'key'
}, {
  action: 'setName',
  key: 'name'
}, {
  action: 'setDescription',
  key: 'description'
}, {
  action: 'changeType',
  key: 'type'
}, {
  action: 'changeInitial',
  key: 'initial'
}, {
  action: 'setTransitions',
  key: 'transitions'
}];
function actionsMapBase$7(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$7,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}
function actionsMapRoles(diff, oldObj, newObj) {
  var _createBuildArrayActi;

  var buildArrayActions = createBuildArrayActions('roles', (_createBuildArrayActi = {}, _defineProperty(_createBuildArrayActi, ADD_ACTIONS, function (newRole) {
    return {
      action: 'addRoles',
      roles: newRole
    };
  }), _defineProperty(_createBuildArrayActi, REMOVE_ACTIONS, function (oldRole) {
    return {
      action: 'removeRoles',
      roles: oldRole
    };
  }), _createBuildArrayActi));
  return buildArrayActions(diff, oldObj, newObj);
}

function groupRoleActions(_ref) {
  var _ref2 = _slicedToArray(_ref, 1),
      actions = _ref2[0];

  var addActionRoles = [];
  var removeActionRoles = [];
  actions.forEach(function (action) {
    if (action.action === 'removeRoles') removeActionRoles.push(action.roles);
    if (action.action === 'addRoles') addActionRoles.push(action.roles);
  });
  return [{
    action: 'removeRoles',
    roles: removeActionRoles
  }, {
    action: 'addRoles',
    roles: addActionRoles
  }].filter(function (action) {
    return action.roles.length;
  });
}

function createStatesMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var baseActions = [];
    var roleActions = [];
    baseActions.push(mapActionGroup('base', function () {
      return actionsMapBase$7(diff, oldObj, newObj, syncActionConfig);
    }));
    roleActions.push(mapActionGroup('roles', function () {
      return actionsMapRoles(diff, oldObj, newObj);
    }));
    return flatten([].concat(baseActions, _toConsumableArray(groupRoleActions(roleActions))));
  };
}

var states = (function (actionGroupList, syncActionConfig) {
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createStatesMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$6 = [{
  action: 'changeKey',
  key: 'key'
}, {
  action: 'changeName',
  key: 'name'
}, {
  action: 'changeDescription',
  key: 'description'
}, {
  action: 'setAddress',
  key: 'address'
}, {
  action: 'setGeoLocation',
  key: 'geoLocation'
}, {
  action: 'setRoles',
  key: 'roles'
}];
function actionsMapBase$6(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$6,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}

function createChannelsMapActions$1(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$6(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, newObj, oldObj);
    }));
    return flatten(allActions);
  };
}

var channels = (function (actionGroupList) {
  var syncActionConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createChannelsMapActions$1(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var REGEX_NUMBER = new RegExp(/^\d+$/);
var REGEX_UNDERSCORE_NUMBER = new RegExp(/^_\d+$/);

var getIsChangedOperation = function getIsChangedOperation(key) {
  return REGEX_NUMBER.test(key);
};

var getIsRemovedOperation = function getIsRemovedOperation(key) {
  return REGEX_UNDERSCORE_NUMBER.test(key);
};

var baseActionsList$5 = [{
  action: 'changeKey',
  key: 'key'
}, {
  action: 'changeName',
  key: 'name'
}, {
  action: 'setDescription',
  key: 'description'
}];
function actionsMapBase$5(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$5,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}

function actionsMapEnums(fieldName, attributeType, attributeDiff, previous, next) {
  var _createBuildArrayActi;

  var addEnumActionName = attributeType === 'Enum' ? 'addEnumValue' : 'addLocalizedEnumValue';
  var changeEnumValueLabelActionName = attributeType === 'Enum' ? 'changeEnumValueLabel' : 'changeLocalizedEnumValueLabel';
  var changeEnumOrderActionName = attributeType === 'Enum' ? 'changeEnumValueOrder' : 'changeLocalizedEnumValueOrder';
  var buildArrayActions = createBuildArrayActions('values', (_createBuildArrayActi = {}, _defineProperty(_createBuildArrayActi, ADD_ACTIONS, function (newEnum) {
    return {
      fieldName: fieldName,
      action: addEnumActionName,
      value: newEnum
    };
  }), _defineProperty(_createBuildArrayActi, CHANGE_ACTIONS, function (oldEnum, newEnum) {
    var oldEnumInNext = next.values.find(function (nextEnum) {
      return nextEnum.key === oldEnum.key;
    }); // These `changeActions` would impose a nested structure among
    // the accumulated `updateActions` generated by `buildArrayActions`
    // In the end; we have to flatten the structure before we pass it back
    // to the client.

    var changeActions = [];

    if (oldEnumInNext) {
      // If the enum value is changed, we need to change the order first
      var isKeyChanged = oldEnum.key !== newEnum.key; // check if the label is changed

      var foundPreviousEnum = previous.values.find(function (previousEnum) {
        return previousEnum.key === newEnum.key;
      });
      var isLabelEqual = isEqual(foundPreviousEnum.label, newEnum.label);

      if (isKeyChanged) {
        // these actions is then flatten in the end
        changeActions.push({
          fieldName: fieldName,
          action: changeEnumOrderActionName,
          value: newEnum
        });
      }

      if (!isLabelEqual) {
        changeActions.push({
          fieldName: fieldName,
          action: changeEnumValueLabelActionName,
          value: newEnum
        });
      }
    } else {
      changeActions.push({
        fieldName: fieldName,
        action: addEnumActionName,
        value: newEnum
      });
    }

    return changeActions;
  }), _createBuildArrayActi));
  var actions = []; // following lists are necessary to ensure that when we change the
  // order of enumValues, we generate one updateAction instead of one at a time.

  var newEnumValuesOrder = [];
  flatten(buildArrayActions(attributeDiff, previous, next)).forEach(function (updateAction) {
    if (updateAction.action === changeEnumOrderActionName) {
      newEnumValuesOrder = next.values.map(function (enumValue) {
        return enumValue.key;
      });
    } else actions.push(updateAction);
  });
  return [].concat(actions, _toConsumableArray(newEnumValuesOrder.length > 0 ? [{
    fieldName: fieldName,
    action: changeEnumOrderActionName,
    keys: newEnumValuesOrder
  }] : []));
}

function actionsMapFieldDefinitions(fieldDefinitionsDiff, previous, next, diffPaths) {
  var actions = [];
  forEach(fieldDefinitionsDiff, function (diffValue, diffKey) {
    var extractedPairs = extractMatchingPairs(diffPaths, diffKey, previous, next);

    if (getIsChangedOperation(diffKey)) {
      var _diffValue$type;

      if (Array.isArray(diffValue)) {
        var deltaValue = getDeltaValue(diffValue);

        if (deltaValue.name) {
          actions.push({
            action: 'addFieldDefinition',
            fieldDefinition: deltaValue
          });
        }
      } else if (diffValue.label) {
        actions.push({
          action: 'changeLabel',
          label: extractedPairs.newObj.label,
          fieldName: extractedPairs.oldObj.name
        });
      } else if (diffValue.inputHint) {
        actions.push({
          action: 'changeInputHint',
          inputHint: extractedPairs.newObj.inputHint,
          fieldName: extractedPairs.oldObj.name
        });
      } else if (diffValue !== null && diffValue !== void 0 && (_diffValue$type = diffValue.type) !== null && _diffValue$type !== void 0 && _diffValue$type.values) {
        actions.push.apply(actions, _toConsumableArray(actionsMapEnums(extractedPairs.oldObj.name, extractedPairs.oldObj.type.name, diffValue.type, extractedPairs.oldObj.type, extractedPairs.newObj.type)));
      }
    } else if (getIsRemovedOperation(diffKey)) {
      if (Array.isArray(diffValue)) {
        if (diffValue.length === 3 && diffValue[2] === 3) {
          actions.push({
            action: 'changeFieldDefinitionOrder',
            fieldNames: next.map(function (n) {
              return n.name;
            })
          });
        } else {
          var _deltaValue = getDeltaValue(diffValue);

          if (_deltaValue === undefined && diffValue[0].name) actions.push({
            action: 'removeFieldDefinition',
            fieldName: diffValue[0].name
          });
        }
      }
    }
  }); // Make sure to execute removeActions before creating new ones
  // in order to prevent any eventual removal of `addAction`.
  // List of `removeActions` can be found here
  // https://docs.commercetools.com/http-api-projects-types.html#change-key

  var sortedActions = sortBy(actions, function (action) {
    return action.action !== 'removeFieldDefinition';
  });
  return sortedActions;
}

function createTypeMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, next, previous) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$5(diff, previous, next, syncActionConfig);
    }), mapActionGroup('fieldDefinitions', function () {
      return actionsMapFieldDefinitions(diff.fieldDefinitions, previous.fieldDefinitions, next.fieldDefinitions, findMatchingPairs(diff.fieldDefinitions, previous.fieldDefinitions, next.fieldDefinitions, 'name'));
    }));
    return flatten(allActions);
  };
}

var types = (function (actionGroupList, syncActionConfig) {
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createTypeMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$4 = [{
  action: 'changeName',
  key: 'name'
}, {
  action: 'changeCurrencies',
  key: 'currencies'
}, {
  action: 'changeCountries',
  key: 'countries'
}, {
  action: 'changeLanguages',
  key: 'languages'
}, {
  action: 'changeMessagesConfiguration',
  key: 'messagesConfiguration'
}, {
  action: 'setShippingRateInputType',
  key: 'shippingRateInputType'
}];
function actionsMapBase$4(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$4,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}

function createChannelsMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$4(diff, oldObj, newObj, syncActionConfig);
    }));
    return flatten(allActions);
  };
}

var projects = (function (actionGroupList) {
  var syncActionConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createChannelsMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$3 = [{
  action: 'setName',
  key: 'name'
}, {
  action: 'setLanguages',
  key: 'languages'
}, {
  action: 'setDistributionChannels',
  key: 'distributionChannels'
}, {
  action: 'setSupplyChannels',
  key: 'supplyChannels'
}];
function actionsMapBase$3(diff, oldObj, newObj) {
  return buildBaseAttributesActions({
    actions: baseActionsList$3,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj
  });
}

function createStoresMapActions(mapActionGroup) {
  return function doMapActions(diff, next, previous) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$3(diff, previous, next);
    }));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, next, previous);
    }));
    return flatten(allActions);
  };
}

var stores = (function (actionGroupList) {
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createStoresMapActions(mapActionGroup);
  var onBeforeApplyingDiff = null;
  var buildActions = createBuildActions(diff, doMapActions, onBeforeApplyingDiff);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$2 = [{
  action: 'changeName',
  key: 'name'
}, {
  action: 'setKey',
  key: 'key'
}];
function actionsMapBase$2(diff, oldObj, newObj) {
  return buildBaseAttributesActions({
    actions: baseActionsList$2,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj
  });
}

function createProductSelectionsMapActions(mapActionGroup) {
  return function doMapActions(diff, next, previous) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase$2(diff, previous, next);
    }));
    allActions.push(mapActionGroup('custom', function () {
      return actionsMapCustom(diff, next, previous);
    }));
    return flatten(allActions);
  };
}

var productSelections = (function (actionGroupList) {
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createProductSelectionsMapActions(mapActionGroup);
  var onBeforeApplyingDiff = null;
  var buildActions = createBuildActions(diff, doMapActions, onBeforeApplyingDiff);
  return {
    buildActions: buildActions
  };
});

var baseActionsList$1 = [{
  action: 'changeValue',
  key: 'value'
}, {
  action: 'setDiscountedPrice',
  key: 'discounted'
}, // TODO: Later add more accurate actions `addPriceTier`, `removePriceTier`
{
  action: 'setPriceTiers',
  key: 'tiers'
}, {
  action: 'setKey',
  key: 'key'
}, {
  action: 'setValidFrom',
  key: 'validFrom'
}, {
  action: 'setValidUntil',
  key: 'validUntil'
}, {
  action: 'changeActive',
  key: 'active'
}];
function actionsMapBase$1(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList$1,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}

function createPriceMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var baseActions = mapActionGroup('base', function () {
      return actionsMapBase$1(diff, oldObj, newObj, syncActionConfig);
    });
    var customActions = mapActionGroup('custom', function () {
      return actionsMapCustom(diff, newObj, oldObj);
    });
    return combineValidityActions([].concat(_toConsumableArray(baseActions), _toConsumableArray(customActions)));
  };
}

var prices = (function (actionGroupList, syncActionConfig) {
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createPriceMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

var hasAttribute = function hasAttribute(attributes, newValue) {
  return attributes.some(function (attribute) {
    return attribute.key === newValue.key;
  });
};

var baseActionsList = [{
  action: 'changeName',
  key: 'name'
}, {
  action: 'setKey',
  key: 'key'
}, {
  action: 'setDescription',
  key: 'description'
}];
function actionsMapBase(diff, oldObj, newObj) {
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return buildBaseAttributesActions({
    actions: baseActionsList,
    diff: diff,
    oldObj: oldObj,
    newObj: newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString
  });
}
function actionsMapAttributes(diff, oldObj, newObj) {
  var _createBuildArrayActi;

  var handler = createBuildArrayActions('attributes', (_createBuildArrayActi = {}, _defineProperty(_createBuildArrayActi, ADD_ACTIONS, function (newAttribute) {
    return {
      action: 'addAttribute',
      attribute: newAttribute
    };
  }), _defineProperty(_createBuildArrayActi, REMOVE_ACTIONS, function (oldAttribute) {
    // We only add the action if the attribute is not included in the new object.
    return !hasAttribute(newObj.attributes, oldAttribute) ? {
      action: 'removeAttribute',
      attribute: oldAttribute
    } : null;
  }), _defineProperty(_createBuildArrayActi, CHANGE_ACTIONS, function (oldAttribute, newAttribute) {
    var result = []; // We only remove the attribute in case that the oldAttribute is not
    // included in the new object

    if (!hasAttribute(newObj.attributes, oldAttribute)) result.push({
      action: 'removeAttribute',
      attribute: oldAttribute
    }); // We only add the attribute in case that the newAttribute was not
    // included in the old object

    if (!hasAttribute(oldObj.attributes, newAttribute)) result.push({
      action: 'addAttribute',
      attribute: newAttribute
    });
    return result;
  }), _createBuildArrayActi));
  return handler(diff, oldObj, newObj);
}

function createAttributeGroupsMapActions(mapActionGroup, syncActionConfig) {
  return function doMapActions(diff, newObj, oldObj) {
    var allActions = [];
    allActions.push(mapActionGroup('base', function () {
      return actionsMapBase(diff, oldObj, newObj, syncActionConfig);
    }));
    allActions.push(flatten(mapActionGroup('attributes', function () {
      return actionsMapAttributes(diff, oldObj, newObj);
    })));
    return flatten(allActions);
  };
}

var attributeGroups = (function (actionGroupList, syncActionConfig) {
  var mapActionGroup = createMapActionGroup(actionGroupList);
  var doMapActions = createAttributeGroupsMapActions(mapActionGroup, syncActionConfig);
  var buildActions = createBuildActions(diff, doMapActions);
  return {
    buildActions: buildActions
  };
});

export { attributeGroups as createSyncAttributeGroups, cartDiscounts as createSyncCartDiscounts, categories as createSyncCategories, channels as createSyncChannels, customerGroup as createSyncCustomerGroup, customers as createSyncCustomers, discountCodes as createSyncDiscountCodes, inventories as createSyncInventories, orders as createSyncOrders, productDiscounts as createSyncProductDiscounts, productSelections as createSyncProductSelections, productTypes as createSyncProductTypes, products as createSyncProducts, projects as createSyncProjects, shippingMethods as createSyncShippingMethods, prices as createSyncStandalonePrices, states as createSyncStates, stores as createSyncStores, taxCategories as createSyncTaxCategories, types as createSyncTypes, zones as createSyncZones };
