(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('querystring')) :
  typeof define === 'function' && define.amd ? define(['exports', 'querystring'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.CommercetoolsSdkClient = {}, global.qs));
})(this, (function (exports, qs) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var qs__default = /*#__PURE__*/_interopDefaultLegacy(qs);

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var METHODS = ['ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE', 'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE'];

  function validate(funcName, request) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      allowedMethods: METHODS
    };
    if (!request) // eslint-disable-next-line max-len
      throw new Error("The \"".concat(funcName, "\" function requires a \"Request\" object as an argument. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest"));
    if (typeof request.uri !== 'string') // eslint-disable-next-line max-len
      throw new Error("The \"".concat(funcName, "\" Request object requires a valid uri. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest"));
    if (!options.allowedMethods.includes(request.method)) // eslint-disable-next-line max-len
      throw new Error("The \"".concat(funcName, "\" Request object requires a valid method. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest"));
  }

  function compose() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }

    // eslint-disable-next-line no-param-reassign
    funcs = funcs.filter(function (func) {
      return typeof func === 'function';
    });
    if (funcs.length === 1) return funcs[0];
    return funcs.reduce(function (a, b) {
      return function () {
        return a(b.apply(void 0, arguments));
      };
    });
  }

  function createClient(options) {
    if (!options) throw new Error('Missing required options');
    if (options.middlewares && !Array.isArray(options.middlewares)) throw new Error('Middlewares should be an array');
    if (!options.middlewares || !Array.isArray(options.middlewares) || !options.middlewares.length) throw new Error('You need to provide at least one middleware');
    return {
      /*
        Given a request object,
      */
      execute: function execute(request) {
        validate('exec', request);
        return new Promise(function (resolve, reject) {
          var resolver = function resolver(rq, rs) {
            // Note: pick the promise `resolve` and `reject` function from
            // the response object. This is not necessary the same function
            // given from the `new Promise` constructor, as middlewares could
            // override those functions for custom behaviours.
            if (rs.error) rs.reject(rs.error);else {
              var resObj = {
                body: rs.body || {},
                statusCode: rs.statusCode
              };
              if (rs.headers) resObj.headers = rs.headers;
              if (rs.request) resObj.request = rs.request;
              rs.resolve(resObj);
            }
          };

          var dispatch = compose.apply(void 0, _toConsumableArray(options.middlewares))(resolver);
          dispatch(request, // Initial response shape
          {
            resolve: resolve,
            reject: reject,
            body: undefined,
            error: undefined
          });
        });
      },
      process: function process(request, fn, processOpt) {
        var _this = this;

        validate('process', request, {
          allowedMethods: ['GET']
        });
        if (typeof fn !== 'function') // eslint-disable-next-line max-len
          throw new Error('The "process" function accepts a "Function" as a second argument that returns a Promise. See https://commercetools.github.io/nodejs/sdk/api/sdkClient.html#processrequest-processfn-options'); // Set default process options

        var opt = _objectSpread2({
          total: Number.POSITIVE_INFINITY,
          accumulate: true
        }, processOpt);

        return new Promise(function (resolve, reject) {
          var _request$uri$split = request.uri.split('?'),
              _request$uri$split2 = _slicedToArray(_request$uri$split, 2),
              path = _request$uri$split2[0],
              queryString = _request$uri$split2[1];

          var requestQuery = _objectSpread2({}, qs__default["default"].parse(queryString));

          var query = _objectSpread2({
            // defaults
            limit: 20
          }, requestQuery);

          var hasFirstPageBeenProcessed = false;
          var itemsToGet = opt.total;

          var processPage = function processPage(lastId) {
            var acc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            // Use the lesser value between limit and itemsToGet in query
            var limit = query.limit < itemsToGet ? query.limit : itemsToGet;
            var originalQueryString = qs__default["default"].stringify(_objectSpread2(_objectSpread2({}, query), {}, {
              limit: limit
            }));

            var enhancedQuery = _objectSpread2({
              sort: 'id asc',
              withTotal: false
            }, lastId ? {
              where: "id > \"".concat(lastId, "\"")
            } : {});

            var enhancedQueryString = qs__default["default"].stringify(enhancedQuery);

            var enhancedRequest = _objectSpread2(_objectSpread2({}, request), {}, {
              uri: "".concat(path, "?").concat(enhancedQueryString, "&").concat(originalQueryString)
            });

            _this.execute(enhancedRequest).then(function (payload) {
              var _payload$body = payload.body,
                  results = _payload$body.results,
                  resultsLength = _payload$body.count;

              if (!resultsLength && hasFirstPageBeenProcessed) {
                resolve(acc || []);
                return;
              }

              Promise.resolve(fn(payload)).then(function (result) {
                hasFirstPageBeenProcessed = true;
                var accumulated;
                if (opt.accumulate) accumulated = acc.concat(result || []);
                itemsToGet -= resultsLength; // If there are no more items to get, it means the total number
                // of items in the original request have been fetched so we
                // resolve the promise.
                // Also, if we get less results in a page then the limit set it
                // means that there are no more pages and that we can finally
                // resolve the promise.

                if (resultsLength < query.limit || !itemsToGet) {
                  resolve(accumulated || []);
                  return;
                }

                var last = results[resultsLength - 1];
                var newLastId = last && last.id;
                processPage(newLastId, accumulated);
              }).catch(reject);
            }).catch(reject);
          }; // Start iterating through pages


          processPage();
        });
      }
    };
  }

  exports.createClient = createClient;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
