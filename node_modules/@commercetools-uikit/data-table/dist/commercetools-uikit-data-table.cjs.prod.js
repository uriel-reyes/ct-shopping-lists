'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
require('prop-types');
var _reduceInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/reduce');
var _mapInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/map');
var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var react$1 = require('react');
var isEqual = require('lodash/isEqual');
var utils = require('@commercetools-uikit/utils');
var hooks = require('@commercetools-uikit/hooks');
var _styled = require('@emotion/styled/base');
var react = require('@emotion/react');
var designSystem = require('@commercetools-uikit/design-system');
var AccessibleButton = require('@commercetools-uikit/accessible-button');
var _taggedTemplateLiteral = require('@babel/runtime-corejs3/helpers/taggedTemplateLiteral');
var icons = require('@commercetools-uikit/icons');
var jsxRuntime = require('@emotion/react/jsx-runtime');
var _Number$isNaN = require('@babel/runtime-corejs3/core-js-stable/number/is-nan');
var _parseInt = require('@babel/runtime-corejs3/core-js-stable/parse-int');
var _slicedToArray = require('@babel/runtime-corejs3/helpers/slicedToArray');
var _someInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/some');
var _concatInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/concat');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _reduceInstanceProperty__default = /*#__PURE__*/_interopDefault(_reduceInstanceProperty);
var _mapInstanceProperty__default = /*#__PURE__*/_interopDefault(_mapInstanceProperty);
var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var isEqual__default = /*#__PURE__*/_interopDefault(isEqual);
var _styled__default = /*#__PURE__*/_interopDefault(_styled);
var AccessibleButton__default = /*#__PURE__*/_interopDefault(AccessibleButton);
var _Number$isNaN__default = /*#__PURE__*/_interopDefault(_Number$isNaN);
var _parseInt__default = /*#__PURE__*/_interopDefault(_parseInt);
var _someInstanceProperty__default = /*#__PURE__*/_interopDefault(_someInstanceProperty);
var _concatInstanceProperty__default = /*#__PURE__*/_interopDefault(_concatInstanceProperty);

const getPaddingStyle = props => {
  if (props.isCondensed) return /*#__PURE__*/react.css("padding:", designSystem.designTokens.paddingForTableCellAsCondensed, ";" + ("" ), "" );
  return /*#__PURE__*/react.css("padding:", designSystem.designTokens.paddingForTableCell, ";" + ("" ), "" );
};
var _ref8 = {
  name: "9nkbgg",
  styles: "text-align:left;justify-self:flex-start"
} ;
var _ref9 = {
  name: "1p06wbt",
  styles: "text-align:right;justify-self:flex-end"
} ;
var _ref10 = {
  name: "weshh4",
  styles: "text-align:center;justify-self:center"
} ;
const getHorizontalAlignmentStyle = props => {
  if (props.horizontalCellAlignment === 'center') {
    return _ref10;
  }
  if (props.horizontalCellAlignment === 'right') {
    return _ref9;
  }
  return _ref8;
};
var _ref5 = {
  name: "xyzkeb",
  styles: "align-self:flex-start"
} ;
var _ref6 = {
  name: "1duj7gx",
  styles: "align-self:flex-end"
} ;
var _ref7 = {
  name: "qbt5ty",
  styles: "align-self:center"
} ;
const getVerticalAlignmentStyle = props => {
  if (props.verticalCellAlignment === 'center') {
    return _ref7;
  }
  if (props.verticalCellAlignment === 'bottom') {
    return _ref6;
  }
  return _ref5;
};
var _ref4 = {
  name: "ucb1au",
  styles: "overflow:hidden;white-space:nowrap;text-overflow:ellipsis"
} ;
const getTruncatedStyle = props => {
  if (props.isTruncated) {
    return _ref4;
  }
  return '';
};

/* the :focus-within state doesn't enable the outline styles,
  so we have to set them manually. */
const outlineStyles = {
  name: "1oudntj",
  styles: "outline-offset:-3px;:not(:focus):focus-within{outline-style:auto;outline-color:Highlight;outline-color:activeborder;outline-color:-moz-mac-focusring;outline-color:-webkit-focus-ring-color;}"
} ;
const getCellInnerStyles = props => {
  return [getVerticalAlignmentStyle(props), getHorizontalAlignmentStyle(props), getTruncatedStyle(props), outlineStyles];
};

/**
 * The `shouldClipContent` overflow rule should only be enabled upon manual column resizing,
 * otherwise it will change the way css-grid automatically allocates space for the cells of the table,
 * preferring to clip the cells instead and adding horizontal scrollbar to the table container
 */
var _ref3 = {
  name: "d3v9zr",
  styles: "overflow:hidden"
} ;
const CellInner = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e10u1n7e3"
} )("box-sizing:border-box;flex:1;", getPaddingStyle, " ", getCellInnerStyles, " ", props => props.shouldClipContent ? _ref3 : '', ";" + ("" ));
var _ref$1 = {
  name: "1a5erbp",
  styles: "cursor:auto"
} ;
var _ref2 = {
  name: "d3v9zr",
  styles: "overflow:hidden"
} ;
const BaseCell = /*#__PURE__*/_styled__default["default"]("td", {
  target: "e10u1n7e2"
} )("position:relative;display:flex;background-color:", designSystem.designTokens.colorSurface, ";border-bottom:", props => props.shouldRenderBottomBorder ? "1px solid ".concat(designSystem.designTokens.colorNeutral95, ";") : 'none', ";font-size:", designSystem.designTokens.fontSizeForTable, ";", props => props.shouldClipContent ? _ref2 : '', " ", props => props.shouldIgnoreRowClick ? _ref$1 : '', ";" + ("" ));
/*#__PURE__*/_styled__default["default"]("td", {
  target: "e10u1n7e1"
} )("position:", props => props.disableFooterStickiness ? 'relative' : 'sticky', ";left:0;bottom:0;grid-column:1/", props => props.numberOfColumns, ";background-color:", designSystem.designTokens.colorSurface, ";border-bottom:1px solid ", designSystem.designTokens.colorNeutral90, ";border-top:1px solid ", designSystem.designTokens.colorNeutral90, ";margin-top:-1px;" + ("" ));
const RowExpandCollapseButton = /*#__PURE__*/_styled__default["default"](AccessibleButton__default["default"], {
  target: "e10u1n7e0"
} )("cursor:", props => props.isRowCollapsed ? /*#__PURE__*/react.css("" , "" ) : /*#__PURE__*/react.css("" , "" ), ";position:absolute;height:16px;width:16px;bottom:0;right:0;opacity:0;display:flex;justify-content:flex-end;align-items:flex-end;" + ("" ));

var _templateObject, _templateObject2, _templateObject3;
const getButtonStyle = () => /*#__PURE__*/react.css("cursor:pointer;border:none;background:none;text-decoration:none;color:inherit;font:inherit;font-size:", designSystem.designTokens.fontSize10, ";font-family:inherit;" + ("" ), "" );

/* When a sortable header is deselected,
 *  (i.e. when another sortable header is selected)
 *  the AngleUpDown is animated with fadeIn
 *
 *  When the user hovers over a sortable header that
 *  is not the active sorted column, the icon for
 *  the current sort direction is animated with fadeIn
 */
const fadeIn = react.keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n"])));

/* When a sortable header is activated/selected,
 *  and the sort direction is 'desc', the ArrowDown
 *  icon is animated with rotateClockwise
 */
const rotateClockwise = react.keyframes(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  from {\n    transform: rotate(-180deg);\n  } to {\n    transform: rotate(0deg);\n  }\n"])));

/* When a sortable header is activated/selected,
 *  and the sort direction is 'asc', the ArrowUp
 *  icon is animated with rotateCounterClockwise
 */
const rotateCounterClockwise = react.keyframes(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n  from {\n    transform: rotate(180deg);\n  } to {\n    transform: rotate(0deg);\n  }\n"])));

/* A sortable header has the two arrow svg icons
 * GIVEN column is sortable and is not focused
 * THEN AngleUpDown icon is shown (default behaviour)
 * AND ArrowUp or ArrowDown icon is not shown
 *
 * GIVEN column is sortable and foucsed or hovered
 * THEN AngleUpDown icon is hidden
 * AND ArrowUp or ArrowDown icon is shown
 */

const getSortableHeaderStyles = props => /*#__PURE__*/react.css("width:100%;display:flex;align-items:center;svg[data-icon-state='inactive'],svg[data-icon-state='active']{margin-left:", designSystem.designTokens.spacing10, ";flex-shrink:0;}svg[data-icon-state='inactive']{display:", props.isActive ? 'none' : 'inline-block', ";animation:", fadeIn, " 150ms ease-in-out;}svg[data-icon-state='active']{display:", props.isActive ? 'inline-block' : 'none', ";animation:", props.isActive && /*#__PURE__*/react.css(props.label === 'asc' ? rotateCounterClockwise : rotateClockwise, " 150ms ease-in-out;" + ("" ), "" ), ";}>svg *{fill:", designSystem.designTokens.colorNeutral60, "!important;}:hover,:focus{svg[data-icon-state='inactive']{display:none;}svg[data-icon-state='active']{display:inline-block;animation:", !props.isActive && /*#__PURE__*/react.css(fadeIn, " 150ms ease-in-out;" + ("" ), "" ), ";}}" + ("" ), "" );
const HeaderCellInner = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e1ipt8n24"
} )("box-sizing:border-box;display:flex;justify-content:flex-start;padding:0 ", props => props.isCondensed ? designSystem.designTokens.paddingForTableHeaderAsCondensed : designSystem.designTokens.paddingForTableHeader, ";", getCellInnerStyles, " ", props => props.isSortable ? getSortableHeaderStyles(props) : '', ";", props => props.as === 'button' ? getButtonStyle() : '', ";", props => props.shouldWrap ? '' : 'white-space: nowrap', ";" + ("" ));
const BaseHeaderCell = /*#__PURE__*/_styled__default["default"]("th", {
  target: "e1ipt8n23"
} )("color:", designSystem.designTokens.colorNeutral40, ";background-color:", designSystem.designTokens.colorNeutral98, ";position:", props => props.disableHeaderStickiness ? 'relative' : 'sticky', ";top:0;z-index:1;line-height:", designSystem.designTokens.lineHeightForTableHeader, ";padding:0;font-weight:", designSystem.designTokens.fontWeight500, ";font-size:", designSystem.designTokens.fontSize10, ";:after{content:'';position:absolute;z-index:-1;width:100%;height:", designSystem.designTokens.borderWidth1, ";bottom:0;left:0;background-color:", designSystem.designTokens.colorNeutral95, ";}:hover,:active{z-index:2;}", HeaderCellInner, "{", props => props.shouldClipContent ? 'overflow: hidden;' : '', ";}" + ("" ));
const HeaderLabelWrapper = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e1ipt8n22"
} )("display:inline-flex;min-height:1.4em;margin:", designSystem.designTokens.marginForTableHeader, " 0;flex:0 0 fit-content;" + ("" ));
const HeaderLabelTextWrapper = /*#__PURE__*/_styled__default["default"]("span", {
  target: "e1ipt8n21"
} )({
  name: "1onapuj",
  styles: "display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;overflow-wrap:anywhere"
} );
const HeaderIconWrapper = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e1ipt8n20"
} )("display:inline-flex;align-items:center;justify-content:center;margin-left:", designSystem.designTokens.spacing20, ";vertical-align:middle;" + ("" ));

const convertNumericDimensionToPixelValue = dimensionValue => typeof dimensionValue === 'number' ? "".concat(dimensionValue, "px") : dimensionValue;
var convertNumericDimensionToPixelValue$1 = convertNumericDimensionToPixelValue;

const getClickableRowStyle = props => {
  if (props.isRowClickable) {
    return /*#__PURE__*/react.css("cursor:pointer;&:hover td{background:", designSystem.designTokens.backgroundColorForTableCellWhenHovered, ";}" + ("" ), "" );
  }
  return '';
};
var _ref = {
  name: "1jff5cf",
  styles: "position:unset;overflow-x:unset;overflow-y:unset"
} ;
const getDisabledSelfContainmentStyles = props => {
  if (props.disableSelfContainment) {
    return _ref;
  }
  return '';
};
const TableContainer = /*#__PURE__*/_styled__default["default"]("div", {
  target: "epk01s24"
} )("position:relative;z-index:0;box-shadow:", designSystem.designTokens.boxShadowForTable, ";border:1px solid ", designSystem.designTokens.colorNeutral95, ";border-radius:", designSystem.designTokens.borderRadius4, ";", props =>
// this is needed in order to have a sticky header
props.maxHeight ? "overflow-x: auto;" : '', " ", props => props.maxWidth && !props.disableSelfContainment ? "max-width: ".concat(convertNumericDimensionToPixelValue$1(props.maxWidth), ";") : '', " ", props => props.isBeingResized && "\n    * {\n      user-select: none;\n    }", " ", getDisabledSelfContainmentStyles, ";" + ("" ));
const TableGrid = /*#__PURE__*/_styled__default["default"]("table", {
  target: "epk01s23"
} )("display:grid;grid-template-columns:", props => {
  var _context;
  return props.columns && _mapInstanceProperty__default["default"](_context = props.columns).call(_context, column => column.width || 'auto').join(' ');
}, ";", props =>
// this is needed in order to have a sticky header
props.maxHeight ? "overflow-y: auto;" : '', " ", props => props.maxHeight && !props.disableSelfContainment ? "max-height: ".concat(convertNumericDimensionToPixelValue$1(props.maxHeight), ";") : '', " ", props => props.resizedTotalWidth ? "max-width: ".concat(props.resizedTotalWidth, "px;") : '', " ", getDisabledSelfContainmentStyles, ";" + ("" ));
const TableHeader = /*#__PURE__*/_styled__default["default"]("thead", {
  target: "epk01s22"
} )("display:contents;:hover{", BaseHeaderCell, ":before{content:'';position:absolute;border-right:1px solid ", designSystem.designTokens.colorNeutral, ";top:", designSystem.designTokens.spacing20, ";right:0;bottom:", designSystem.designTokens.spacing20, ";}", BaseHeaderCell, ":last-child:before{display:none;}}" + ("" ));
const TableBody = /*#__PURE__*/_styled__default["default"]("tbody", {
  target: "epk01s21"
} )({
  name: "49aokf",
  styles: "display:contents"
} );
const TableRow = /*#__PURE__*/_styled__default["default"]("tr", {
  target: "epk01s20"
} )("display:contents;", getClickableRowStyle, " :hover,:focus-within{", RowExpandCollapseButton, "{opacity:1;}}" + ("" ));

const defaultProps$4 = {
  horizontalCellAlignment: 'left'
};
const Footer = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e2ce7vj0"
} )("box-sizing:border-box;display:block;", getPaddingStyle, " ", getHorizontalAlignmentStyle, " background-color:", designSystem.designTokens.colorSurface, ";border-top:1px solid ", designSystem.designTokens.colorNeutral90, ";border-bottom:1px solid ", designSystem.designTokens.colorNeutral90, ";", props => props.resizedTotalWidth ? "max-width: ".concat(props.resizedTotalWidth, "px;") : '', ";" + ("" ));
Footer.displayName = 'Footer';
Footer.defaultProps = defaultProps$4;
var Footer$1 = Footer;

const ResizerIndicator = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e1ccic7f1"
} )("height:100%;width:3px;background:", designSystem.designTokens.colorInfo, ";visibility:hidden;cursor:col-resize;", (props // extra 1px of height to appear above the bottom horizontal row border
) => props.isOnDataCell ? 'visibility: visible; height: calc(100% + 1px);' : '', ";" + ("" ));
const DraggableArea = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e1ccic7f0"
} )("display:flex;justify-content:flex-end;height:100%;position:absolute;top:0;right:0;width:6px;cursor:col-resize;user-select:none;&:hover ", ResizerIndicator, "{height:100%;visibility:visible;}&:active{width:20px;right:-10px;", ResizerIndicator, "{margin-right:10px;visibility:visible;}}" + ("" ));
const ColumnResizer = props => jsxRuntime.jsx(DraggableArea, {
  role: "presentation",
  onMouseDown: props.onMouseDown,
  children: jsxRuntime.jsx(ResizerIndicator, {
    isOnDataCell: props.isOnDataCell
  })
});
ColumnResizer.propTypes = {};
ColumnResizer.displayName = 'ColumnResizer';
var Resizer = ColumnResizer;

var ColumnResizingContext = /*#__PURE__*/react$1.createContext({});

const isFixedWidthValue = value => {
  return !_Number$isNaN__default["default"](_parseInt__default["default"](String(value), 10));
};
var isFixedWidthValue$1 = isFixedWidthValue;

function ownKeys$3(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys$3(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys$3(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const HeaderCellWrapper = props => {
  var _headerRef$current2;
  const columnResizingReducer = react$1.useContext(ColumnResizingContext);
  const headerRef = react$1.useRef(null);
  const onStartResizing = event => {
    columnResizingReducer.startResizing(headerRef, event);
  };
  const onDrag = event => {
    var _headerRef$current;
    return columnResizingReducer.onDragResizing(event, (_headerRef$current = headerRef.current) === null || _headerRef$current === void 0 ? void 0 : _headerRef$current.cellIndex);
  };
  const onDragEnd = () => {
    const finalSizes = columnResizingReducer.finishResizing();
    if (props.onColumnResized) {
      props.onColumnResized(finalSizes);
    }
    window.removeEventListener('mousemove', onDrag);
    window.removeEventListener('mouseup', onDragEnd);
  };
  if (columnResizingReducer.getIsColumnBeingResized((_headerRef$current2 = headerRef.current) === null || _headerRef$current2 === void 0 ? void 0 : _headerRef$current2.cellIndex)) {
    window.addEventListener('mousemove', onDrag);
    window.addEventListener('mouseup', onDragEnd);
  }
  /**
   * GIVEN that any table column is being OR has been resized
   * OR the width of the current column is a fixed value
   * THEN the header content should be clipped
   */
  const shouldClipContent = props.columnWidth && isFixedWidthValue$1(props.columnWidth) || columnResizingReducer.getHasTableBeenResized() || columnResizingReducer.getIsAnyColumnBeingResized();
  return jsxRuntime.jsxs(BaseHeaderCell, {
    ref: headerRef,
    "data-testid": "header-".concat(props.columnKey),
    "data-id": props.columnKey,
    shouldClipContent: shouldClipContent,
    disableHeaderStickiness: props.disableHeaderStickiness,
    children: [props.children, !props.disableResizing && jsxRuntime.jsx(Resizer, {
      onMouseDown: onStartResizing
    })]
  });
};
HeaderCellWrapper.displayName = 'HeaderCellWrapper';
const defaultProps$3 = {
  sortDirection: 'desc',
  disableHeaderStickiness: false,
  horizontalCellAlignment: 'left'
};
const HeaderCell = props => {
  let sortableHeaderProps = {};
  let SortingIcon;
  if (props.isSortable) {
    const isActive = props.sortedBy === props.columnKey;
    const nextSortDirection = !isActive || props.sortDirection === 'desc' ? 'asc' : 'desc';
    SortingIcon = props.sortDirection === 'desc' ? icons.ArrowDownIcon : icons.ArrowUpIcon;
    sortableHeaderProps = {
      as: 'button',
      label: props.sortDirection,
      onClick: () => props.onClick && props.onClick(props.columnKey, nextSortDirection),
      isActive,
      isSortable: true
    };
  }
  return jsxRuntime.jsx(HeaderCellWrapper, {
    columnWidth: props.columnWidth,
    columnKey: props.columnKey,
    onColumnResized: props.onColumnResized,
    disableResizing: props.disableResizing,
    disableHeaderStickiness: props.disableHeaderStickiness,
    children: jsxRuntime.jsxs(HeaderCellInner, _objectSpread$3(_objectSpread$3({
      shouldWrap: props.shouldWrap,
      isCondensed: props.isCondensed,
      horizontalCellAlignment: props.horizontalCellAlignment
    }, sortableHeaderProps), {}, {
      children: [jsxRuntime.jsxs(HeaderLabelWrapper, {
        children: [jsxRuntime.jsx(HeaderLabelTextWrapper, {
          children: props.children
        }), props.iconComponent && jsxRuntime.jsx(HeaderIconWrapper, {
          children: props.iconComponent
        })]
      }), props.isSortable && jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [jsxRuntime.jsx(icons.AngleUpDownIcon, {
          size: "medium",
          color: "surface",
          "data-icon-state": "inactive"
        }), jsxRuntime.jsx(SortingIcon, {
          size: "medium",
          color: "surface",
          "data-icon-state": "active"
        })]
      })]
    }))
  });
};
HeaderCell.propTypes = {};
HeaderCell.displayName = 'HeaderCell';
HeaderCell.defaultProps = defaultProps$3;
var HeaderCell$1 = HeaderCell;

function ownKeys$2(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys$2(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys$2(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const defaultProps$2 = {
  isTruncated: false,
  shouldRenderBottomBorder: true
};
const DataCell = props => {
  if (props.shouldRenderCollapseButton) ;
  const Icon = props.isRowCollapsed ? icons.RightTriangleFilledIcon : icons.RightTriangleLinearIcon;
  return jsxRuntime.jsxs(BaseCell, {
    onClick: props.onCellClick,
    shouldIgnoreRowClick: props.shouldIgnoreRowClick,
    shouldClipContent: props.isTruncated && !props.shouldRenderResizingIndicator,
    shouldRenderBottomBorder: props.shouldRenderBottomBorder,
    children: [jsxRuntime.jsx(CellInner, _objectSpread$2(_objectSpread$2({
      isCondensed: props.isCondensed,
      isTruncated: props.isTruncated,
      verticalCellAlignment: props.verticalCellAlignment,
      horizontalCellAlignment: props.horizontalCellAlignment
    }, utils.filterDataAttributes(props)), {}, {
      children: props.children
    })), props.shouldRenderCollapseButton && jsxRuntime.jsx(RowExpandCollapseButton, {
      label: "Expand/Collapse Row",
      onClick: event => {
        if (props.handleRowCollapseClick) props.handleRowCollapseClick();
        event.stopPropagation();
      },
      isRowCollapsed: props.isRowCollapsed,
      children: jsxRuntime.jsx(Icon, {
        size: "small"
      })
    }), props.shouldRenderResizingIndicator && jsxRuntime.jsx(Resizer, {
      isOnDataCell: true
    })]
  });
};
DataCell.propTypes = {};
DataCell.displayName = 'DataCell';
DataCell.defaultProps = defaultProps$2;
var DataCell$1 = DataCell;

const defaultItemRenderer = (row, column) => {
  // @ts-ignore
  return row[column.key];
};
const defaultProps$1 = {
  isCondensed: true,
  shouldClipContent: false,
  verticalCellAlignment: 'top',
  horizontalCellAlignment: 'left',
  shouldRenderBottomBorder: true,
  itemRenderer: defaultItemRenderer
};
const DataRow = props => {
  var _context, _context2;
  const _ref = react$1.useContext(ColumnResizingContext),
    getIsColumnBeingResized = _ref.getIsColumnBeingResized;
  const rowHasTruncatedColumn = _someInstanceProperty__default["default"](_context = props.columns).call(_context, column => column.isTruncated);
  const _useState = react$1.useState(rowHasTruncatedColumn),
    _useState2 = _slicedToArray(_useState, 2),
    isRowCollapsed = _useState2[0],
    collapseRow = _useState2[1];
  const handleRowCollapseClick = () => {
    collapseRow(!isRowCollapsed);
  };

  // update the collapsed state if isTruncated options are changed for the whole row
  react$1.useEffect(() => {
    if (rowHasTruncatedColumn) {
      collapseRow(true);
    } else {
      collapseRow(false);
    }
  }, [rowHasTruncatedColumn]);
  const shouldRenderCollapseButton = (totalColumnsLength, currentColumnIndex) => rowHasTruncatedColumn && totalColumnsLength - 1 === currentColumnIndex;
  return jsxRuntime.jsx(TableRow, {
    isRowClickable: Boolean(props.onRowClick),
    children: _mapInstanceProperty__default["default"](_context2 = props.columns).call(_context2, (column, columnIndex) => {
      var _context3, _context4;
      return jsxRuntime.jsx(DataCell$1, {
        "data-testid": _concatInstanceProperty__default["default"](_context4 = "cell-".concat(props.rowIndex, "-")).call(_context4, column.key),
        isTruncated: column.isTruncated && isRowCollapsed,
        isCondensed: props.isCondensed,
        isRowCollapsed: isRowCollapsed,
        verticalCellAlignment: props.verticalCellAlignment,
        horizontalCellAlignment: column.align ? column.align : props.horizontalCellAlignment,
        shouldIgnoreRowClick: column.shouldIgnoreRowClick,
        handleRowCollapseClick: handleRowCollapseClick,
        shouldRenderCollapseButton: shouldRenderCollapseButton(props.columns.length, columnIndex),
        onCellClick: props.onRowClick && !column.shouldIgnoreRowClick ? () => {
          var _props$onRowClick;
          return (_props$onRowClick = props.onRowClick) === null || _props$onRowClick === void 0 ? void 0 : _props$onRowClick.call(props, props.row, props.rowIndex, column.key);
        } : undefined,
        shouldRenderBottomBorder: props.shouldRenderBottomBorder,
        shouldRenderResizingIndicator: getIsColumnBeingResized(columnIndex),
        children: column.renderItem ? column.renderItem(props.row, isRowCollapsed) : props.itemRenderer(props.row, column, isRowCollapsed)
      }, _concatInstanceProperty__default["default"](_context3 = "".concat(props.row.id, "-")).call(_context3, column.key));
    })
  });
};
DataRow.propTypes = {};
DataRow.defaultProps = defaultProps$1;
DataRow.displayName = 'DataRow';
var DataRow$1 = DataRow;

function ownKeys$1(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context3, _context4; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context3 = ownKeys$1(Object(source), !0)).call(_context3, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context4 = ownKeys$1(Object(source))).call(_context4, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const MINIMUM_COLUMN_SIZE = 32;

// calculates size on mouse-drag and enforces a minimum size
const calculateNewSize = function () {
  let initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  let initialMousePosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let newMousePosition = arguments.length > 2 ? arguments[2] : undefined;
  let minSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MINIMUM_COLUMN_SIZE;
  const newSize = initialSize - (initialMousePosition - newMousePosition);
  return minSize > newSize ? minSize : newSize;
};
const setColumnWidth = function () {
  let columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let position = arguments.length > 1 ? arguments[1] : undefined;
  let value = arguments.length > 2 ? arguments[2] : undefined;
  // columns => comes from state.sizes which reflects component's state
  // any update to the columns results in updating the state

  columns[position] = _objectSpread$1(_objectSpread$1({}, columns[position]), {}, {
    width: value
  });
  return columns;
};
const getGridTemplateColumnsStyle = columns => "".concat(_mapInstanceProperty__default["default"](columns).call(columns, width => "".concat(width || 0, "px")).join(' '));
const initialState = tableRef => ({
  initialColWidth: undefined,
  initialMousePosition: undefined,
  columnBeingResized: undefined,
  hasBeenResized: false,
  sizes: undefined,
  tableRef
});
function reducer(state, action) {
  switch (action.type) {
    case 'reset':
      {
        return _objectSpread$1({}, initialState(state.tableRef));
      }
    case 'registerColumnMeasurements':
      {
        return _objectSpread$1(_objectSpread$1({}, state), {}, {
          sizes: action.payload.sizes
        });
      }
    case 'startResizing':
      return _objectSpread$1(_objectSpread$1({}, state), {}, {
        initialColWidth: action.payload.initialColWidth,
        initialMousePosition: action.payload.initialMousePosition,
        columnBeingResized: action.payload.columnBeingResized
      });
    case 'finishResizing':
      return _objectSpread$1(_objectSpread$1({}, state), {}, {
        initialColWidth: undefined,
        initialMousePosition: undefined,
        columnBeingResized: undefined,
        hasBeenResized: true
      });
    default:
      return state;
  }
}
const useManualResizingReducer = tableRef => {
  const _useReducer = react$1.useReducer(reducer, initialState(tableRef)),
    _useReducer2 = _slicedToArray(_useReducer, 2),
    manualResizingState = _useReducer2[0],
    dispatch = _useReducer2[1];
  react$1.useDebugValue(manualResizingState);
  return [manualResizingState, dispatch];
};
const useManualColumnResizing = tableRef => {
  var _state$tableRef;
  const _useManualResizingRed = useManualResizingReducer(tableRef),
    _useManualResizingRed2 = _slicedToArray(_useManualResizingRed, 2),
    state = _useManualResizingRed2[0],
    dispatch = _useManualResizingRed2[1];

  // if the table element has been rendered and we haven't yet measured the columns
  if ((_state$tableRef = state.tableRef) !== null && _state$tableRef !== void 0 && _state$tableRef.current && !state.sizes) {
    var _context;
    const renderedColumnMeasurements = [];
    _forEachInstanceProperty__default["default"](_context = state.tableRef.current.querySelectorAll('th')).call(_context, header => {
      renderedColumnMeasurements.push({
        key: header.getAttribute('data-id'),
        width: header.getBoundingClientRect().width
      });
    });
    dispatch({
      type: 'registerColumnMeasurements',
      payload: {
        sizes: renderedColumnMeasurements
      }
    });
  }
  const startResizing = (headerRef, mouseEvent) => {
    dispatch({
      type: 'startResizing',
      payload: {
        initialColWidth: headerRef.current.clientWidth,
        initialMousePosition: mouseEvent.clientX,
        columnBeingResized: headerRef.current.cellIndex
      }
    });
  };
  const onDragResizing = (event, columnIndex) => {
    // throttle and sync resizing update rate with screen refresh rate
    requestAnimationFrame(() => {
      var _state$tableRef2;
      const width = calculateNewSize(state.initialColWidth, state.initialMousePosition, event.clientX);
      const newColumnsSizes = setColumnWidth(state.sizes, columnIndex, width);
      if (!((_state$tableRef2 = state.tableRef) !== null && _state$tableRef2 !== void 0 && _state$tableRef2.current)) return;
      state.tableRef.current.style.gridTemplateColumns = getGridTemplateColumnsStyle(_mapInstanceProperty__default["default"](newColumnsSizes).call(newColumnsSizes, newColumnsSize => newColumnsSize.width.toString()));
    });
  };
  const finishResizing = () => {
    dispatch({
      type: 'finishResizing'
    });
    return state.sizes;
  };
  const getIsColumnBeingResized = columnIndex => state.columnBeingResized !== undefined ? state.columnBeingResized === columnIndex : false;
  const getIsAnyColumnBeingResized = () => state.columnBeingResized !== undefined;
  const getHasTableBeenResized = () => state.hasBeenResized;
  const getTotalResizedTableWidth = () => {
    var _context2;
    if (!state.hasBeenResized || !state.sizes) {
      return -1;
    }
    return _reduceInstanceProperty__default["default"](_context2 = state.sizes).call(_context2, (a, b) => a + b.width, 0);
  };
  const reset = () => {
    var _state$tableRef3;
    if (!((_state$tableRef3 = state.tableRef) !== null && _state$tableRef3 !== void 0 && _state$tableRef3.current)) return;
    state.tableRef.current.style.gridTemplateColumns = '';
    return dispatch({
      type: 'reset'
    });
  };
  const getSizes = () => state.sizes;
  react$1.useDebugValue(state);
  return {
    reset,
    getSizes,
    startResizing,
    onDragResizing,
    finishResizing,
    getHasTableBeenResized,
    getIsColumnBeingResized,
    getIsAnyColumnBeingResized,
    getTotalResizedTableWidth
  };
};
var useManualColumnResizing$1 = useManualColumnResizing;

function ownKeys(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context3, _context4; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context4 = ownKeys(Object(source))).call(_context4, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const getColumnsLayoutInfo = columns => _reduceInstanceProperty__default["default"](columns).call(columns, (acc, currentValue) => [...acc, {
  key: currentValue.key,
  width: currentValue.width
}], []);
const shouldRenderRowBottomBorder = (rowIndex, rowCount, footer) => {
  if (!footer) return true;
  if (rowIndex + 1 < rowCount) return true;
  return false;
};
const defaultProps = {
  columns: [],
  isCondensed: true,
  wrapHeaderLabels: true,
  verticalCellAlignment: 'top',
  horizontalCellAlignment: 'left',
  disableSelfContainment: false,
  // @ts-ignore
  itemRenderer: (row, column) => row[column.key]
};
const DataTable = props => {
  var _context, _context2;
  const tableRef = react$1.useRef();
  const columnResizingReducer = useManualColumnResizing$1(tableRef);

  // if the table columns have been measured
  // and if the list of columns, their width field, or the isCondensed prop has changed
  // then we need to reset the resized column widths
  const columnsInfo = getColumnsLayoutInfo(props.columns);
  const prevLayout = hooks.usePrevious({
    columns: columnsInfo,
    isCondensed: props.isCondensed
  });
  const currentLayout = {
    columns: columnsInfo,
    isCondensed: props.isCondensed
  };
  const hasLayoutChanged = !isEqual__default["default"](prevLayout, currentLayout);
  react$1.useLayoutEffect(() => {
    if (hasLayoutChanged) {
      columnResizingReducer.reset();
    }
  }, [columnResizingReducer, hasLayoutChanged]);
  const hasTableBeenResized = columnResizingReducer.getHasTableBeenResized();
  const resizedTotalWidth = hasTableBeenResized && tableRef.current ? columnResizingReducer.getTotalResizedTableWidth() + (
  // if the table has a maxHeight, it might add a scrollbar which takes space inside the container
  tableRef.current.offsetWidth - tableRef.current.clientWidth) : undefined;
  return jsxRuntime.jsxs(TableContainer, {
    maxWidth: props.maxWidth,
    maxHeight: props.maxHeight,
    isBeingResized: columnResizingReducer.getIsAnyColumnBeingResized(),
    disableSelfContainment: !!props.disableSelfContainment,
    children: [jsxRuntime.jsx(TableGrid, _objectSpread(_objectSpread({
      ref: tableRef
    }, utils.filterDataAttributes(props)), {}, {
      columns: props.columns,
      maxHeight: props.maxHeight,
      disableSelfContainment: !!props.disableSelfContainment,
      resizedTotalWidth: resizedTotalWidth,
      children: jsxRuntime.jsxs(ColumnResizingContext.Provider, {
        value: columnResizingReducer,
        children: [jsxRuntime.jsx(TableHeader, {
          children: jsxRuntime.jsx(TableRow, {
            isRowClickable: false,
            children: _mapInstanceProperty__default["default"](_context = props.columns).call(_context, column => jsxRuntime.jsx(HeaderCell$1, {
              shouldWrap: props.wrapHeaderLabels,
              isCondensed: props.isCondensed,
              iconComponent: column.headerIcon,
              onColumnResized: props.onColumnResized,
              disableResizing: column.disableResizing,
              horizontalCellAlignment: column.align ? column.align : props.horizontalCellAlignment,
              disableHeaderStickiness: props.disableHeaderStickiness,
              columnWidth: column.width
              /* Sorting Props */,
              onClick: props.onSortChange && props.onSortChange,
              sortedBy: props.sortedBy,
              columnKey: column.key,
              isSortable: column.isSortable,
              sortDirection: props.sortDirection,
              children: column.label
            }, column.key))
          })
        }), jsxRuntime.jsx(TableBody, {
          children: _mapInstanceProperty__default["default"](_context2 = props.rows).call(_context2, (row, rowIndex) => react.createElement(DataRow$1, _objectSpread(_objectSpread({}, props), {}, {
            row: row,
            key: row.id,
            rowIndex: rowIndex,
            shouldClipContent: columnResizingReducer.getIsAnyColumnBeingResized() || hasTableBeenResized,
            shouldRenderBottomBorder: shouldRenderRowBottomBorder(rowIndex, props.rows.length, props.footer)
          })))
        })]
      })
    })), props.footer && jsxRuntime.jsx(Footer$1, {
      "data-testid": "footer",
      isCondensed: props.isCondensed,
      horizontalCellAlignment: props.horizontalCellAlignment,
      resizedTotalWidth: resizedTotalWidth,
      children: props.footer
    })]
  });
};
DataTable.propTypes = {};
DataTable.defaultProps = defaultProps;
DataTable.displayName = 'DataTable';
var DataTable$1 = DataTable;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

Object.defineProperty(exports, 'useRowSelection', {
  enumerable: true,
  get: function () { return hooks.useRowSelection; }
});
Object.defineProperty(exports, 'useSorting', {
  enumerable: true,
  get: function () { return hooks.useSorting; }
});
exports["default"] = DataTable$1;
exports.version = version;
