'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
var _slicedToArray = require('@babel/runtime-corejs3/helpers/slicedToArray');
require('prop-types');
var _setTimeout = require('@babel/runtime-corejs3/core-js-stable/set-timeout');
var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var react$1 = require('react');
require('react-is');
var isNil = require('lodash/isNil');
var usePopper = require('use-popper');
var react = require('@emotion/react');
var hooks = require('@commercetools-uikit/hooks');
var utils = require('@commercetools-uikit/utils');
var _taggedTemplateLiteral = require('@babel/runtime-corejs3/helpers/taggedTemplateLiteral');
var _styled = require('@emotion/styled/base');
var designSystem = require('@commercetools-uikit/design-system');
var jsxRuntime = require('@emotion/react/jsx-runtime');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _setTimeout__default = /*#__PURE__*/_interopDefault(_setTimeout);
var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var isNil__default = /*#__PURE__*/_interopDefault(isNil);
var usePopper__default = /*#__PURE__*/_interopDefault(usePopper);
var _styled__default = /*#__PURE__*/_interopDefault(_styled);

var _templateObject, _templateObject2;
function ownKeys$1(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys$1(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys$1(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const growIn = react.keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  from {\n    transform: scale(0);\n  }\n  to {\n    transform: scale(1);\n  }\n"])));
const growOut = react.keyframes(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  from {\n    transform: scale(1);\n  }\n  to {\n    transform: scale(0);\n  }\n"])));
const getAnimation = state => {
  switch (state) {
    case 'opened':
      return {
        animation: "".concat(growIn, " 80ms")
      };
    case 'exiting':
      return {
        animation: "".concat(growOut, " 80ms")
      };
    default:
      return {};
  }
};
const getOffsetMargin = _ref => {
  let placement = _ref.placement;
  const position = placement && placement.split('-')[0] || '';
  switch (position) {
    case 'left':
    case 'right':
      return "0 ".concat(designSystem.designTokens.spacing10);
    case 'top':
    case 'bottom':
      return "".concat(designSystem.designTokens.spacing10, " 0");
    default:
      return '';
  }
};
const Body = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e14le4p1"
} )("font-family:inherit;border-radius:", designSystem.designTokens.borderRadius6, ";padding:", designSystem.designTokens.paddingForTooltip, ";border:none;box-shadow:", designSystem.designTokens.shadowForTooltip, ";font-size:", designSystem.designTokens.fontSize10, ";opacity:0.95;color:", designSystem.designTokens.colorSurface, ";background-color:", designSystem.designTokens.backgroundColorForTooltip, ";white-space:break-spaces;" + ("" ));

// here we use object styles so we can spread these
// with the styles we get from react-popper :D
// eslint-disable-next-line import/prefer-default-export
const getBodyStyles = _ref2 => {
  let constraint = _ref2.constraint,
    placement = _ref2.placement,
    customStyles = _ref2.customStyles;
  const constraintTokenName = "constraint".concat(constraint);
  return _objectSpread$1({
    fontFamily: 'inherit',
    margin: "".concat(getOffsetMargin({
      placement
    }), " !important"),
    maxWidth: constraintTokenName in designSystem.designTokens ? designSystem.designTokens[constraintTokenName] : 'auto',
    // so hovering over the tooltip when the tooltip overlaps the component
    pointerEvents: 'none',
    width: constraint === 'auto' ? 'auto' : undefined,
    zIndex: 1000
  }, customStyles);
};
const getTooltipStyles = tooltipState => getAnimation(tooltipState);
const Wrapper = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e14le4p0"
} )({
  name: "18fwu9s",
  styles: "display:inline-block;cursor:not-allowed;>:disabled{pointer-events:none;}"
} );

function ownKeys(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const sequentialId = utils.createSequentialId('tooltip-');
const TooltipWrapper = props => jsxRuntime.jsx(jsxRuntime.Fragment, {
  children: props.children
});
TooltipWrapper.displayName = 'TooltipWrapperComponent';
const tooltipDefaultProps = {
  showAfter: 300,
  closeAfter: 200,
  horizontalConstraint: 'scale',
  off: false,
  placement: 'top'
};
const Tooltip = props => {
  var _props$components, _props$components2, _props$components3, _props$components4, _props$components5, _props$components6, _props$styles;
  const enterTimer = react$1.useRef();
  const leaveTimer = react$1.useRef();
  if ((_props$components = props.components) !== null && _props$components !== void 0 && _props$components.BodyComponent) ;
  if ((_props$components2 = props.components) !== null && _props$components2 !== void 0 && _props$components2.TooltipWrapperComponent) ;
  if ((_props$components3 = props.components) !== null && _props$components3 !== void 0 && _props$components3.WrapperComponent) ;
  react$1.useEffect(() => {
    return () => {
      if (enterTimer.current) {
        clearTimeout(enterTimer.current);
      }
      if (leaveTimer.current) {
        clearTimeout(leaveTimer.current);
      }
    };
  }, []);
  const _usePopper = usePopper__default["default"]({
      placement: props.placement,
      modifiers: props.modifiers
    }),
    reference = _usePopper.reference,
    popper = _usePopper.popper,
    popperInstance = _usePopper.popperInstance;
  const _useState = react$1.useState('closed'),
    _useState2 = _slicedToArray(_useState, 2),
    state = _useState2[0],
    setState = _useState2[1];
  const isControlled = !isNil__default["default"](props.isOpen);
  const tooltipIsOpen = isControlled ? props.isOpen : state === 'opened' || state === 'exiting';
  const id = hooks.useFieldId(props.id, sequentialId);
  const onClose = props.onClose;
  const handleClose = react$1.useCallback(event => {
    if (!isControlled) {
      setState('closed');
    }
    if (onClose) {
      onClose(event);
    }
  }, [isControlled, onClose]);
  const _props$children$props = props.children.props,
    onFocus = _props$children$props.onFocus,
    onMouseOver = _props$children$props.onMouseOver;
  const showAfter = props.showAfter,
    onOpen = props.onOpen;
  const handleEnter = react$1.useCallback(event => {
    if (event) {
      if (event.type === 'mouseover' && onMouseOver) {
        onMouseOver(event);
      }
      if (event.type === 'focus' && onFocus) {
        onFocus(event);
      }
      if (state !== 'opened' && !isControlled) {
        setState('entering');
        enterTimer.current = _setTimeout__default["default"](() => {
          setState('opened');
          if (onOpen) {
            onOpen(event);
          }
        }, showAfter);
      }
      event.preventDefault();
      event.stopPropagation();
    }
  }, [onFocus, onOpen, onMouseOver, isControlled, state, showAfter]);
  const _props$children$props2 = props.children.props,
    onBlur = _props$children$props2.onBlur,
    onMouseLeave = _props$children$props2.onMouseLeave;
  const closeAfter = props.closeAfter;
  const handleLeave = react$1.useCallback(event => {
    clearTimeout(enterTimer.current);
    clearTimeout(leaveTimer.current);
    if (event.type === 'mouseleave' && onMouseLeave) {
      onMouseLeave(event);
    }
    if (event.type === 'blur' && onBlur) {
      onBlur(event);
    }
    if (closeAfter && state === 'opened') {
      leaveTimer.current = _setTimeout__default["default"](() => {
        const tooltipElement = popperInstance === null || popperInstance === void 0 ? void 0 : popperInstance.popper.querySelector('[data-testid="tooltip-message-wrapper"]');
        if (tooltipElement) {
          tooltipElement.addEventListener('animationend', () => handleClose());
        } else {
          handleClose();
        }
        setState('exiting');
      }, closeAfter);
    } else {
      handleClose(event);
    }
  }, [closeAfter, onBlur, onMouseLeave, handleClose, state, popperInstance]);
  react$1.useEffect(() => {
    // if tooltip was open, and then component
    // updated to be off, we should close the tooltip
    if (state === 'opened' && props.off) {
      if (closeAfter) {
        leaveTimer.current = _setTimeout__default["default"](() => {
          handleClose();
        }, closeAfter);
      } else {
        handleClose();
      }
    }
  }, [props.off, closeAfter, handleClose, state]);
  const childrenProps = {
    // don't pass event listeners to children
    onFocus: null,
    onMouseOver: null,
    onMouseLeave: null,
    onBlur: null
  };
  const tooltipProps = !props.off ? {
    'aria-describedby': tooltipIsOpen ? id : null,
    // for seo and accessibility, we add the tooltip's title
    // as a native title when the title is hidden
    title: !tooltipIsOpen && state !== 'entering' && typeof props.title === 'string' ? props.title : null
  } : {};
  const eventListeners = !props.off ? {
    onMouseEnter: handleEnter,
    onMouseLeave: handleLeave,
    onFocus: handleEnter,
    onBlur: handleLeave
  } : {};
  const WrapperComponent = ((_props$components4 = props.components) === null || _props$components4 === void 0 ? void 0 : _props$components4.WrapperComponent) || Wrapper;
  const BodyComponent = ((_props$components5 = props.components) === null || _props$components5 === void 0 ? void 0 : _props$components5.BodyComponent) || Body;
  const TooltipWrapperComponent = ((_props$components6 = props.components) === null || _props$components6 === void 0 ? void 0 : _props$components6.TooltipWrapperComponent) || TooltipWrapper;
  return jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [jsxRuntime.jsx(WrapperComponent, _objectSpread(_objectSpread({}, eventListeners), {}, {
      // @ts-expect-error: yes, ref can be undefined
      ref: reference.ref,
      children: /*#__PURE__*/react$1.cloneElement(props.children, _objectSpread(_objectSpread({}, childrenProps), tooltipProps))
    })), tooltipIsOpen && jsxRuntime.jsx(TooltipWrapperComponent, {
      children: jsxRuntime.jsx("div", {
        // ref accepts `LegacyRef`, which is a union of `RefObject` and `string`
        // propper.ref returns `RefObject`
        ref: popper.ref,
        css: /*#__PURE__*/react.css(_objectSpread(_objectSpread({}, popper.styles), getBodyStyles({
          constraint: props.horizontalConstraint,
          placement: popper.placement,
          customStyles: (_props$styles = props.styles) === null || _props$styles === void 0 ? void 0 : _props$styles.body
        })), "" , "" ),
        "data-placement": popper.placement,
        children: jsxRuntime.jsx("div", {
          css: /*#__PURE__*/react.css(_objectSpread({}, getTooltipStyles(state)), "" , "" ),
          "data-testid": "tooltip-message-wrapper",
          children: jsxRuntime.jsx(BodyComponent, {
            children: props.title
          })
        })
      })
    })]
  });
};
Tooltip.propTypes = {};
Tooltip.displayName = 'ToolTip';
Tooltip.defaultProps = tooltipDefaultProps;
var Tooltip$1 = Tooltip;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

exports["default"] = Tooltip$1;
exports.version = version;
