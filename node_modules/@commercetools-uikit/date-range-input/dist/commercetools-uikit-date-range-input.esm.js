import _Reflect$construct from '@babel/runtime-corejs3/core-js-stable/reflect/construct';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _classCallCheck from '@babel/runtime-corejs3/helpers/esm/classCallCheck';
import _createClass from '@babel/runtime-corejs3/helpers/esm/createClass';
import _inherits from '@babel/runtime-corejs3/helpers/esm/inherits';
import _possibleConstructorReturn from '@babel/runtime-corejs3/helpers/esm/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime-corejs3/helpers/esm/getPrototypeOf';
import _pt from 'prop-types';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _mapInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/map';
import _trimInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/trim';
import _sortInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/sort';
import _fillInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/fill';
import _concatInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/concat';
import { createRef, Component } from 'react';
import Downshift from 'downshift';
import { injectIntl } from 'react-intl';
import Constraints from '@commercetools-uikit/constraints';
import { filterDataAttributes } from '@commercetools-uikit/utils';
import { getToday, formatRange, changeMonth, getDateInMonth, createItemRangeToString, createCalendarItems, getPaddingDayCount, getWeekdayNames, CalendarBody, getPreviousDay, getDaysInMonth, CalendarMenu, CalendarHeader, getMonthCalendarLabel, getYearCalendarLabel, CalendarContent, CalendarDay, isSameDay, getCalendarDayLabel, parseInputToDate, isBetween } from '@commercetools-uikit/calendar-utils';
import { getLocalizedDateTimeFormatPattern } from '@commercetools-uikit/calendar-time-utils';
import { jsx, jsxs } from '@emotion/react/jsx-runtime';

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context5, _context6; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context5 = ownKeys(Object(source), !0)).call(_context5, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context6 = ownKeys(Object(source))).call(_context6, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
const preventDownshiftDefault = event => {
  event.nativeEvent.preventDownshiftDefault = true;
};
const parseRangeText = (text, locale) => {
  var _context, _context2;
  const parts = _filterInstanceProperty(_context = _mapInstanceProperty(_context2 = text.split(' - ')).call(_context2, part => {
    const parsedDate = parseInputToDate(_trimInstanceProperty(part).call(part), locale);
    return parsedDate === '' ? null : parsedDate;
  })).call(_context, Boolean);
  return parts;
};
const isSameRange = (a, b) => {
  if (a.length !== b.length) return false;
  if (a.length === 0) return true;
  if (a[0] === b[0] && a[1] === b[1]) return true;
  return false;
};
const getRange = _ref => {
  let item = _ref.item,
    value = _ref.value,
    startDate = _ref.startDate,
    highlightedItem = _ref.highlightedItem;
  const isRangeSelectionInProgress = startDate;
  const hasSelection = value.length === 2;
  const isStartDate = isSameDay(item, startDate);
  const isBetween$1 = highlightedItem && isBetween(item, startDate, highlightedItem);
  let isRangeStart = false;
  if (isRangeSelectionInProgress) {
    isRangeStart = isStartDate;
  } else if (hasSelection) {
    isRangeStart = value[0] === item;
  }
  let isRangeBetween = false;
  if (isRangeSelectionInProgress) {
    isRangeBetween = isBetween$1;
  } else if (hasSelection) {
    isRangeBetween = isBetween(item, value[0], value[1]);
  }
  let isRangeEnd = false;
  if (isRangeSelectionInProgress) {
    isRangeEnd = item === highlightedItem;
  } else if (hasSelection) {
    isRangeEnd = value[1] === item;
  }
  return {
    isRangeStart,
    isRangeBetween,
    isRangeEnd
  };
};
let DateRangeInput = /*#__PURE__*/function (_Component) {
  _inherits(DateRangeInput, _Component);
  var _super = _createSuper(DateRangeInput);
  function DateRangeInput() {
    var _this;
    _classCallCheck(this, DateRangeInput);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.inputRef = /*#__PURE__*/createRef();
    _this.state = {
      calendarDate: _this.props.value.length === 2 ? _this.props.value[0] : getToday(),
      suggestedItems: [],
      startDate: null,
      highlightedIndex: null,
      isOpen: false,
      inputValue: formatRange(_this.props.value, _this.props.intl.locale),
      prevValue: _this.props.value,
      prevLocale: _this.props.intl.locale
    };
    _this.jumpMonth = function (amount) {
      let dayToHighlight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      _this.setState(prevState => {
        const nextDate = changeMonth(prevState.calendarDate, amount);
        return {
          calendarDate: nextDate,
          highlightedIndex: dayToHighlight
        };
      });
    };
    _this.showToday = () => {
      const today = getToday();
      _this.setState(prevState => ({
        calendarDate: today,
        highlightedIndex: prevState.suggestedItems.length + getDateInMonth(today) - 1
      }), () => {
        var _this$inputRef$curren;
        return (_this$inputRef$curren = _this.inputRef.current) === null || _this$inputRef$curren === void 0 ? void 0 : _this$inputRef$curren.focus();
      });
    };
    _this.handleBlur = () => {
      if (_this.props.onBlur) _this.props.onBlur({
        target: {
          id: _this.props.id,
          name: _this.props.name
        }
      });
    };
    _this.emit = unsortedRange => {
      var _this$props$onChange, _this$props;
      (_this$props$onChange = (_this$props = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props, {
        target: {
          id: _this.props.id,
          name: _this.props.name,
          value: _sortInstanceProperty(unsortedRange).call(unsortedRange)
        }
      });
    };
    return _this;
  }
  _createClass(DateRangeInput, [{
    key: "render",
    value: function render() {
      return jsx(Constraints.Horizontal, {
        max: this.props.horizontalConstraint,
        children: jsx(Downshift, {
          inputId: this.props.id,
          itemToString: createItemRangeToString(this.props.intl.locale),
          inputValue: this.state.inputValue,
          selectedItem: null,
          highlightedIndex: this.state.highlightedIndex,
          onInputValueChange: (inputValue, changes) => {
            // only attempt to parse input when the user typed into the input
            // field
            // @ts-ignore
            if (changes.type !== Downshift.stateChangeTypes.changeInput) return;
            this.setState(() => {
              const parsedRange = parseRangeText(inputValue, this.props.intl.locale);
              if (parsedRange.length === 0) return {
                suggestedItems: [],
                highlightedIndex: null,
                inputValue,
                startDate: null
              };
              if (parsedRange.length === 1) {
                const calendarDate = parsedRange[0];
                return {
                  suggestedItems: [],
                  highlightedIndex: getDateInMonth(calendarDate) - 1,
                  inputValue,
                  startDate: parsedRange[0],
                  calendarDate
                };
              }
              if (parsedRange.length === 2) {
                const calendarDate = parsedRange[1];
                return {
                  suggestedItems: [],
                  highlightedIndex: getDateInMonth(calendarDate) - 1,
                  inputValue,
                  startDate: parsedRange[0],
                  calendarDate
                };
              }
              return null;
            });
          },
          onStateChange: changes => {
            this.setState(prevState => {
              if (changes.type === Downshift.stateChangeTypes.mouseUp || changes.type === Downshift.stateChangeTypes.blurInput) {
                return {
                  highlightedIndex: null,
                  isOpen: false,
                  inputValue: formatRange(this.props.value, this.props.intl.locale)
                };
              }
              if (changes.hasOwnProperty('selectedItem')) {
                const hasStartedRangeSelection = Boolean(!prevState.startDate && changes.selectedItem);
                const hasFinishedRangeSelection = Boolean(prevState.startDate && changes.selectedItem);
                return {
                  highlightedIndex: prevState.highlightedIndex,
                  startDate: prevState.startDate ? null : changes.selectedItem,
                  calendarDate: changes.selectedItem,
                  isOpen: !hasFinishedRangeSelection,
                  inputValue: (() => {
                    if (hasFinishedRangeSelection) {
                      return formatRange([prevState.startDate, changes.selectedItem], this.props.intl.locale);
                    }
                    if (hasStartedRangeSelection) {
                      return formatRange([changes.selectedItem], this.props.intl.locale);
                    }
                    return '';
                  })()
                };
              }
              if (changes.hasOwnProperty('isOpen')) {
                return {
                  isOpen: changes.isOpen,
                  highlightedIndex: changes.highlightedIndex || null,
                  inputValue: changes.inputValue || prevState.inputValue,
                  // Reset range selection progress when menu opens/closes
                  startDate: null,
                  // Ensure calendar opens on selected date.
                  // Open on the current day as a fallback.
                  calendarDate: this.props.value.length === 2 ? this.props.value[0] : getToday()
                };
              }
              if (changes.hasOwnProperty('highlightedIndex')) {
                return {
                  highlightedIndex: changes.highlightedIndex
                };
              }
              return null;
            });
          },
          onChange: selectedItem => {
            if (this.state.startDate && selectedItem) {
              this.emit([this.state.startDate, selectedItem]);
            } else {
              this.emit([]);
            }
          },
          isOpen: this.state.isOpen,
          children: _ref2 => {
            var _context3, _context4;
            let getInputProps = _ref2.getInputProps,
              getMenuProps = _ref2.getMenuProps,
              getItemProps = _ref2.getItemProps,
              getToggleButtonProps = _ref2.getToggleButtonProps,
              clearSelection = _ref2.clearSelection,
              highlightedIndex = _ref2.highlightedIndex,
              openMenu = _ref2.openMenu,
              setHighlightedIndex = _ref2.setHighlightedIndex,
              isOpen = _ref2.isOpen,
              inputValue = _ref2.inputValue;
            const calendarItems = createCalendarItems(this.state.calendarDate);
            const allItems = [...this.state.suggestedItems, ...calendarItems];
            const paddingDayCount = getPaddingDayCount(this.state.calendarDate, this.props.intl.locale);
            const paddingDays = _fillInstanceProperty(_context3 = Array(paddingDayCount)).call(_context3, undefined);
            const weekdays = getWeekdayNames(this.props.intl.locale);
            const today = getToday();
            return jsxs("div", {
              onFocus: this.props.onFocus,
              onBlur: this.handleBlur,
              children: [jsx(CalendarBody, {
                inputRef: this.inputRef,
                inputProps: getInputProps(_objectSpread({
                  /* ARIA */
                  'aria-invalid': this.props['aria-invalid'],
                  'aria-errormessage': this.props['aria-errormessage'],
                  // Unset the aria-labelledby as it interfers with the link
                  // between the <label for> and the <input id>.
                  'aria-labelledby': undefined,
                  name: this.props.name,
                  placeholder: typeof this.props.placeholder === 'string' ? this.props.placeholder : _concatInstanceProperty(_context4 = "".concat(getLocalizedDateTimeFormatPattern(this.props.intl.locale), " - ")).call(_context4, getLocalizedDateTimeFormatPattern(this.props.intl.locale)),
                  onMouseEnter: () => {
                    // we remove the highlight so that the user can use the
                    // arrow keys to move the cursor when hovering
                    // @ts-ignore
                    if (isOpen) setHighlightedIndex(null);
                  },
                  onKeyDown: event => {
                    if (this.props.isReadOnly) {
                      preventDownshiftDefault(event);
                      return;
                    }
                    if (event.key === 'Enter' && (inputValue === null || inputValue === void 0 ? void 0 : _trimInstanceProperty(inputValue).call(inputValue)) === '' &&
                    // do not clear value when user presses Enter to
                    // select the end date (so only clear when there is no
                    // startDate)
                    !this.state.startDate && this.props.isClearable) {
                      clearSelection();
                      this.emit([]);
                    }
                    // ArrowDown
                    if (event.key === 'ArrowDown') {
                      if (highlightedIndex + 1 >= calendarItems.length) {
                        // if it's the end of the month
                        // then bypass normal arrow navigation
                        preventDownshiftDefault(event);
                        // then jump to start of next month
                        this.jumpMonth(1, 0);
                      }
                    }
                    // ArrowUp
                    if (event.key === 'ArrowUp') {
                      const previousDay = getPreviousDay(calendarItems[highlightedIndex]);
                      if (highlightedIndex <= 0) {
                        // if it's the start of the month
                        // then bypass normal arrow navigation
                        preventDownshiftDefault(event);
                        const numberOfDaysOfPrevMonth = getDaysInMonth(previousDay);
                        // then jump to the last day of the previous month
                        this.jumpMonth(-1, numberOfDaysOfPrevMonth - 1);
                      }
                    }
                  },
                  // we only do this for readOnly because the input
                  // doesn't ignore these events, unlike when its disabled
                  onClick: this.props.isReadOnly ? undefined : openMenu
                }, filterDataAttributes(this.props))),
                hasSelection: this.props.value.length === 2,
                isClearable: this.props.isClearable,
                onClear: () => {
                  this.setState({
                    startDate: null
                  });
                  this.emit([]);
                  clearSelection();
                },
                isOpen: isOpen,
                isDisabled: this.props.isDisabled,
                isReadOnly: this.props.isReadOnly,
                toggleButtonProps: getToggleButtonProps(),
                hasError: this.props.hasError,
                hasWarning: this.props.hasWarning
              }), isOpen && !this.props.isDisabled && jsxs(CalendarMenu, _objectSpread(_objectSpread({}, getMenuProps()), {}, {
                hasError: this.props.hasError,
                hasWarning: this.props.hasWarning,
                children: [jsx(CalendarHeader, {
                  monthLabel: getMonthCalendarLabel(this.state.calendarDate, this.props.intl.locale),
                  yearLabel: getYearCalendarLabel(this.state.calendarDate, this.props.intl.locale),
                  onPrevMonthClick: () => this.jumpMonth(-1),
                  onTodayClick: this.showToday,
                  onNextMonthClick: () => this.jumpMonth(1),
                  onPrevYearClick: () => this.jumpMonth(-12),
                  onNextYearClick: () => this.jumpMonth(12)
                }), jsxs(CalendarContent, {
                  children: [_mapInstanceProperty(weekdays).call(weekdays, weekday => jsx(CalendarDay, {
                    type: "heading",
                    children: weekday
                  }, weekday)), _mapInstanceProperty(paddingDays).call(paddingDays, (_, index) => jsx(CalendarDay, {
                    type: "spacing"
                  }, index)), _mapInstanceProperty(calendarItems).call(calendarItems, (item, index) => {
                    const isHighlighted = this.state.suggestedItems.length + index === highlightedIndex;
                    const _getRange = getRange({
                        item,
                        value: this.props.value,
                        startDate: this.state.startDate,
                        highlightedItem: allItems[this.state.highlightedIndex || 0]
                      }),
                      isRangeStart = _getRange.isRangeStart,
                      isRangeBetween = _getRange.isRangeBetween,
                      isRangeEnd = _getRange.isRangeEnd;
                    return jsx(CalendarDay, _objectSpread(_objectSpread({
                      isToday: isSameDay(today, item)
                    }, getItemProps({
                      disabled: this.props.isDisabled,
                      item,
                      onMouseOut: () => {
                        // @ts-ignore
                        setHighlightedIndex(null);
                      }
                    })), {}, {
                      isHighlighted: isHighlighted,
                      isRangeStart: isRangeStart,
                      isRangeBetween: isRangeBetween,
                      isRangeEnd: isRangeEnd,
                      children: getCalendarDayLabel(item)
                    }), item);
                  })]
                })]
              }))]
            });
          }
        }, this.props.intl.locale)
      });
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      // We need to update the input value string in case so that is is formatted
      // according to the locale and holds the current value in case the value
      // changes or when the locale changes
      const shouldUpdateInputValue = !isSameRange(props.value, state.prevValue) || props.intl.locale !== state.prevLocale;
      if (!shouldUpdateInputValue) return null;
      return {
        prevLocale: props.intl.locale,
        // This is not the input value but the actual value passed to
        // DateRangeInput
        prevValue: props.value,
        inputValue: formatRange(props.value, props.intl.locale)
      };
    }
  }]);
  return DateRangeInput;
}(Component);
DateRangeInput.displayName = 'DateRangeInput';
DateRangeInput.defaultProps = {
  isClearable: true
};
DateRangeInput.isEmpty = range => range.length === 0;
DateRangeInput.propTypes = process.env.NODE_ENV !== "production" ? {
  horizontalConstraint: _pt.oneOf([6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 'scale', 'auto']),
  value: _pt.arrayOf(_pt.any).isRequired,
  'aria-invalid': _pt.bool,
  'aria-errormessage': _pt.string,
  onChange: _pt.func,
  isClearable: _pt.bool,
  onFocus: _pt.func,
  onBlur: _pt.func,
  id: _pt.string,
  name: _pt.string,
  placeholder: _pt.string,
  isDisabled: _pt.bool,
  isReadOnly: _pt.bool,
  hasError: _pt.bool,
  hasWarning: _pt.bool
} : {};
var dateRangeInput = injectIntl(DateRangeInput);

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

export { dateRangeInput as default, version };
