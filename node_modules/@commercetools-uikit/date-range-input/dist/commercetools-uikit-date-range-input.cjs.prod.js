'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _Reflect$construct = require('@babel/runtime-corejs3/core-js-stable/reflect/construct');
var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
var _classCallCheck = require('@babel/runtime-corejs3/helpers/classCallCheck');
var _createClass = require('@babel/runtime-corejs3/helpers/createClass');
var _inherits = require('@babel/runtime-corejs3/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime-corejs3/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime-corejs3/helpers/getPrototypeOf');
require('prop-types');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _mapInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/map');
var _trimInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/trim');
var _sortInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/sort');
var _fillInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/fill');
var _concatInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/concat');
var react = require('react');
var Downshift = require('downshift');
var reactIntl = require('react-intl');
var Constraints = require('@commercetools-uikit/constraints');
var utils = require('@commercetools-uikit/utils');
var calendarUtils = require('@commercetools-uikit/calendar-utils');
var calendarTimeUtils = require('@commercetools-uikit/calendar-time-utils');
var jsxRuntime = require('@emotion/react/jsx-runtime');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _Reflect$construct__default = /*#__PURE__*/_interopDefault(_Reflect$construct);
var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _mapInstanceProperty__default = /*#__PURE__*/_interopDefault(_mapInstanceProperty);
var _trimInstanceProperty__default = /*#__PURE__*/_interopDefault(_trimInstanceProperty);
var _sortInstanceProperty__default = /*#__PURE__*/_interopDefault(_sortInstanceProperty);
var _fillInstanceProperty__default = /*#__PURE__*/_interopDefault(_fillInstanceProperty);
var _concatInstanceProperty__default = /*#__PURE__*/_interopDefault(_concatInstanceProperty);
var Downshift__default = /*#__PURE__*/_interopDefault(Downshift);
var Constraints__default = /*#__PURE__*/_interopDefault(Constraints);

function ownKeys(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context5, _context6; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context5 = ownKeys(Object(source), !0)).call(_context5, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context6 = ownKeys(Object(source))).call(_context6, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct__default["default"](Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct__default["default"]) return false; if (_Reflect$construct__default["default"].sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct__default["default"](Boolean, [], function () {})); return true; } catch (e) { return false; } }
const preventDownshiftDefault = event => {
  event.nativeEvent.preventDownshiftDefault = true;
};
const parseRangeText = (text, locale) => {
  var _context, _context2;
  const parts = _filterInstanceProperty__default["default"](_context = _mapInstanceProperty__default["default"](_context2 = text.split(' - ')).call(_context2, part => {
    const parsedDate = calendarUtils.parseInputToDate(_trimInstanceProperty__default["default"](part).call(part), locale);
    return parsedDate === '' ? null : parsedDate;
  })).call(_context, Boolean);
  return parts;
};
const isSameRange = (a, b) => {
  if (a.length !== b.length) return false;
  if (a.length === 0) return true;
  if (a[0] === b[0] && a[1] === b[1]) return true;
  return false;
};
const getRange = _ref => {
  let item = _ref.item,
    value = _ref.value,
    startDate = _ref.startDate,
    highlightedItem = _ref.highlightedItem;
  const isRangeSelectionInProgress = startDate;
  const hasSelection = value.length === 2;
  const isStartDate = calendarUtils.isSameDay(item, startDate);
  const isBetween = highlightedItem && calendarUtils.isBetween(item, startDate, highlightedItem);
  let isRangeStart = false;
  if (isRangeSelectionInProgress) {
    isRangeStart = isStartDate;
  } else if (hasSelection) {
    isRangeStart = value[0] === item;
  }
  let isRangeBetween = false;
  if (isRangeSelectionInProgress) {
    isRangeBetween = isBetween;
  } else if (hasSelection) {
    isRangeBetween = calendarUtils.isBetween(item, value[0], value[1]);
  }
  let isRangeEnd = false;
  if (isRangeSelectionInProgress) {
    isRangeEnd = item === highlightedItem;
  } else if (hasSelection) {
    isRangeEnd = value[1] === item;
  }
  return {
    isRangeStart,
    isRangeBetween,
    isRangeEnd
  };
};
let DateRangeInput = /*#__PURE__*/function (_Component) {
  _inherits(DateRangeInput, _Component);
  var _super = _createSuper(DateRangeInput);
  function DateRangeInput() {
    var _this;
    _classCallCheck(this, DateRangeInput);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.inputRef = /*#__PURE__*/react.createRef();
    _this.state = {
      calendarDate: _this.props.value.length === 2 ? _this.props.value[0] : calendarUtils.getToday(),
      suggestedItems: [],
      startDate: null,
      highlightedIndex: null,
      isOpen: false,
      inputValue: calendarUtils.formatRange(_this.props.value, _this.props.intl.locale),
      prevValue: _this.props.value,
      prevLocale: _this.props.intl.locale
    };
    _this.jumpMonth = function (amount) {
      let dayToHighlight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      _this.setState(prevState => {
        const nextDate = calendarUtils.changeMonth(prevState.calendarDate, amount);
        return {
          calendarDate: nextDate,
          highlightedIndex: dayToHighlight
        };
      });
    };
    _this.showToday = () => {
      const today = calendarUtils.getToday();
      _this.setState(prevState => ({
        calendarDate: today,
        highlightedIndex: prevState.suggestedItems.length + calendarUtils.getDateInMonth(today) - 1
      }), () => {
        var _this$inputRef$curren;
        return (_this$inputRef$curren = _this.inputRef.current) === null || _this$inputRef$curren === void 0 ? void 0 : _this$inputRef$curren.focus();
      });
    };
    _this.handleBlur = () => {
      if (_this.props.onBlur) _this.props.onBlur({
        target: {
          id: _this.props.id,
          name: _this.props.name
        }
      });
    };
    _this.emit = unsortedRange => {
      var _this$props$onChange, _this$props;
      (_this$props$onChange = (_this$props = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props, {
        target: {
          id: _this.props.id,
          name: _this.props.name,
          value: _sortInstanceProperty__default["default"](unsortedRange).call(unsortedRange)
        }
      });
    };
    return _this;
  }
  _createClass(DateRangeInput, [{
    key: "render",
    value: function render() {
      return jsxRuntime.jsx(Constraints__default["default"].Horizontal, {
        max: this.props.horizontalConstraint,
        children: jsxRuntime.jsx(Downshift__default["default"], {
          inputId: this.props.id,
          itemToString: calendarUtils.createItemRangeToString(this.props.intl.locale),
          inputValue: this.state.inputValue,
          selectedItem: null,
          highlightedIndex: this.state.highlightedIndex,
          onInputValueChange: (inputValue, changes) => {
            // only attempt to parse input when the user typed into the input
            // field
            // @ts-ignore
            if (changes.type !== Downshift__default["default"].stateChangeTypes.changeInput) return;
            this.setState(() => {
              const parsedRange = parseRangeText(inputValue, this.props.intl.locale);
              if (parsedRange.length === 0) return {
                suggestedItems: [],
                highlightedIndex: null,
                inputValue,
                startDate: null
              };
              if (parsedRange.length === 1) {
                const calendarDate = parsedRange[0];
                return {
                  suggestedItems: [],
                  highlightedIndex: calendarUtils.getDateInMonth(calendarDate) - 1,
                  inputValue,
                  startDate: parsedRange[0],
                  calendarDate
                };
              }
              if (parsedRange.length === 2) {
                const calendarDate = parsedRange[1];
                return {
                  suggestedItems: [],
                  highlightedIndex: calendarUtils.getDateInMonth(calendarDate) - 1,
                  inputValue,
                  startDate: parsedRange[0],
                  calendarDate
                };
              }
              return null;
            });
          },
          onStateChange: changes => {
            this.setState(prevState => {
              if (changes.type === Downshift__default["default"].stateChangeTypes.mouseUp || changes.type === Downshift__default["default"].stateChangeTypes.blurInput) {
                return {
                  highlightedIndex: null,
                  isOpen: false,
                  inputValue: calendarUtils.formatRange(this.props.value, this.props.intl.locale)
                };
              }
              if (changes.hasOwnProperty('selectedItem')) {
                const hasStartedRangeSelection = Boolean(!prevState.startDate && changes.selectedItem);
                const hasFinishedRangeSelection = Boolean(prevState.startDate && changes.selectedItem);
                return {
                  highlightedIndex: prevState.highlightedIndex,
                  startDate: prevState.startDate ? null : changes.selectedItem,
                  calendarDate: changes.selectedItem,
                  isOpen: !hasFinishedRangeSelection,
                  inputValue: (() => {
                    if (hasFinishedRangeSelection) {
                      return calendarUtils.formatRange([prevState.startDate, changes.selectedItem], this.props.intl.locale);
                    }
                    if (hasStartedRangeSelection) {
                      return calendarUtils.formatRange([changes.selectedItem], this.props.intl.locale);
                    }
                    return '';
                  })()
                };
              }
              if (changes.hasOwnProperty('isOpen')) {
                return {
                  isOpen: changes.isOpen,
                  highlightedIndex: changes.highlightedIndex || null,
                  inputValue: changes.inputValue || prevState.inputValue,
                  // Reset range selection progress when menu opens/closes
                  startDate: null,
                  // Ensure calendar opens on selected date.
                  // Open on the current day as a fallback.
                  calendarDate: this.props.value.length === 2 ? this.props.value[0] : calendarUtils.getToday()
                };
              }
              if (changes.hasOwnProperty('highlightedIndex')) {
                return {
                  highlightedIndex: changes.highlightedIndex
                };
              }
              return null;
            });
          },
          onChange: selectedItem => {
            if (this.state.startDate && selectedItem) {
              this.emit([this.state.startDate, selectedItem]);
            } else {
              this.emit([]);
            }
          },
          isOpen: this.state.isOpen,
          children: _ref2 => {
            var _context3, _context4;
            let getInputProps = _ref2.getInputProps,
              getMenuProps = _ref2.getMenuProps,
              getItemProps = _ref2.getItemProps,
              getToggleButtonProps = _ref2.getToggleButtonProps,
              clearSelection = _ref2.clearSelection,
              highlightedIndex = _ref2.highlightedIndex,
              openMenu = _ref2.openMenu,
              setHighlightedIndex = _ref2.setHighlightedIndex,
              isOpen = _ref2.isOpen,
              inputValue = _ref2.inputValue;
            const calendarItems = calendarUtils.createCalendarItems(this.state.calendarDate);
            const allItems = [...this.state.suggestedItems, ...calendarItems];
            const paddingDayCount = calendarUtils.getPaddingDayCount(this.state.calendarDate, this.props.intl.locale);
            const paddingDays = _fillInstanceProperty__default["default"](_context3 = Array(paddingDayCount)).call(_context3, undefined);
            const weekdays = calendarUtils.getWeekdayNames(this.props.intl.locale);
            const today = calendarUtils.getToday();
            return jsxRuntime.jsxs("div", {
              onFocus: this.props.onFocus,
              onBlur: this.handleBlur,
              children: [jsxRuntime.jsx(calendarUtils.CalendarBody, {
                inputRef: this.inputRef,
                inputProps: getInputProps(_objectSpread({
                  /* ARIA */
                  'aria-invalid': this.props['aria-invalid'],
                  'aria-errormessage': this.props['aria-errormessage'],
                  // Unset the aria-labelledby as it interfers with the link
                  // between the <label for> and the <input id>.
                  'aria-labelledby': undefined,
                  name: this.props.name,
                  placeholder: typeof this.props.placeholder === 'string' ? this.props.placeholder : _concatInstanceProperty__default["default"](_context4 = "".concat(calendarTimeUtils.getLocalizedDateTimeFormatPattern(this.props.intl.locale), " - ")).call(_context4, calendarTimeUtils.getLocalizedDateTimeFormatPattern(this.props.intl.locale)),
                  onMouseEnter: () => {
                    // we remove the highlight so that the user can use the
                    // arrow keys to move the cursor when hovering
                    // @ts-ignore
                    if (isOpen) setHighlightedIndex(null);
                  },
                  onKeyDown: event => {
                    if (this.props.isReadOnly) {
                      preventDownshiftDefault(event);
                      return;
                    }
                    if (event.key === 'Enter' && (inputValue === null || inputValue === void 0 ? void 0 : _trimInstanceProperty__default["default"](inputValue).call(inputValue)) === '' &&
                    // do not clear value when user presses Enter to
                    // select the end date (so only clear when there is no
                    // startDate)
                    !this.state.startDate && this.props.isClearable) {
                      clearSelection();
                      this.emit([]);
                    }
                    // ArrowDown
                    if (event.key === 'ArrowDown') {
                      if (highlightedIndex + 1 >= calendarItems.length) {
                        // if it's the end of the month
                        // then bypass normal arrow navigation
                        preventDownshiftDefault(event);
                        // then jump to start of next month
                        this.jumpMonth(1, 0);
                      }
                    }
                    // ArrowUp
                    if (event.key === 'ArrowUp') {
                      const previousDay = calendarUtils.getPreviousDay(calendarItems[highlightedIndex]);
                      if (highlightedIndex <= 0) {
                        // if it's the start of the month
                        // then bypass normal arrow navigation
                        preventDownshiftDefault(event);
                        const numberOfDaysOfPrevMonth = calendarUtils.getDaysInMonth(previousDay);
                        // then jump to the last day of the previous month
                        this.jumpMonth(-1, numberOfDaysOfPrevMonth - 1);
                      }
                    }
                  },
                  // we only do this for readOnly because the input
                  // doesn't ignore these events, unlike when its disabled
                  onClick: this.props.isReadOnly ? undefined : openMenu
                }, utils.filterDataAttributes(this.props))),
                hasSelection: this.props.value.length === 2,
                isClearable: this.props.isClearable,
                onClear: () => {
                  this.setState({
                    startDate: null
                  });
                  this.emit([]);
                  clearSelection();
                },
                isOpen: isOpen,
                isDisabled: this.props.isDisabled,
                isReadOnly: this.props.isReadOnly,
                toggleButtonProps: getToggleButtonProps(),
                hasError: this.props.hasError,
                hasWarning: this.props.hasWarning
              }), isOpen && !this.props.isDisabled && jsxRuntime.jsxs(calendarUtils.CalendarMenu, _objectSpread(_objectSpread({}, getMenuProps()), {}, {
                hasError: this.props.hasError,
                hasWarning: this.props.hasWarning,
                children: [jsxRuntime.jsx(calendarUtils.CalendarHeader, {
                  monthLabel: calendarUtils.getMonthCalendarLabel(this.state.calendarDate, this.props.intl.locale),
                  yearLabel: calendarUtils.getYearCalendarLabel(this.state.calendarDate, this.props.intl.locale),
                  onPrevMonthClick: () => this.jumpMonth(-1),
                  onTodayClick: this.showToday,
                  onNextMonthClick: () => this.jumpMonth(1),
                  onPrevYearClick: () => this.jumpMonth(-12),
                  onNextYearClick: () => this.jumpMonth(12)
                }), jsxRuntime.jsxs(calendarUtils.CalendarContent, {
                  children: [_mapInstanceProperty__default["default"](weekdays).call(weekdays, weekday => jsxRuntime.jsx(calendarUtils.CalendarDay, {
                    type: "heading",
                    children: weekday
                  }, weekday)), _mapInstanceProperty__default["default"](paddingDays).call(paddingDays, (_, index) => jsxRuntime.jsx(calendarUtils.CalendarDay, {
                    type: "spacing"
                  }, index)), _mapInstanceProperty__default["default"](calendarItems).call(calendarItems, (item, index) => {
                    const isHighlighted = this.state.suggestedItems.length + index === highlightedIndex;
                    const _getRange = getRange({
                        item,
                        value: this.props.value,
                        startDate: this.state.startDate,
                        highlightedItem: allItems[this.state.highlightedIndex || 0]
                      }),
                      isRangeStart = _getRange.isRangeStart,
                      isRangeBetween = _getRange.isRangeBetween,
                      isRangeEnd = _getRange.isRangeEnd;
                    return jsxRuntime.jsx(calendarUtils.CalendarDay, _objectSpread(_objectSpread({
                      isToday: calendarUtils.isSameDay(today, item)
                    }, getItemProps({
                      disabled: this.props.isDisabled,
                      item,
                      onMouseOut: () => {
                        // @ts-ignore
                        setHighlightedIndex(null);
                      }
                    })), {}, {
                      isHighlighted: isHighlighted,
                      isRangeStart: isRangeStart,
                      isRangeBetween: isRangeBetween,
                      isRangeEnd: isRangeEnd,
                      children: calendarUtils.getCalendarDayLabel(item)
                    }), item);
                  })]
                })]
              }))]
            });
          }
        }, this.props.intl.locale)
      });
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      // We need to update the input value string in case so that is is formatted
      // according to the locale and holds the current value in case the value
      // changes or when the locale changes
      const shouldUpdateInputValue = !isSameRange(props.value, state.prevValue) || props.intl.locale !== state.prevLocale;
      if (!shouldUpdateInputValue) return null;
      return {
        prevLocale: props.intl.locale,
        // This is not the input value but the actual value passed to
        // DateRangeInput
        prevValue: props.value,
        inputValue: calendarUtils.formatRange(props.value, props.intl.locale)
      };
    }
  }]);
  return DateRangeInput;
}(react.Component);
DateRangeInput.displayName = 'DateRangeInput';
DateRangeInput.defaultProps = {
  isClearable: true
};
DateRangeInput.isEmpty = range => range.length === 0;
DateRangeInput.propTypes = {};
var dateRangeInput = reactIntl.injectIntl(DateRangeInput);

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

exports["default"] = dateRangeInput;
exports.version = version;
