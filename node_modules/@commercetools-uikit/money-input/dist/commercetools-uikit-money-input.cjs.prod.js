'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var _slicedToArray = require('@babel/runtime-corejs3/helpers/slicedToArray');
var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
var _objectWithoutProperties = require('@babel/runtime-corejs3/helpers/objectWithoutProperties');
var _styled = require('@emotion/styled/base');
var _pt = require('prop-types');
var _lastIndexOfInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/last-index-of');
var _parseFloat = require('@babel/runtime-corejs3/core-js-stable/parse-float');
var _Math$trunc = require('@babel/runtime-corejs3/core-js-stable/math/trunc');
var _indexOfInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/index-of');
var _parseInt = require('@babel/runtime-corejs3/core-js-stable/parse-int');
var _trimInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/trim');
var _mapInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/map');
var _findInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/find');
var _concatInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/concat');
var react$1 = require('react');
var ReactDOM = require('react-dom');
require('lodash/has');
var Select = require('react-select');
var reactIntl = require('react-intl');
var react = require('@emotion/react');
var designSystem = require('@commercetools-uikit/design-system');
var utils = require('@commercetools-uikit/utils');
var Tooltip = require('@commercetools-uikit/tooltip');
var selectUtils = require('@commercetools-uikit/select-utils');
var icons = require('@commercetools-uikit/icons');
var Constraints = require('@commercetools-uikit/constraints');
var hooks = require('@commercetools-uikit/hooks');
var inputUtils = require('@commercetools-uikit/input-utils');
var jsxRuntime = require('@emotion/react/jsx-runtime');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var _styled__default = /*#__PURE__*/_interopDefault(_styled);
var _pt__default = /*#__PURE__*/_interopDefault(_pt);
var _lastIndexOfInstanceProperty__default = /*#__PURE__*/_interopDefault(_lastIndexOfInstanceProperty);
var _parseFloat__default = /*#__PURE__*/_interopDefault(_parseFloat);
var _Math$trunc__default = /*#__PURE__*/_interopDefault(_Math$trunc);
var _indexOfInstanceProperty__default = /*#__PURE__*/_interopDefault(_indexOfInstanceProperty);
var _parseInt__default = /*#__PURE__*/_interopDefault(_parseInt);
var _trimInstanceProperty__default = /*#__PURE__*/_interopDefault(_trimInstanceProperty);
var _mapInstanceProperty__default = /*#__PURE__*/_interopDefault(_mapInstanceProperty);
var _findInstanceProperty__default = /*#__PURE__*/_interopDefault(_findInstanceProperty);
var _concatInstanceProperty__default = /*#__PURE__*/_interopDefault(_concatInstanceProperty);
var ReactDOM__default = /*#__PURE__*/_interopDefault(ReactDOM);
var Select__default = /*#__PURE__*/_interopDefault(Select);
var Tooltip__default = /*#__PURE__*/_interopDefault(Tooltip);
var Constraints__default = /*#__PURE__*/_interopDefault(Constraints);

var currencies = {
	ADP: {
		fractionDigits: 0
	},
	AED: {
		fractionDigits: 2
	},
	AFA: {
		fractionDigits: 2
	},
	AFN: {
		fractionDigits: 2
	},
	ALL: {
		fractionDigits: 2
	},
	AMD: {
		fractionDigits: 2
	},
	ANG: {
		fractionDigits: 2
	},
	AOA: {
		fractionDigits: 2
	},
	ARS: {
		fractionDigits: 2
	},
	ATS: {
		fractionDigits: 2
	},
	AUD: {
		fractionDigits: 2
	},
	AWG: {
		fractionDigits: 2
	},
	AYM: {
		fractionDigits: 2
	},
	AZM: {
		fractionDigits: 2
	},
	AZN: {
		fractionDigits: 2
	},
	BAM: {
		fractionDigits: 2
	},
	BBD: {
		fractionDigits: 2
	},
	BDT: {
		fractionDigits: 2
	},
	BEF: {
		fractionDigits: 0
	},
	BGL: {
		fractionDigits: 2
	},
	BGN: {
		fractionDigits: 2
	},
	BHD: {
		fractionDigits: 3
	},
	BIF: {
		fractionDigits: 0
	},
	BMD: {
		fractionDigits: 2
	},
	BND: {
		fractionDigits: 2
	},
	BOB: {
		fractionDigits: 2
	},
	BOV: {
		fractionDigits: 2
	},
	BRL: {
		fractionDigits: 2
	},
	BSD: {
		fractionDigits: 2
	},
	BTN: {
		fractionDigits: 2
	},
	BWP: {
		fractionDigits: 2
	},
	BYB: {
		fractionDigits: 0
	},
	BYR: {
		fractionDigits: 0
	},
	BZD: {
		fractionDigits: 2
	},
	CAD: {
		fractionDigits: 2
	},
	CDF: {
		fractionDigits: 2
	},
	CHF: {
		fractionDigits: 2
	},
	CLF: {
		fractionDigits: 0
	},
	CLP: {
		fractionDigits: 0
	},
	CNY: {
		fractionDigits: 2
	},
	COP: {
		fractionDigits: 2
	},
	CRC: {
		fractionDigits: 2
	},
	CSD: {
		fractionDigits: 2
	},
	CUC: {
		fractionDigits: 2
	},
	CUP: {
		fractionDigits: 2
	},
	CVE: {
		fractionDigits: 2
	},
	CYP: {
		fractionDigits: 2
	},
	CZK: {
		fractionDigits: 2
	},
	DEM: {
		fractionDigits: 2
	},
	DJF: {
		fractionDigits: 0
	},
	DKK: {
		fractionDigits: 2
	},
	DOP: {
		fractionDigits: 2
	},
	DZD: {
		fractionDigits: 2
	},
	EEK: {
		fractionDigits: 2
	},
	EGP: {
		fractionDigits: 2
	},
	ERN: {
		fractionDigits: 2
	},
	ESP: {
		fractionDigits: 0
	},
	ETB: {
		fractionDigits: 2
	},
	EUR: {
		fractionDigits: 2
	},
	FIM: {
		fractionDigits: 2
	},
	FJD: {
		fractionDigits: 2
	},
	FKP: {
		fractionDigits: 2
	},
	FRF: {
		fractionDigits: 2
	},
	GBP: {
		fractionDigits: 2
	},
	GEL: {
		fractionDigits: 2
	},
	GHC: {
		fractionDigits: 2
	},
	GHS: {
		fractionDigits: 2
	},
	GIP: {
		fractionDigits: 2
	},
	GMD: {
		fractionDigits: 2
	},
	GNF: {
		fractionDigits: 0
	},
	GRD: {
		fractionDigits: 0
	},
	GTQ: {
		fractionDigits: 2
	},
	GWP: {
		fractionDigits: 2
	},
	GYD: {
		fractionDigits: 2
	},
	HKD: {
		fractionDigits: 2
	},
	HNL: {
		fractionDigits: 2
	},
	HRK: {
		fractionDigits: 2
	},
	HTG: {
		fractionDigits: 2
	},
	HUF: {
		fractionDigits: 2
	},
	IDR: {
		fractionDigits: 2
	},
	IEP: {
		fractionDigits: 2
	},
	ILS: {
		fractionDigits: 2
	},
	INR: {
		fractionDigits: 2
	},
	IQD: {
		fractionDigits: 3
	},
	IRR: {
		fractionDigits: 2
	},
	ISK: {
		fractionDigits: 0
	},
	ITL: {
		fractionDigits: 0
	},
	JMD: {
		fractionDigits: 2
	},
	JOD: {
		fractionDigits: 3
	},
	JPY: {
		fractionDigits: 0
	},
	KES: {
		fractionDigits: 2
	},
	KGS: {
		fractionDigits: 2
	},
	KHR: {
		fractionDigits: 2
	},
	KMF: {
		fractionDigits: 0
	},
	KPW: {
		fractionDigits: 2
	},
	KRW: {
		fractionDigits: 0
	},
	KWD: {
		fractionDigits: 3
	},
	KYD: {
		fractionDigits: 2
	},
	KZT: {
		fractionDigits: 2
	},
	LAK: {
		fractionDigits: 2
	},
	LBP: {
		fractionDigits: 2
	},
	LKR: {
		fractionDigits: 2
	},
	LRD: {
		fractionDigits: 2
	},
	LSL: {
		fractionDigits: 2
	},
	LTL: {
		fractionDigits: 2
	},
	LUF: {
		fractionDigits: 0
	},
	LVL: {
		fractionDigits: 2
	},
	LYD: {
		fractionDigits: 3
	},
	MAD: {
		fractionDigits: 2
	},
	MDL: {
		fractionDigits: 2
	},
	MGA: {
		fractionDigits: 2
	},
	MGF: {
		fractionDigits: 0
	},
	MKD: {
		fractionDigits: 2
	},
	MMK: {
		fractionDigits: 2
	},
	MNT: {
		fractionDigits: 2
	},
	MOP: {
		fractionDigits: 2
	},
	MRO: {
		fractionDigits: 2
	},
	MTL: {
		fractionDigits: 2
	},
	MUR: {
		fractionDigits: 2
	},
	MVR: {
		fractionDigits: 2
	},
	MWK: {
		fractionDigits: 2
	},
	MXN: {
		fractionDigits: 2
	},
	MXV: {
		fractionDigits: 2
	},
	MYR: {
		fractionDigits: 2
	},
	MZM: {
		fractionDigits: 2
	},
	MZN: {
		fractionDigits: 2
	},
	NAD: {
		fractionDigits: 2
	},
	NGN: {
		fractionDigits: 2
	},
	NIO: {
		fractionDigits: 2
	},
	NLG: {
		fractionDigits: 2
	},
	NOK: {
		fractionDigits: 2
	},
	NPR: {
		fractionDigits: 2
	},
	NZD: {
		fractionDigits: 2
	},
	OMR: {
		fractionDigits: 3
	},
	PAB: {
		fractionDigits: 2
	},
	PEN: {
		fractionDigits: 2
	},
	PGK: {
		fractionDigits: 2
	},
	PHP: {
		fractionDigits: 2
	},
	PKR: {
		fractionDigits: 2
	},
	PLN: {
		fractionDigits: 2
	},
	PTE: {
		fractionDigits: 0
	},
	PYG: {
		fractionDigits: 0
	},
	QAR: {
		fractionDigits: 2
	},
	ROL: {
		fractionDigits: 2
	},
	RON: {
		fractionDigits: 2
	},
	RSD: {
		fractionDigits: 2
	},
	RUB: {
		fractionDigits: 2
	},
	RUR: {
		fractionDigits: 2
	},
	RWF: {
		fractionDigits: 0
	},
	SAR: {
		fractionDigits: 2
	},
	SBD: {
		fractionDigits: 2
	},
	SCR: {
		fractionDigits: 2
	},
	SDD: {
		fractionDigits: 2
	},
	SDG: {
		fractionDigits: 2
	},
	SEK: {
		fractionDigits: 2
	},
	SGD: {
		fractionDigits: 2
	},
	SHP: {
		fractionDigits: 2
	},
	SIT: {
		fractionDigits: 2
	},
	SKK: {
		fractionDigits: 2
	},
	SLL: {
		fractionDigits: 2
	},
	SOS: {
		fractionDigits: 2
	},
	SRD: {
		fractionDigits: 2
	},
	SRG: {
		fractionDigits: 2
	},
	SSP: {
		fractionDigits: 2
	},
	STD: {
		fractionDigits: 2
	},
	SVC: {
		fractionDigits: 2
	},
	SYP: {
		fractionDigits: 2
	},
	SZL: {
		fractionDigits: 2
	},
	THB: {
		fractionDigits: 2
	},
	TJS: {
		fractionDigits: 2
	},
	TMM: {
		fractionDigits: 2
	},
	TMT: {
		fractionDigits: 2
	},
	TND: {
		fractionDigits: 3
	},
	TOP: {
		fractionDigits: 2
	},
	TPE: {
		fractionDigits: 0
	},
	TRL: {
		fractionDigits: 0
	},
	TRY: {
		fractionDigits: 2
	},
	TTD: {
		fractionDigits: 2
	},
	TWD: {
		fractionDigits: 2
	},
	TZS: {
		fractionDigits: 2
	},
	UAH: {
		fractionDigits: 2
	},
	UGX: {
		fractionDigits: 0
	},
	USD: {
		fractionDigits: 2
	},
	USN: {
		fractionDigits: 2
	},
	USS: {
		fractionDigits: 2
	},
	UYU: {
		fractionDigits: 2
	},
	UZS: {
		fractionDigits: 2
	},
	VEB: {
		fractionDigits: 2
	},
	VEF: {
		fractionDigits: 2
	},
	VND: {
		fractionDigits: 0
	},
	VUV: {
		fractionDigits: 0
	},
	WST: {
		fractionDigits: 2
	},
	XAF: {
		fractionDigits: 0
	},
	XAG: {
		fractionDigits: -1
	},
	XAU: {
		fractionDigits: -1
	},
	XBA: {
		fractionDigits: -1
	},
	XBB: {
		fractionDigits: -1
	},
	XBC: {
		fractionDigits: -1
	},
	XBD: {
		fractionDigits: -1
	},
	XCD: {
		fractionDigits: 2
	},
	XDR: {
		fractionDigits: -1
	},
	XFO: {
		fractionDigits: -1
	},
	XFU: {
		fractionDigits: -1
	},
	XOF: {
		fractionDigits: 0
	},
	XPD: {
		fractionDigits: -1
	},
	XPF: {
		fractionDigits: 0
	},
	XPT: {
		fractionDigits: -1
	},
	XSU: {
		fractionDigits: -1
	},
	XTS: {
		fractionDigits: -1
	},
	XUA: {
		fractionDigits: -1
	},
	XXX: {
		fractionDigits: -1
	},
	YER: {
		fractionDigits: 2
	},
	YUM: {
		fractionDigits: 2
	},
	ZAR: {
		fractionDigits: 2
	},
	ZMK: {
		fractionDigits: 2
	},
	ZMW: {
		fractionDigits: 2
	},
	ZWD: {
		fractionDigits: 2
	},
	ZWL: {
		fractionDigits: 2
	},
	ZWN: {
		fractionDigits: 2
	},
	ZWR: {
		fractionDigits: 2
	}
};

const getLanguageLabelBackgroundColor = props => {
  if (props.isDisabled) {
    return designSystem.designTokens.backgroundColorForLocalizedInputLabelWhenDisabled;
  }
  if (props.isReadOnly) {
    return designSystem.designTokens.backgroundColorForLocalizedInputLabelWhenReadonly;
  }
  return designSystem.designTokens.backgroundColorForLocalizedInputLabel;
};
const getCurrencyLabelStyles = props => /*#__PURE__*/react.css("display:flex;color:", designSystem.designTokens.fontColorForInputWhenDisabled, ";cursor:", props.isDisabled ? 'not-allowed' : 'default', ";background-color:", getLanguageLabelBackgroundColor(props), ";border-top-left-radius:", designSystem.designTokens.borderRadiusForInput, ";border-bottom-left-radius:", designSystem.designTokens.borderRadiusForInput, ";border:1px solid ", props.isReadOnly ? designSystem.designTokens.borderColorForInputWhenReadonly : designSystem.designTokens.borderColorForInputWhenDisabled, ";border-right:0;padding:", designSystem.designTokens.paddingForMoneyInputCurrencyDropdown, ";align-items:center;font-size:", designSystem.designTokens.fontSizeForLocalizedInputLabel, ";box-sizing:border-box;&:focus-within:{border-width:1px;}" + ("" ), "" );
const getAmountInputStyles = props => [inputUtils.getInputStyles(props), /*#__PURE__*/react.css("border-top-left-radius:0;border-bottom-left-radius:0;margin-left:0;&::placeholder{color:", designSystem.designTokens.placeholderFontColorForInput, ";}" + ("" ), "" )];
const getHighPrecisionWrapperStyles = _ref => {
  let isDisabled = _ref.isDisabled;
  return /*#__PURE__*/react.css("position:absolute;top:0;right:0;margin-right:", designSystem.designTokens.marginRightForMoneyInputPrecisionBadge, ";height:100%;display:flex;align-items:center;cursor:", isDisabled ? 'not-allowed' : 'default', ";justify-content:center;" + ("" ), "" );
};

var messages = reactIntl.defineMessages({
  highPrecision: {
    id: 'UIKit.MoneyInput.highPrecision',
    description: 'Label of high precision tooltip in MoneyInput',
    defaultMessage: 'High Precision Price'
  }
});

const _excluded = ["id"];
function ownKeys(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context14, _context15; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context14 = ownKeys(Object(source), !0)).call(_context14, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context15 = ownKeys(Object(source))).call(_context15, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const TooltipWrapper = /*#__PURE__*/_styled__default["default"]("div", {
  target: "e1u90zjc0"
} )({
  name: "zjik7",
  styles: "display:flex"
} );
const moneyInputSequentialId = utils.createSequentialId('money-input-');
const getPortalId = id => "portal-".concat(id);
const getPortalNode = id => document.querySelector("#".concat(getPortalId(id)));
const Portal = props => {
  const domNode = getPortalNode(props.id);
  if (domNode) {
    return /*#__PURE__*/ReactDOM__default["default"].createPortal(props.children, domNode);
  }
  return null;
};
Portal.propTypes = {
  id: _pt__default["default"].string.isRequired,
  children: _pt__default["default"].node,
  isDisabled: _pt__default["default"].bool,
  isReadOnly: _pt__default["default"].bool
};
const CurrencyLabel = props => jsxRuntime.jsx("label", {
  htmlFor: props.id,
  css: getCurrencyLabelStyles(props),
  children: props.children
});
CurrencyLabel.propTypes = {};
CurrencyLabel.displayName = 'CurrencyLabel';
const SingleValue = _ref3 => {
  let id = _ref3.id,
    props = _objectWithoutProperties(_ref3, _excluded);
  return jsxRuntime.jsx(Select.components.SingleValue, _objectSpread(_objectSpread({}, props), {}, {
    children: jsxRuntime.jsx("label", {
      htmlFor: id,
      children: props.children
    })
  }));
};
SingleValue.propTypes = {};
SingleValue.displayName = 'SingleValue';
// overwrite styles of createSelectStyles
const createCurrencySelectStyles = _ref4 => {
  let hasWarning = _ref4.hasWarning,
    hasError = _ref4.hasError,
    isDisabled = _ref4.isDisabled,
    isReadOnly = _ref4.isReadOnly,
    menuPortalZIndex = _ref4.menuPortalZIndex,
    currencyHasFocus = _ref4.currencyHasFocus;
  const selectStyles = selectUtils.createSelectStyles({
    hasWarning,
    hasError,
    menuPortalZIndex,
    isReadOnly,
    isDisabled
  });
  return _objectSpread(_objectSpread({}, selectStyles), {}, {
    control: (base, state) => _objectSpread(_objectSpread({}, selectStyles.control(base, state)), {}, {
      padding: designSystem.designTokens.paddingForMoneyInputCurrencyDropdown,
      borderTopRightRadius: '0',
      borderBottomRightRadius: '0',
      borderRight: '0',
      minWidth: designSystem.designTokens.minWidthForMoneyInputCurrencyDropdown,
      height: '100%',
      borderColor: (() => {
        if (isDisabled) return "".concat(designSystem.designTokens.borderColorForInputWhenDisabled, " !important");
        if (isReadOnly) return "".concat(designSystem.designTokens.borderColorForInputWhenReadonly, " !important");
        if (hasError) return designSystem.designTokens.borderColorForInputWhenError;
        if (hasWarning) return designSystem.designTokens.borderColorForInputWhenWarning;
        if (currencyHasFocus) {
          return designSystem.designTokens.borderColorForInputWhenFocused;
        }
        return designSystem.designTokens.borderColorForInput;
      })(),
      cursor: (() => {
        if (isDisabled) return 'not-allowed';
        if (isReadOnly) return "default";
        return 'pointer';
      })(),
      backgroundColor: (() => {
        if (isReadOnly) return designSystem.designTokens.backgroundColorForInputWhenReadonly;
        return base.backgroundColor;
      })(),
      '&:hover': {
        borderColor: designSystem.designTokens.borderColorForInput
      },
      '&:hover:not(:read-only):not(:disabled)': {
        backgroundColor: designSystem.designTokens.backgroundColorForInputWhenHovered
      }
    }),
    singleValue: base => _objectSpread(_objectSpread({}, base), {}, {
      marginLeft: 0,
      maxWidth: 'initial',
      color: (() => {
        if (isDisabled) return designSystem.designTokens.fontColorForInputWhenDisabled;
        if (hasError) return designSystem.designTokens.fontColorForInputWhenError;
        if (hasWarning) return designSystem.designTokens.fontColorForInputWhenWarning;
        if (isReadOnly) return designSystem.designTokens.fontColorForInputWhenReadonly;
        return base.color;
      })()
    }),
    dropdownIndicator: () => ({
      fill: isReadOnly ? designSystem.designTokens.fontColorForInputWhenReadonly : designSystem.designTokens.fontColorForMoneyInputCurrencyDropdownIndicator
    })
  });
};
// The MoneyInput component always operates on a value consisting of:
// ```
// { amount: String, currencyCode: String }
// ```
//
// The amount may only use a dot as the decimal separator.
// The `currencyCode` must be supported by the API.
//
// The `MoneyInput` does not do any validation on its own. It only serves as a way
// to get the amount and `currencyCode` input from the user. Validation is always
// up to the parent.
//
// The CTP API supports two types of prices: `centPrecision` and `highPrecision`.
// The `MoneyInput` itself does not know about these. However,
// it has two static methods defined (`convertToMoneyValue` and `parseMoneyValue`),
// which can be used to convert between `MoneyInput` value and the `MoneyValue`
// supported by the API.
// Some places in the API do not support `highPrecision` prices, but the
// `convertToMoneyValue `will always return either a `centPrecision `or a
// `highPrecision` price. It's up the `MoneyInput`'s parent to show a validation
// error in case a `highPrecision` price is used.
//
// A value is considered as to have `highPrecision` when the number of supplied
// fraction digits exceed the number of fraction digits the currency uses. For
// example, `EUR 42.00` is always a `centPrecision` price, while `EUR 42.001` is always a
// `highPrecision` price. It is not possible to have `EUR 42.00` as a `highPrecision`
// price.
//
// The first time the component renders, we want to try to show the `centAmount`
// as a formatted number. To achieve this, the `parseMoneyValue` function can
// be used to turn the API value into a value the `MoneyInput` understands.
// During this transformation, the money value will get formatted into "amount".
//
// When the user changes the value, we don't want to format again. We only format
// in case the user blurs the field. This avoids many edge cases where the
// formatting would mess with the user's input.
//
//
// A full example of an `MoneyValue` with `centPrecision` would be
// ```
// {
//   "type": "centPrecision",
//   "currencyCode": "EUR",
//   "centAmount": 4200,
//   "fractionDigits": 2
// }
// ```
// which equals `EUR 42.00`.
//
// A full example of an `MoneyValue` with `highPrecision` would be
// ```
// {
//  "type": "highPrecision",
//  "currencyCode": "EUR",
//  "centAmount": 1,
//  "preciseAmount": 123456,
//  "fractionDigits": 7
// }
// ```
// which equals `EUR 0.0123456`

// Parsing
// Since most users are not careful about how they enter values, we will parse
// both `.` and `,` as decimal separators.
// When a value is `1.000,00` we parse it as `1000`.
// When a value is `1,000.00` we also parse it as `1000`.
//
// This means the highest amount always wins. We do this by comparing the last
// position of `.` and `,`. Whatever occurs later is used as the decimal separator.
const parseRawAmountToNumber = (rawAmount, locale) => {
  let fractionsSeparator;
  if (locale) {
    fractionsSeparator = 2.5 // we need any number with fractions, so that we know what is the fraction
    .toLocaleString(locale) // "symbol" for the provided locale
    .replace(/\d/g, ''); // then we remove the numbers and keep the "symbol"
  } else {
    var _context, _context2;
    const lastDot = _lastIndexOfInstanceProperty__default["default"](_context = String(rawAmount)).call(_context, '.');
    const lastComma = _lastIndexOfInstanceProperty__default["default"](_context2 = String(rawAmount)).call(_context2, ',');
    fractionsSeparator = lastComma > lastDot ? ',' : '.';
  }
  fractionsSeparator = fractionsSeparator === '.' ? '\\.' : fractionsSeparator; // here we escape the '.' to use it as regex
  // The raw amount with only one sparator
  const normalizedAmount = String(rawAmount).replace(new RegExp("[^-0-9".concat(fractionsSeparator, "]"), 'g'), '') // we just keep the numbers and the fraction symbol
  .replace(fractionsSeparator, '.'); // then we change whatever `fractionsSeparator` was to `.` so we can parse it as float

  return _parseFloat__default["default"](normalizedAmount);
};

// Turns the user input into a value the MoneyInput can pass up through onChange
// In case the number of fraction digits contained in "amount" exceeds the
// number of fraction digits the currency uses, it will emit a price of
// type "highPrecision" instead of the regular "centPrecision".
// It will return "null" in case an invalid value is entered.
// The value is invalid when
//  - no amount was entered
//  - an invalid amount was entered
//  - no currency was selected
//
// This function expects the "amount" to be a trimmed value.

const createMoneyValue = (rawAmount, locale, currencyCode) => {
  var _context3, _context4;
  if (!currencyCode) return null;
  const currency = currencies[currencyCode];
  if (!currency) return null;
  if (rawAmount.length === 0 || !utils.isNumberish(rawAmount)) return null;
  const amountAsNumber = parseRawAmountToNumber(rawAmount, locale);
  if (isNaN(amountAsNumber)) return null;

  // The cent amount is rounded to the currencie's default number
  // of fraction digits for prices with high precision.
  //
  // Additionally, JavaScript is sometimes incorrect when multiplying floats,
  //   e.g. 2.49 * 100 -> 249.00000000000003
  // While inaccuracy from multiplying floating point numbers is a
  // general problem in JS, we can avoid it by cutting off all
  // decimals. This is possible since cents is the base unit, so we
  // operate on integers anyways
  // Also we should the round the value to ensure that we come close
  // to the nearest decimal value
  // ref: https://github.com/commercetools/merchant-center-frontend/pull/770
  const centAmount = _Math$trunc__default["default"](Math.round(amountAsNumber * 10 ** currency.fractionDigits));
  const fractionDigitsOfAmount =
  // The conversion to a string will always use a dot as the separator.
  // That means we don't have to handle a comma.
  _indexOfInstanceProperty__default["default"](_context3 = String(amountAsNumber)).call(_context3, '.') === -1 ? 0 : String(amountAsNumber).length - _indexOfInstanceProperty__default["default"](_context4 = String(amountAsNumber)).call(_context4, '.') - 1;
  if (fractionDigitsOfAmount > currency.fractionDigits) {
    return {
      type: 'highPrecision',
      currencyCode,
      centAmount,
      preciseAmount: _parseInt__default["default"](
      // Here we need to convert  a number like 8.066652 to its centamount
      // We could do that by multiplying it with 10 ** number-of-fraction-digits
      // but then we'll run into problems with JavaScript's floating point
      // number precision and end up with 8066651.9999999, and then parseInt
      // cuts off the remainder.
      // So instead of using maths to convert the number, we just replace
      // the dot inside the number which does the same thing.
      // We don't need to replace "," as well, as numbers always us a dot
      // when converted using String().
      //
      // The mathematical way: amountAsNumber * 10 ** fractionDigitsOfAmount,
      String(amountAsNumber).replace('.', ''), 10),
      fractionDigits: fractionDigitsOfAmount
    };
  }
  return {
    type: 'centPrecision',
    currencyCode,
    centAmount,
    fractionDigits: currency.fractionDigits
  };
};
const createEmptyMoneyValue = currencyCode => ({
  type: 'centPrecision',
  currencyCode,
  centAmount: NaN,
  fractionDigits: 2
});
const getAmountAsNumberFromMoneyValue = moneyValue => moneyValue.type === 'highPrecision' ? moneyValue.preciseAmount / 10 ** moneyValue.fractionDigits : moneyValue.centAmount / 10 ** currencies[moneyValue.currencyCode].fractionDigits;

// gets called with a string and should return a formatted string
const formatAmount = (rawAmount, locale, currencyCode) => {
  // fallback in case the user didn't enter an amount yet (or it's invalid)
  const moneyValue = createMoneyValue(rawAmount, locale, currencyCode) || createEmptyMoneyValue(currencyCode);
  const amount = getAmountAsNumberFromMoneyValue(moneyValue);
  const fractionDigits = moneyValue.preciseAmount ? moneyValue.fractionDigits : currencies[moneyValue.currencyCode].fractionDigits;
  return isNaN(amount) ? '' : amount.toLocaleString(locale, {
    minimumFractionDigits: fractionDigits
  });
};
const getAmountInputName = name => name ? "".concat(name, ".amount") : undefined;
const getCurrencyDropdownName = name => name ? "".concat(name, ".currencyCode") : undefined;
const defaultProps = {
  currencies: [],
  horizontalConstraint: 'scale',
  menuPortalZIndex: 1
};
var _ref = {
  name: "pw7jst",
  styles: "position:relative;width:100%"
} ;
var _ref2 = {
  name: "xqiz9q",
  styles: "font-family:inherit;width:100%;position:relative;display:flex"
} ;
const MoneyInput = props => {
  var _context7, _context9, _context10;
  const intl = reactIntl.useIntl();
  const _useToggleState = hooks.useToggleState(false),
    _useToggleState2 = _slicedToArray(_useToggleState, 2),
    currencyHasFocus = _useToggleState2[0],
    toggleCurrencyHasFocus = _useToggleState2[1];
  const _useToggleState3 = hooks.useToggleState(false),
    _useToggleState4 = _slicedToArray(_useToggleState3, 2),
    amountHasFocus = _useToggleState4[0],
    toggleAmountHasFocus = _useToggleState4[1];
  const containerRef = react$1.useRef(null);
  const amountInputRef = react$1.useRef(null);
  const moneyInputId = hooks.useFieldId(props.id, moneyInputSequentialId);
  if (!props.isReadOnly) ;
  selectUtils.warnIfMenuPortalPropsAreMissing({
    menuPortalZIndex: props.menuPortalZIndex,
    menuPortalTarget: props.menuPortalTarget,
    componentName: 'MoneyInput'
  });
  const onFocus = props.onFocus;
  const handleAmountFocus = react$1.useCallback(() => {
    if (onFocus) onFocus({
      target: {
        id: MoneyInput.getAmountInputId(moneyInputId),
        name: getAmountInputName(props.name)
      }
    });
    toggleAmountHasFocus(true);
  }, [toggleAmountHasFocus, onFocus, moneyInputId, props.name]);
  const onChange = props.onChange;
  const handleAmountBlur = react$1.useCallback(() => {
    var _context5;
    const amount = _trimInstanceProperty__default["default"](_context5 = props.value.amount).call(_context5);
    toggleAmountHasFocus(false);
    // Skip formatting for empty value or when the input is used with an
    // unknown currency.
    if (amount.length > 0 && props.value.currencyCode && currencies[props.value.currencyCode]) {
      const formattedAmount = formatAmount(amount, intl.locale, props.value.currencyCode);

      // When the user entered a value with centPrecision, we can format
      // the resulting value to that currency, e.g. 20.1 to 20.10
      if (String(formattedAmount) !== amount) {
        // We need to emit an event with the now formatted value
        const fakeEvent = {
          persist: () => {},
          target: {
            id: MoneyInput.getAmountInputId(moneyInputId),
            name: getAmountInputName(props.name),
            value: formattedAmount
          }
        };
        onChange === null || onChange === void 0 ? void 0 : onChange(fakeEvent);
      }
    }
  }, [intl.locale, onChange, moneyInputId, props.name, props.value.amount, props.value.currencyCode, toggleAmountHasFocus]);
  const handleAmountChange = react$1.useCallback(event => {
    if (utils.isNumberish(event.target.value)) {
      onChange === null || onChange === void 0 ? void 0 : onChange({
        persist: () => {},
        target: {
          id: MoneyInput.getAmountInputId(moneyInputId),
          name: getAmountInputName(props.name),
          value: event.target.value
        }
      });
    }
  }, [onChange, moneyInputId, props.name]);
  const handleCurrencyChange = react$1.useCallback(option => {
    const currencyCode = option.value;
    if (props.value.currencyCode !== currencyCode) {
      var _context6, _amountInputRef$curre;
      // When the user changes from a currency with 3 fraction digits to
      // a currency with 2 fraction digits, and when the input value was
      // "9.000" (9), then it should change to "9.00" to reflect the new
      // currency's number of fraction digits.
      // When the currency was a high-precision price, then no digits should
      // be lost
      const formattedAmount = formatAmount(_trimInstanceProperty__default["default"](_context6 = props.value.amount).call(_context6), intl.locale, currencyCode);
      // The user could be changing the currency before entering any amount,
      // or while the amount is invalid. In these cases, we don't attempt to
      // format the amount.
      const nextAmount = isNaN(Number(formattedAmount)) ? props.value.amount : formattedAmount;

      // change currency code
      const fakeCurrencyEvent = {
        persist: () => {},
        target: {
          id: MoneyInput.getCurrencyDropdownId(moneyInputId),
          name: getCurrencyDropdownName(props.name),
          value: currencyCode || ''
        }
      };
      onChange === null || onChange === void 0 ? void 0 : onChange(fakeCurrencyEvent);

      // change amount if necessary
      if (props.value.amount !== nextAmount) {
        onChange === null || onChange === void 0 ? void 0 : onChange({
          persist: () => {},
          target: {
            id: MoneyInput.getAmountInputId(moneyInputId),
            name: getAmountInputName(props.name),
            value: nextAmount
          }
        });
      }
      (_amountInputRef$curre = amountInputRef.current) === null || _amountInputRef$curre === void 0 ? void 0 : _amountInputRef$curre.focus();
    }
  }, [intl.locale, onChange, moneyInputId, props.name, props.value.amount, props.value.currencyCode]);
  const handleCurrencyFocus = react$1.useCallback(() => {
    if (onFocus) onFocus({
      target: {
        id: MoneyInput.getCurrencyDropdownId(moneyInputId),
        name: getCurrencyDropdownName(props.name)
      }
    });
    toggleCurrencyHasFocus(true);
  }, [onFocus, toggleCurrencyHasFocus, props.name, moneyInputId]);
  const handleCurrencyBlur = react$1.useCallback(() => {
    toggleCurrencyHasFocus(false);
  }, [toggleCurrencyHasFocus]);
  const hasNoCurrencies = props.currencies.length === 0;
  const hasFocus = currencyHasFocus || amountHasFocus;
  const currencySelectStyles = createCurrencySelectStyles({
    hasWarning: props.hasWarning,
    hasError: props.hasError,
    isDisabled: props.isDisabled,
    isReadOnly: props.isReadOnly,
    menuPortalZIndex: props.menuPortalZIndex,
    currencyHasFocus
  });
  const options = _mapInstanceProperty__default["default"](_context7 = props.currencies).call(_context7, currencyCode => ({
    label: currencyCode,
    value: currencyCode
  }));
  const option = (_context8 => {
    const matchedOption = _findInstanceProperty__default["default"](options).call(options, optionCandidate => optionCandidate.value === props.value.currencyCode);
    if (matchedOption) return matchedOption;
    // ensure an option is found, even when the currencies don't include
    // the money value's currencyCode
    if (_trimInstanceProperty__default["default"](_context8 = props.value.currencyCode).call(_context8) !== '') return {
      label: props.value.currencyCode,
      value: props.value.currencyCode
    };
    return null;
  })();
  const isHighPrecision = !MoneyInput.isEmpty(props.value) && MoneyInput.isHighPrecision(props.value, intl.locale);
  const onBlur = props.onBlur;
  const handleContainerBlur = react$1.useCallback(event => {
    var _containerRef$current;
    // ensures that both fields are marked as touched when one of them
    // is blurred
    if (typeof onBlur === 'function' && !((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(event.relatedTarget))) {
      onBlur({
        target: {
          id: MoneyInput.getCurrencyDropdownId(moneyInputId),
          name: getCurrencyDropdownName(props.name)
        }
      });
      onBlur({
        target: {
          id: MoneyInput.getAmountInputId(moneyInputId),
          name: getAmountInputName(props.name)
        }
      });
    }
  }, [onBlur, moneyInputId, props.name]);
  const TooltipPortal = react$1.useCallback(remainingProps => jsxRuntime.jsx(Portal, _objectSpread(_objectSpread({}, remainingProps), {}, {
    id: props.id
  })), [props.id]);
  return jsxRuntime.jsx(Constraints__default["default"].Horizontal, {
    max: props.horizontalConstraint,
    children: jsxRuntime.jsxs("div", {
      ref: containerRef,
      css: _ref2,
      "data-testid": "money-input-container",
      onBlur: handleContainerBlur,
      children: [hasNoCurrencies ? jsxRuntime.jsx(CurrencyLabel, {
        id: MoneyInput.getAmountInputId(moneyInputId),
        isDisabled: props.isDisabled,
        isReadOnly: props.isReadOnly,
        children: option && option.label
      }) : jsxRuntime.jsx(Select__default["default"], {
        inputId: MoneyInput.getCurrencyDropdownId(moneyInputId),
        name: getCurrencyDropdownName(props.name),
        value: option,
        isDisabled: props.isDisabled,
        isSearchable: false,
        components: {
          SingleValue: innerProps => jsxRuntime.jsx(SingleValue, _objectSpread(_objectSpread({}, innerProps), {}, {
            id: MoneyInput.getCurrencyDropdownId(moneyInputId)
          })),
          Input: ownProps => jsxRuntime.jsx(Select.components.Input, _objectSpread(_objectSpread({}, ownProps), {}, {
            readOnly: props.isReadOnly
          })),
          DropdownIndicator: selectUtils.DropdownIndicator
        },
        options: options,
        menuIsOpen: props.isReadOnly ? false : undefined,
        placeholder: "",
        styles: currencySelectStyles,
        onFocus: handleCurrencyFocus,
        menuPortalTarget: props.menuPortalTarget,
        menuShouldBlockScroll: props.menuShouldBlockScroll,
        onBlur: handleCurrencyBlur,
        onChange: handleCurrencyChange,
        "data-testid": "currency-dropdown"
      }), jsxRuntime.jsxs("div", {
        css: _ref,
        children: [jsxRuntime.jsx("input", _objectSpread(_objectSpread({
          ref: amountInputRef,
          id: MoneyInput.getAmountInputId(moneyInputId),
          autoComplete: props.autoComplete,
          name: getAmountInputName(props.name),
          type: "text",
          onFocus: handleAmountFocus,
          value: props.value.amount,
          css: [getAmountInputStyles(_objectSpread(_objectSpread({}, props), {}, {
            hasFocus
          })),
          // accounts for size of icon
          props.hasHighPrecisionBadge && isHighPrecision && /*#__PURE__*/react.css("padding-right:", designSystem.designTokens.spacing40, ";" + ("" ), "" ), currencyHasFocus && !props.isDisabled && !props.isReadOnly && /*#__PURE__*/react.css("border-left-color:", designSystem.designTokens.borderColorForInputWhenFocused, ";" + ("" ), "" ), "" , "" ],
          placeholder: props.placeholder,
          onChange: handleAmountChange,
          onBlur: handleAmountBlur,
          disabled: props.isDisabled,
          readOnly: props.isReadOnly,
          autoFocus: props.isAutofocussed
        }, utils.filterDataAttributes(props)), {}, {
          /* ARIA */
          "aria-invalid": props['aria-invalid'],
          "aria-errormessage": props['aria-errormessage']
        })), props.hasHighPrecisionBadge && isHighPrecision && jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [!props.isDisabled && jsxRuntime.jsx("div", {
            id: getPortalId(props.id)
          }), jsxRuntime.jsx("div", {
            css: () => getHighPrecisionWrapperStyles({
              isDisabled: props.isDisabled
            }),
            children: jsxRuntime.jsx(Tooltip__default["default"], {
              off: props.isDisabled,
              placement: "top-end"
              // we use negative margin to make up for the padding in the Tooltip Wrapper
              // so that the tooltip is flush with the component
              ,
              styles: {
                body: {
                  margin: _concatInstanceProperty__default["default"](_context9 = _concatInstanceProperty__default["default"](_context10 = "".concat(designSystem.designTokens.spacing20, " -")).call(_context10, designSystem.designTokens.spacing10, " ")).call(_context9, designSystem.designTokens.spacing20, " 0")
                }
              },
              title: intl.formatMessage(messages.highPrecision),
              components: {
                TooltipWrapperComponent: TooltipPortal,
                WrapperComponent: TooltipWrapper
              },
              children: jsxRuntime.jsx(icons.FractionDigitsIcon, {
                color: props.isDisabled ? 'neutral60' : 'info'
              })
            })
          })]
        })]
      })]
    })
  });
};
MoneyInput.propTypes = {};
MoneyInput.displayName = 'MoneyInput';
MoneyInput.getAmountInputId = getAmountInputName;
MoneyInput.getCurrencyDropdownId = getCurrencyDropdownName;
MoneyInput.convertToMoneyValue = (value, locale) => {
  var _context11;
  return createMoneyValue(typeof value.amount === 'string' ? _trimInstanceProperty__default["default"](_context11 = value.amount).call(_context11) : '', locale, value.currencyCode);
};
MoneyInput.parseMoneyValue = (moneyValue, locale) => {
  if (!moneyValue) return {
    currencyCode: '',
    amount: ''
  };
  const amount = formatAmount(getAmountAsNumberFromMoneyValue(moneyValue).toLocaleString(locale, {
    minimumFractionDigits: moneyValue.fractionDigits
  }), locale, moneyValue.currencyCode);
  return {
    amount,
    currencyCode: moneyValue.currencyCode
  };
};
MoneyInput.isEmpty = formValue => {
  var _context12, _context13;
  return !formValue || _trimInstanceProperty__default["default"](_context12 = formValue.amount).call(_context12) === '' || _trimInstanceProperty__default["default"](_context13 = formValue.currencyCode).call(_context13) === '';
};
MoneyInput.isHighPrecision = (formValue, locale) => {
  const moneyValue = MoneyInput.convertToMoneyValue(formValue, locale);
  return (moneyValue === null || moneyValue === void 0 ? void 0 : moneyValue.type) === 'highPrecision';
};
MoneyInput.isTouched = touched => Boolean(touched && touched.currencyCode && touched.amount);
MoneyInput.defaultProps = defaultProps;
var MoneyInput$1 = MoneyInput;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

exports["default"] = MoneyInput$1;
exports.version = version;
