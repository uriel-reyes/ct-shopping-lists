import { defineMessages, useIntl } from 'react-intl';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _concatInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/concat';
import { designTokens } from '@commercetools-uikit/design-system';
import { warning } from '@commercetools-uikit/utils';
import _objectWithoutProperties from '@babel/runtime-corejs3/helpers/esm/objectWithoutProperties';
import { css } from '@emotion/react';
import { CloseIcon, CloseBoldIcon, CaretDownIcon, SearchIcon } from '@commercetools-uikit/icons';
import { jsx, jsxs, Fragment } from '@emotion/react/jsx-runtime';
import omit from 'lodash/omit';
import AccessibleButton from '@commercetools-uikit/accessible-button';
import { components } from 'react-select';
import { cloneElement } from 'react';
import Spacings from '@commercetools-uikit/spacings';
import Text from '@commercetools-uikit/text';

var messages$1 = defineMessages({
  clearButtonLabel: {
    id: 'UIKit.ClearButton.clearButtonLabel',
    description: 'Label for the clear button',
    defaultMessage: 'Clear'
  }
});

const _excluded = ["ref", "onMouseDown"];
function ownKeys$6(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys$6(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys$6(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const ClearIndicator = props => {
  const intl = useIntl();
  const getStyles = props.getStyles,
    _props$innerProps = props.innerProps,
    ref = _props$innerProps.ref,
    onMouseDown = _props$innerProps.onMouseDown,
    restInnerProps = _objectWithoutProperties(_props$innerProps, _excluded);
  return jsx("button", _objectSpread$6(_objectSpread$6({}, restInnerProps), {}, {
    ref: ref,
    css: /*#__PURE__*/css("border:none;cursor:pointer;background:none;box-sizing:border-box;text-decoration:none;fill:", designTokens.fontColorForClearInputIcon, ";:hover svg *{fill:", designTokens.fontColorForClearInputIconWhenHovered, ";}" + (process.env.NODE_ENV === "production" ? "" : ";label:ClearIndicator;"), process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNsZWFyLWluZGljYXRvci50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMEJjIiwiZmlsZSI6ImNsZWFyLWluZGljYXRvci50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIExlZ2FjeVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgQ2xlYXJJbmRpY2F0b3JQcm9wcyB9IGZyb20gJ3JlYWN0LXNlbGVjdCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgeyB1c2VJbnRsIH0gZnJvbSAncmVhY3QtaW50bCc7XG5pbXBvcnQgeyBkZXNpZ25Ub2tlbnMgfSBmcm9tICdAY29tbWVyY2V0b29scy11aWtpdC9kZXNpZ24tc3lzdGVtJztcbmltcG9ydCB7IENsb3NlSWNvbiB9IGZyb20gJ0Bjb21tZXJjZXRvb2xzLXVpa2l0L2ljb25zJztcbmltcG9ydCBtZXNzYWdlcyBmcm9tICcuL21lc3NhZ2VzJztcblxudHlwZSBUSW5uZXJQcm9wcyA9IHtcbiAgcmVmOiBMZWdhY3lSZWY8SFRNTEJ1dHRvbkVsZW1lbnQ+O1xufSAmIEpTWC5JbnRyaW5zaWNFbGVtZW50c1snYnV0dG9uJ107XG5cbmV4cG9ydCB0eXBlIFRDbGVhckluZGljYXRvclByb3BzID0ge1xuICBpbm5lclByb3BzOiBUSW5uZXJQcm9wcztcbn0gJiBDbGVhckluZGljYXRvclByb3BzO1xuXG5jb25zdCBDbGVhckluZGljYXRvciA9IChwcm9wczogVENsZWFySW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcbiAgY29uc3Qge1xuICAgIGdldFN0eWxlcyxcbiAgICBpbm5lclByb3BzOiB7IHJlZiwgb25Nb3VzZURvd24sIC4uLnJlc3RJbm5lclByb3BzIH0sXG4gIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICB7Li4ucmVzdElubmVyUHJvcHN9XG4gICAgICByZWY9e3JlZn1cbiAgICAgIGNzcz17Y3NzYFxuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgYmFja2dyb3VuZDogbm9uZTtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICBmaWxsOiAke2Rlc2lnblRva2Vucy5mb250Q29sb3JGb3JDbGVhcklucHV0SWNvbn07XG4gICAgICAgIDpob3ZlciBzdmcgKiB7XG4gICAgICAgICAgZmlsbDogJHtkZXNpZ25Ub2tlbnMuZm9udENvbG9yRm9yQ2xlYXJJbnB1dEljb25XaGVuSG92ZXJlZH07XG4gICAgICAgIH1cbiAgICAgIGB9XG4gICAgICBzdHlsZT17Z2V0U3R5bGVzKCdjbGVhckluZGljYXRvcicsIHByb3BzKSBhcyBDU1NQcm9wZXJ0aWVzfVxuICAgICAgdGl0bGU9e2ludGwuZm9ybWF0TWVzc2FnZShtZXNzYWdlcy5jbGVhckJ1dHRvbkxhYmVsKX1cbiAgICAgIGFyaWEtbGFiZWw9e2ludGwuZm9ybWF0TWVzc2FnZShtZXNzYWdlcy5jbGVhckJ1dHRvbkxhYmVsKX1cbiAgICAgIC8vIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgYGFyaWEtaGlkZGVuYCBwcm9wIHZhbHVlIHRvIG1ha2UgdGhlIGNvbXBvbmVudCBhY2Nlc3NpYmxlIGJ5IGtleWJvYXJkIC0gaHR0cHM6Ly9naXRodWIuY29tL0plZFdhdHNvbi9yZWFjdC1zZWxlY3QvaXNzdWVzLzQ3OTNcbiAgICAgIGFyaWEtaGlkZGVuPXtmYWxzZX1cbiAgICAgIC8vIG9ubHkgb25Nb3VzZURvd24gYW5kIG9uVG91Y2hFbmQgZXZlbnQgaGFuZGxlcnMgYXJlIHBhc3NlZCBieSBgcmVhY3Qtc2VsZWN0YCB0byB0aGUgY29tcG9uZW50IGJ5IGRlZmF1bHQsIHdoaWNoIG1ha2VzIGl0IG5vdCBhY2Nlc3NpYmxlIGJ5IGtleWJvYXJkXG4gICAgICBvbkNsaWNrPXtvbk1vdXNlRG93bn1cbiAgICA+XG4gICAgICA8Q2xvc2VJY29uIHNpemU9XCJtZWRpdW1cIiAvPlxuICAgIDwvYnV0dG9uPlxuICApO1xufTtcblxuQ2xlYXJJbmRpY2F0b3IuZGlzcGxheU5hbWUgPSAnQ2xlYXJJbmRpY2F0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBDbGVhckluZGljYXRvcjtcbiJdfQ== */"),
    style: getStyles('clearIndicator', props),
    title: intl.formatMessage(messages$1.clearButtonLabel),
    "aria-label": intl.formatMessage(messages$1.clearButtonLabel)
    // overriding the default `aria-hidden` prop value to make the component accessible by keyboard - https://github.com/JedWatson/react-select/issues/4793
    ,
    "aria-hidden": false
    // only onMouseDown and onTouchEnd event handlers are passed by `react-select` to the component by default, which makes it not accessible by keyboard
    ,
    onClick: onMouseDown,
    children: jsx(CloseIcon, {
      size: "medium"
    })
  }));
};
ClearIndicator.displayName = 'ClearIndicator';
var ClearIndicator$1 = ClearIndicator;

function ownKeys$5(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys$5(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys$5(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
// see https://github.com/JedWatson/react-select/blob/44e9fb29b230e49a754a2f0d6f30c2250aa45009/src/components/MultiValue.js
const removeProps = ['onClick', 'onTouchEnd', 'onMouseDown'];
const TagRemove = props => {
  const isDisabled = Boolean(props.selectProps.isDisabled || props.selectProps.isReadOnly);
  // when the select input is disabled,
  // we don't want to spread the removeProp event handlers
  const innerProps = isDisabled ? omit(props.innerProps, removeProps) : props.innerProps;
  return jsx(AccessibleButton, _objectSpread$5(_objectSpread$5({
    label: "Remove"
  }, innerProps), {}, {
    children: jsx(CloseBoldIcon, {
      color: isDisabled ? 'neutral60' : 'solid',
      size: "medium"
    })
  }));
};
TagRemove.displayName = 'TagRemove';
var TagRemove$1 = TagRemove;

function ownKeys$4(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys$4(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys$4(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const DropdownIndicator = props => jsx(components.DropdownIndicator, _objectSpread$4(_objectSpread$4({}, props), {}, {
  children: jsx(CaretDownIcon, {
    color: props.isDisabled ? 'neutral60' : undefined,
    size: "small"
  })
}));
DropdownIndicator.displayName = 'DropdownIndicator';
var DropdownIndicator$1 = DropdownIndicator;

function ownKeys$3(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys$3(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys$3(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const SearchIconDropdownIndicator = props => {
  return jsx(components.DropdownIndicator, _objectSpread$3(_objectSpread$3({}, props), {}, {
    children: jsx(SearchIcon, {
      color: 'neutral60',
      size: "big"
    })
  }));
};
SearchIconDropdownIndicator.displayName = 'SearchIconDropdownIndicator';
var SearchIconDropdownIndicator$1 = SearchIconDropdownIndicator;

function ownKeys$2(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys$2(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys$2(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const getDefaultComponent = type => {
  if (type === 'singleValue') return components.SingleValue;
  if (type === 'placeholder') return components.Placeholder;
  return null;
};
const WrapperWithIcon = props => {
  const DefaultComponent = getDefaultComponent(props.type);
  if (!DefaultComponent) {
    return null;
  }
  return jsxs(Fragment, {
    children: [props.selectProps.iconLeft && /*#__PURE__*/cloneElement(props.selectProps.iconLeft, {
      size: 'big'
    }), jsx("span", {
      // react-select uses absolute positioning for the SingleValue/Placeholder
      // the icon has a fixed size of 24px (== SpacingsXl), therefore we can use a fixed margin
      // spacingsXs is the margin between the icon and value
      css: /*#__PURE__*/css("margin-left:", designTokens.marginLeftForSelectInputIcon, ";" + (process.env.NODE_ENV === "production" ? "" : ";label:WrapperWithIcon;"), process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndyYXBwZXItd2l0aC1pY29uLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUErRGdCIiwiZmlsZSI6IndyYXBwZXItd2l0aC1pY29uLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNsb25lRWxlbWVudCwgdHlwZSBSZWFjdEVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgeyBkZXNpZ25Ub2tlbnMgfSBmcm9tICdAY29tbWVyY2V0b29scy11aWtpdC9kZXNpZ24tc3lzdGVtJztcbmltcG9ydCB7XG4gIGNvbXBvbmVudHMgYXMgZGVmYXVsdENvbXBvbmVudHMsXG4gIHR5cGUgU2luZ2xlVmFsdWVQcm9wcyxcbiAgdHlwZSBQbGFjZWhvbGRlclByb3BzLFxufSBmcm9tICdyZWFjdC1zZWxlY3QnO1xuXG5leHBvcnQgdHlwZSBUV3JhcHBlcldpdGhJY29uU2VsZWN0UHJvcHMgPSB7XG4gIGljb25MZWZ0PzogUmVhY3RFbGVtZW50O1xufTtcbmV4cG9ydCB0eXBlIFRTaW5nbGVWYWx1ZVdyYXBwZXJXaXRoSWNvblByb3BzID0ge1xuICB0eXBlOiAnc2luZ2xlVmFsdWUnO1xuICBzZWxlY3RQcm9wcz86IFRXcmFwcGVyV2l0aEljb25TZWxlY3RQcm9wcztcbn0gJiBTaW5nbGVWYWx1ZVByb3BzO1xuZXhwb3J0IHR5cGUgVFBsYWNlaG9sZGVyV3JhcHBlcldpdGhJY29uUHJvcHMgPSB7XG4gIHR5cGU6ICdwbGFjZWhvbGRlcic7XG4gIHNlbGVjdFByb3BzPzogVFdyYXBwZXJXaXRoSWNvblNlbGVjdFByb3BzO1xufSAmIFBsYWNlaG9sZGVyUHJvcHM7XG5leHBvcnQgdHlwZSBUV3JhcHBlcldpdGhJY29uUHJvcHM8VHlwZSBleHRlbmRzICdzaW5nbGVWYWx1ZScgfCAncGxhY2Vob2xkZXInPiA9XG4gIFR5cGUgZXh0ZW5kcyAnc2luZ2xlVmFsdWUnXG4gICAgPyBUU2luZ2xlVmFsdWVXcmFwcGVyV2l0aEljb25Qcm9wc1xuICAgIDogVHlwZSBleHRlbmRzICdwbGFjZWhvbGRlcidcbiAgICA/IFRQbGFjZWhvbGRlcldyYXBwZXJXaXRoSWNvblByb3BzXG4gICAgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIFREZWZhdWx0Q29tcG9uZW50PFR5cGUgZXh0ZW5kcyAnc2luZ2xlVmFsdWUnIHwgJ3BsYWNlaG9sZGVyJz4gPSAoXG4gIHByb3BzOiBUeXBlIGV4dGVuZHMgJ3NpbmdsZVZhbHVlJ1xuICAgID8gU2luZ2xlVmFsdWVQcm9wc1xuICAgIDogVHlwZSBleHRlbmRzICdwbGFjZWhvbGRlcidcbiAgICA/IFBsYWNlaG9sZGVyUHJvcHNcbiAgICA6IG5ldmVyXG4pID0+IEpTWC5FbGVtZW50O1xuXG5jb25zdCBnZXREZWZhdWx0Q29tcG9uZW50ID0gPFR5cGUgZXh0ZW5kcyAnc2luZ2xlVmFsdWUnIHwgJ3BsYWNlaG9sZGVyJz4oXG4gIHR5cGU6IFRXcmFwcGVyV2l0aEljb25Qcm9wczxUeXBlPlsndHlwZSddXG4pOiBURGVmYXVsdENvbXBvbmVudDxUeXBlPiB8IG51bGwgPT4ge1xuICBpZiAodHlwZSA9PT0gJ3NpbmdsZVZhbHVlJylcbiAgICByZXR1cm4gZGVmYXVsdENvbXBvbmVudHMuU2luZ2xlVmFsdWUgYXMgVERlZmF1bHRDb21wb25lbnQ8VHlwZT47XG4gIGlmICh0eXBlID09PSAncGxhY2Vob2xkZXInKVxuICAgIHJldHVybiBkZWZhdWx0Q29tcG9uZW50cy5QbGFjZWhvbGRlciBhcyBURGVmYXVsdENvbXBvbmVudDxUeXBlPjtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBXcmFwcGVyV2l0aEljb24gPSA8VHlwZSBleHRlbmRzICdzaW5nbGVWYWx1ZScgfCAncGxhY2Vob2xkZXInPihcbiAgcHJvcHM6IFRXcmFwcGVyV2l0aEljb25Qcm9wczxUeXBlPlxuKSA9PiB7XG4gIGNvbnN0IERlZmF1bHRDb21wb25lbnQgPSBnZXREZWZhdWx0Q29tcG9uZW50PFR5cGU+KHByb3BzLnR5cGUpO1xuXG4gIGlmICghRGVmYXVsdENvbXBvbmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge3Byb3BzLnNlbGVjdFByb3BzLmljb25MZWZ0ICYmXG4gICAgICAgIGNsb25lRWxlbWVudChwcm9wcy5zZWxlY3RQcm9wcy5pY29uTGVmdCwge1xuICAgICAgICAgIHNpemU6ICdiaWcnLFxuICAgICAgICB9KX1cbiAgICAgIDxzcGFuXG4gICAgICAgIC8vIHJlYWN0LXNlbGVjdCB1c2VzIGFic29sdXRlIHBvc2l0aW9uaW5nIGZvciB0aGUgU2luZ2xlVmFsdWUvUGxhY2Vob2xkZXJcbiAgICAgICAgLy8gdGhlIGljb24gaGFzIGEgZml4ZWQgc2l6ZSBvZiAyNHB4ICg9PSBTcGFjaW5nc1hsKSwgdGhlcmVmb3JlIHdlIGNhbiB1c2UgYSBmaXhlZCBtYXJnaW5cbiAgICAgICAgLy8gc3BhY2luZ3NYcyBpcyB0aGUgbWFyZ2luIGJldHdlZW4gdGhlIGljb24gYW5kIHZhbHVlXG4gICAgICAgIGNzcz17Y3NzYFxuICAgICAgICAgIG1hcmdpbi1sZWZ0OiAke2Rlc2lnblRva2Vucy5tYXJnaW5MZWZ0Rm9yU2VsZWN0SW5wdXRJY29ufTtcbiAgICAgICAgYH1cbiAgICAgID5cbiAgICAgICAgey8qIEB0cy1pZ25vcmUgKi99XG4gICAgICAgIDxEZWZhdWx0Q29tcG9uZW50IHsuLi5wcm9wc30gLz5cbiAgICAgIDwvc3Bhbj5cbiAgICA8Lz5cbiAgKTtcbn07XG5cbldyYXBwZXJXaXRoSWNvbi5kaXNwbGF5TmFtZSA9ICdXcmFwcGVyV2l0aEljb24nO1xuXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVyV2l0aEljb247XG5cbmNvbnN0IGN1c3RvbUNvbXBvbmVudHMgPSB7XG4gIFNpbmdsZVZhbHVlOiAocHJvcHM6IFRXcmFwcGVyV2l0aEljb25Qcm9wczwnc2luZ2xlVmFsdWUnPikgPT4gKFxuICAgIDxXcmFwcGVyV2l0aEljb248J3NpbmdsZVZhbHVlJz4gey4uLnByb3BzfSB0eXBlPVwic2luZ2xlVmFsdWVcIiAvPlxuICApLFxuICBQbGFjZWhvbGRlcjogKHByb3BzOiBUV3JhcHBlcldpdGhJY29uUHJvcHM8J3BsYWNlaG9sZGVyJz4pID0+IChcbiAgICA8V3JhcHBlcldpdGhJY29uPCdwbGFjZWhvbGRlcic+IHsuLi5wcm9wc30gdHlwZT1cInBsYWNlaG9sZGVyXCIgLz5cbiAgKSxcbn07XG5cbmV4cG9ydCB7IGN1c3RvbUNvbXBvbmVudHMgfTtcbiJdfQ== */"),
      children: jsx(DefaultComponent, _objectSpread$2({}, props))
    })]
  });
};
WrapperWithIcon.displayName = 'WrapperWithIcon';
var WrapperWithIcon$1 = WrapperWithIcon;
const customComponents = {
  SingleValue: props => jsx(WrapperWithIcon, _objectSpread$2(_objectSpread$2({}, props), {}, {
    type: "singleValue"
  })),
  Placeholder: props => jsx(WrapperWithIcon, _objectSpread$2(_objectSpread$2({}, props), {}, {
    type: "placeholder"
  }))
};

const NO_VALUE_FALLBACK = '- - - -';
const SELECT_DROPDOWN_OPTION_TYPES = {
  SINGLE_PROPERTY: 'single-property',
  DOUBLE_PROPERTY: 'double-property',
  MULTIPLE_PROPERTIES: 'multiple-properties'
};

function ownKeys$1(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys$1(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys$1(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const MultiplePropertiesSelectInputOption = props => {
  const data = props.data;
  const noValueFallback = props.noValueFallback || NO_VALUE_FALLBACK;
  return jsx(components.Option, _objectSpread$1(_objectSpread$1({}, props), {}, {
    children: jsxs(Spacings.Stack, {
      scale: "xs",
      children: [jsx(Text.Detail, {
        fontWeight: "bold",
        children: (data === null || data === void 0 ? void 0 : data.label) || noValueFallback
      }), jsxs(Text.Detail, {
        children: ["Key: ", (data === null || data === void 0 ? void 0 : data.key) || noValueFallback]
      }), jsxs(Text.Detail, {
        children: ["ID: ", (data === null || data === void 0 ? void 0 : data.id) || noValueFallback]
      })]
    })
  }));
};
MultiplePropertiesSelectInputOption.displayName = 'MultiplePropertiesSelectInputOption';
const DoublePropertySelectInputOption = props => {
  const data = props.data;
  const noValueFallback = props.noValueFallback || NO_VALUE_FALLBACK;
  return jsx(components.Option, _objectSpread$1(_objectSpread$1({}, props), {}, {
    children: jsxs(Spacings.Stack, {
      scale: "xs",
      children: [jsx(Text.Detail, {
        fontWeight: "bold",
        children: (data === null || data === void 0 ? void 0 : data.label) || noValueFallback
      }), jsxs(Text.Detail, {
        children: ["Key: ", (data === null || data === void 0 ? void 0 : data.key) || noValueFallback]
      })]
    })
  }));
};
DoublePropertySelectInputOption.displayName = 'DoublePropertySelectInputOption';
const CustomSelectInputOption = props => {
  var _props$optionInnerPro;
  const noValueFallback = props.noValueFallback || NO_VALUE_FALLBACK;
  switch (props.optionType) {
    case SELECT_DROPDOWN_OPTION_TYPES.MULTIPLE_PROPERTIES:
      return jsx(MultiplePropertiesSelectInputOption, _objectSpread$1(_objectSpread$1({}, props.optionInnerProps), {}, {
        noValueFallback: noValueFallback
      }));
    case SELECT_DROPDOWN_OPTION_TYPES.DOUBLE_PROPERTY:
      return jsx(DoublePropertySelectInputOption, _objectSpread$1(_objectSpread$1({}, props.optionInnerProps), {}, {
        noValueFallback: noValueFallback
      }));
    default:
      return jsx(components.Option, _objectSpread$1(_objectSpread$1({}, props.optionInnerProps), {}, {
        children: jsx(Text.Detail, {
          children: ((_props$optionInnerPro = props.optionInnerProps.data) === null || _props$optionInnerPro === void 0 ? void 0 : _props$optionInnerPro.label) || noValueFallback
        })
      }));
  }
};
CustomSelectInputOption.displayName = 'CustomSelectInputOption';

var messages = defineMessages({
  createLabel: {
    id: 'UIKit.CreatableSelectInput.createLabel',
    description: 'Text of dropdown when creating option',
    defaultMessage: 'Create "{inputValue}"'
  },
  noOptionsMessageWithInputValue: {
    id: 'UIKit.SelectInput.noOptionsMessageWithInputValue',
    description: 'Text of dropdown when no options match search text',
    defaultMessage: 'No options'
  },
  noOptionsMessageWithoutInputValue: {
    id: 'UIKit.SelectInput.noOptionsMessageWithoutInputValue',
    description: 'Text of dropdown when no options exist',
    defaultMessage: 'No options'
  },
  placeholder: {
    id: 'UIKit.SelectInput.placeholder',
    description: 'Default input placeholder text',
    defaultMessage: 'Select...'
  },
  loadingOptions: {
    id: 'UIKit.SelectInput.loadingOptions',
    description: 'Default input loading text',
    defaultMessage: 'Loading...'
  }
});

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context8, _context9; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context8 = ownKeys(Object(source), !0)).call(_context8, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context9 = ownKeys(Object(source))).call(_context9, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const getInputBackgroundColor = props => {
  if (props.appearance === 'quiet') {
    return designTokens.backgroundColorForInputAsQuiet;
  }
  if (props.isDisabled) {
    return designTokens.backgroundColorForInputWhenDisabled;
  }
  if (props.isReadOnly) {
    return designTokens.backgroundColorForInputWhenReadonly;
  }
  return designTokens.backgroundColorForInput;
};
const getInputBorderColor = (props, state) => {
  if (props.appearance === 'quiet') {
    return designTokens.borderColorForInputAsQuiet;
  }
  if (props.isDisabled) {
    return designTokens.borderColorForInputWhenDisabled;
  }
  if (props.isReadOnly) {
    return designTokens.borderColorForSelectInputWhenReadonly;
  }
  if (state.isFocused) {
    return designTokens.borderColorForInputWhenFocused;
  }
  if (props.hasError) {
    return designTokens.borderColorForInputWhenError;
  }
  if (props.hasWarning) {
    return designTokens.borderColorForInputWhenWarning;
  }
  return designTokens.borderColorForInput;
};
const getHoverInputBorderColor = props => {
  if (props.appearance === 'quiet') {
    return designTokens.borderColorForInputAsQuiet;
  }
  if (props.isDisabled) {
    return designTokens.borderColorForInputWhenDisabled;
  }
  if (props.isReadOnly) {
    return designTokens.borderColorForSelectInputWhenReadonly;
  }
  if (props.hasError) {
    return designTokens.borderColorForInputWhenError;
  }
  if (props.hasWarning) {
    return designTokens.borderColorForInputWhenWarning;
  }
  return designTokens.borderColorForInputWhenHovered;
};
const controlStyles = props => (base, state) => {
  var _context;
  return _objectSpread(_objectSpread(_objectSpread({}, base), {}, {
    fontSize: designTokens.fontSizeForInput,
    backgroundColor: getInputBackgroundColor(props),
    borderColor: getInputBorderColor(props, state),
    borderWidth: (() => {
      if (props.hasWarning || props.hasError || state.isFocused || props.appearance === 'quiet') {
        return designTokens.borderWidthForSelectInput;
      }
      return designTokens.borderWidth1;
    })(),
    borderRadius: designTokens.borderRadiusForInput,
    minHeight: designTokens.heightForInput,
    cursor: (() => {
      if (props.isDisabled) return 'not-allowed';
      if (props.isReadOnly) return 'default';
      return 'pointer';
    })(),
    padding: "0 ".concat(designTokens.paddingForInput),
    transition: _concatInstanceProperty(_context = "border-color ".concat(designTokens.transitionStandard, ",\n    box-shadow ")).call(_context, designTokens.transitionStandard),
    outline: 0,
    boxShadow: 'none'
  }, props.horizontalConstraint === 'auto' ? {
    display: 'inline-flex'
  } : {}), {}, {
    '&:focus-within': {
      borderColor: (() => {
        if (!props.isDisabled && !props.isReadOnly) return designTokens.borderColorForInputWhenFocused;
        return null;
      })()
    },
    '&:hover': {
      borderColor: getHoverInputBorderColor(props),
      backgroundColor: (() => {
        if (!props.isDisabled && !props.isReadOnly) {
          if (props.appearance === 'quiet') {
            return designTokens.backgroundColorForInputAsQuietWhenHovered;
          } else {
            return designTokens.backgroundColorForInputWhenHovered;
          }
        }
        return null;
      })()
    },
    pointerEvents: 'auto',
    color: props.isDisabled || props.isReadOnly ? designTokens.fontColorForInputWhenDisabled : base.fontColorForInput
  });
};
const menuStyles = props => base => {
  return _objectSpread(_objectSpread({}, base), {}, {
    border: "1px solid ".concat(designTokens.borderColorForSelectInputMenu),
    borderRadius: designTokens.borderRadiusForInput,
    backgroundColor: designTokens.backgroundColorForInput,
    boxShadow: designTokens.shadowForSelectInputMenu,
    fontSize: designTokens.fontSizeForInput,
    fontFamily: 'inherit',
    margin: "".concat(designTokens.spacing10, " 0 0 0"),
    borderColor: (() => {
      if (props.hasError) return designTokens.borderColorForSelectInputMenuWhenError;
      if (props.hasWarning) return designTokens.borderColorForSelectInputMenuWhenWarning;
      return base.borderColorForInput;
    })(),
    width: props.horizontalConstraint === 'auto' ? 'auto' : '100%'
  });
};
const indicatorSeparatorStyles = () => base => {
  return _objectSpread(_objectSpread({}, base), {}, {
    display: 'none',
    margin: '0',
    padding: '0',
    marginLeft: designTokens.spacing10
  });
};
const dropdownIndicatorStyles = props => base => {
  return _objectSpread(_objectSpread({}, base), {}, {
    color: designTokens.fontColorForInput,
    margin: '0',
    padding: '0',
    marginLeft: designTokens.marginForSelectInputIcon,
    fill: (() => {
      if (props.isDisabled || props.isReadOnly) return designTokens.fontColorForInputWhenDisabled;
      if (props.hasError) return designTokens.fontColorForSelectInputIconWhenError;
      if (props.hasWarning) return designTokens.fontColorForSelectInputIconWhenWarning;
      return designTokens.fontColorForSelectInputIcon;
    })()
  });
};
const clearIndicatorStyles = () => base => _objectSpread(_objectSpread({}, base), {}, {
  display: 'flex',
  padding: 0,
  marginLeft: designTokens.marginForSelectInputIcon
});
const menuListStyles = () => base => {
  return _objectSpread(_objectSpread({}, base), {}, {
    padding: designTokens.paddingForSelectInputMenu,
    borderRadius: designTokens.borderRadiusForInput,
    backgroundColor: designTokens.backgroundColorForInput
  });
};
const optionStyles = () => (base, state) => {
  var _context2, _context3;
  return _objectSpread(_objectSpread({}, base), {}, {
    transition: _concatInstanceProperty(_context2 = _concatInstanceProperty(_context3 = "border-color ".concat(designTokens.transitionStandard, ",\n      background-color ")).call(_context3, designTokens.transitionStandard, ",\n      color ")).call(_context2, designTokens.transitionStandard),
    paddingLeft: designTokens.paddingLeftForSelectInputOptions,
    paddingRight: designTokens.paddingRightForSelectInputOptions,
    paddingTop: designTokens.paddingTopForSelectInputOptions,
    paddingBottom: designTokens.paddingBottomForSelectInputOptions,
    lineHeight: designTokens.lineHeightForSelectInputOptions,
    color: (() => {
      if (!state.isDisabled) return designTokens.fontColorForInput;
      if (state.isSelected) return designTokens.fontColorForInput;
      return base.color;
    })(),
    backgroundColor: (() => {
      if (state.isSelected) return designTokens.backgroundColorForInputWhenSelected;
      if (state.isFocused) return designTokens.backgroundColorForSelectInputOptionWhenHovered;
      return base.backgroundColor;
    })(),
    '&:active': {
      color: (() => {
        if (!state.isDisabled) return designTokens.fontColorForInput;
        return base.color;
      })(),
      backgroundColor: designTokens.backgroundColorForInputWhenActive
    }
  });
};
const placeholderStyles = props => base => {
  return _objectSpread(_objectSpread({}, base), {}, {
    color: (() => {
      if (props.appearance === 'quiet' && !props.isReadOnly && !props.isDisabled) {
        if (props.hasError) {
          return designTokens.fontColorForSelectInputWhenError;
        }
        if (props.hasWarning) {
          return designTokens.fontColorForSelectInputWhenWarning;
        }
      }
      return designTokens.placeholderFontColorForInput;
    })(),
    width: '100%',
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    textOverflow: 'ellipsis',
    fill: props.isDisabled || props.isReadOnly ? designTokens.fontColorForInputWhenDisabled : base.fontColorForInput
  });
};
const valueContainerStyles = props => base => {
  var _props$controlShouldR;
  return _objectSpread(_objectSpread({}, base), {}, {
    padding: '0',
    backgroundColor: 'none',
    overflow: 'hidden',
    // Display property should be grid when isMulti and has no value so the Placeholder component is positioned correctly with the Input
    // Display property should be Flex when there is an iconLeft, also when the input has some values when isMulti.
    // See PR from react select for more insight https://github.com/JedWatson/react-select/pull/4833
    display: props.iconLeft && !props.isMulti || props.isMulti && props.hasValue && ((_props$controlShouldR = props.controlShouldRenderValue) !== null && _props$controlShouldR !== void 0 ? _props$controlShouldR : true) ? 'flex' : 'grid',
    fill: props.isDisabled || props.isReadOnly ? designTokens.fontColorForInputWhenDisabled : designTokens.fontColorForSelectInputIcon
  });
};
const singleValueStyles = props => base => {
  return _objectSpread(_objectSpread({}, base), {}, {
    color: (() => {
      if (props.isDisabled) {
        return designTokens.fontColorForInputWhenDisabled;
      }
      if (props.isReadOnly) {
        return designTokens.fontColorForInputWhenReadonly;
      }
      if (props.hasError) return designTokens.fontColorForSelectInputWhenError;
      if (props.hasWarning) return designTokens.fontColorForSelectInputWhenWarning;
      return designTokens.fontColorForInput;
    })()
  });
};
const groupStyles = props => base => {
  return _objectSpread(_objectSpread({}, base), {}, {
    padding: 0,
    '&:not(:first-of-type)': {
      borderTop: props.showOptionGroupDivider ? "1px solid ".concat(designTokens.borderColorForGroupHeadingSelectInputOptions) : base.borderTop
    }
  });
};
const groupHeadingStyles = () => base => {
  var _context4;
  return _objectSpread(_objectSpread({}, base), {}, {
    color: designTokens.fontColorForInputWhenReadonly,
    fontSize: designTokens.fontSizeSmall,
    textTransform: 'none',
    fontWeight: 'bold',
    padding: _concatInstanceProperty(_context4 = "".concat(designTokens.spacing20, " ")).call(_context4, designTokens.paddingForGroupHeadingSelectInputOptions),
    '&:empty': {
      padding: 0
    }
  });
};
const containerStyles = () => (base, state) => {
  return _objectSpread(_objectSpread({}, base), {}, {
    fontFamily: 'inherit',
    minHeight: designTokens.sizeHeightInput,
    borderRadius: designTokens.borderRadiusForInput,
    borderColor: state.isFocused ? designTokens.borderColorForInputWhenFocused : base.borderColor,
    boxShadow: state.isFocused ? 'none' : base.boxShadow
  });
};
const indicatorsContainerStyles = () => () => ({
  background: 'none',
  display: 'flex',
  alignItems: 'center'
});
const menuPortalStyles = props => base => _objectSpread(_objectSpread({}, base), {}, {
  zIndex: props.menuPortalZIndex
});
const multiValueStyles = () => base => {
  return _objectSpread(_objectSpread({}, base), {}, {
    display: 'flex',
    alignItems: designTokens.alignItemsForSelectInputTag,
    height: designTokens.heightForSelectInputTag,
    backgroundColor: designTokens.backgroundColorForTag,
    padding: '0',
    border: designTokens.borderForSelectInputTag
  });
};
const multiValueLabelStyles = props => base => {
  var _context5, _context6;
  return _objectSpread(_objectSpread({}, base), {}, {
    fontSize: designTokens.fontSizeForSelectInputTag,
    color: (() => {
      if (props.isDisabled) return designTokens.fontColorForInputWhenDisabled;
      if (props.isReadOnly) return designTokens.fontColorForInputWhenReadonly;
      return base.color;
    })(),
    padding: _concatInstanceProperty(_context5 = "".concat(designTokens.spacing10, " ")).call(_context5, designTokens.spacing20),
    borderRadius: _concatInstanceProperty(_context6 = "".concat(designTokens.borderRadiusForTag, " 0 0 ")).call(_context6, designTokens.borderRadiusForTag),
    border: 'none',
    borderWidth: '1px 0 1px 1px',
    '&:last-child': {
      borderRadius: designTokens.borderRadiusForTag,
      borderWidth: designTokens.borderWidth1
    }
  });
};
const multiValueRemoveStyles = props => (base, state) => {
  var _context7;
  return _objectSpread(_objectSpread({}, base), {}, {
    borderColor: designTokens.borderColorForTag,
    padding: "0 ".concat(designTokens.spacing10),
    borderRadius: _concatInstanceProperty(_context7 = "0 ".concat(designTokens.borderRadiusForTag, " ")).call(_context7, designTokens.borderRadiusForTag, " 0"),
    borderStyle: 'none',
    borderWidth: '0',
    pointerEvents: state.isDisabled || props.isReadOnly ? 'none' : base.pointerEvents,
    backgroundColor: designTokens.backgroundColorForTag,
    'svg *': {
      fill: props.isReadOnly ? designTokens.fontColorForInputWhenReadonly : ''
    },
    '&:hover, &:focus': {
      borderColor: designTokens.borderColorForTagWarning,
      backgroundColor: designTokens.backgroundColorForTag,
      'svg *': {
        fill: designTokens.fontColorForClearInputIconWhenHovered
      }
    }
  });
};
function createSelectStyles(props) {
  return {
    control: controlStyles(props),
    menu: menuStyles(props),
    indicatorSeparator: indicatorSeparatorStyles(),
    dropdownIndicator: dropdownIndicatorStyles(props),
    clearIndicator: clearIndicatorStyles(),
    menuList: menuListStyles(),
    menuPortal: menuPortalStyles(props),
    multiValue: multiValueStyles(),
    multiValueLabel: multiValueLabelStyles(props),
    multiValueRemove: multiValueRemoveStyles(props),
    indicatorsContainer: indicatorsContainerStyles(),
    option: optionStyles(),
    placeholder: placeholderStyles(props),
    valueContainer: valueContainerStyles(props),
    singleValue: singleValueStyles(props),
    group: groupStyles(props),
    groupHeading: groupHeadingStyles(),
    container: containerStyles()
  };
}

const getMessage = componentName => "".concat(componentName, ": use `menuPortalZIndex` in conjunction with `menuPortalTarget`");
const warnIfMenuPortalPropsAreMissing = props => {
  if (typeof props.menuPortalZIndex !== 'undefined' && props.menuPortalZIndex !== 1 // 1 is the value passed in default props
  ) {
    process.env.NODE_ENV !== "production" ? warning(props.menuPortalTarget, getMessage(props.componentName)) : void 0;
  }
};

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

export { ClearIndicator$1 as ClearIndicator, CustomSelectInputOption, DoublePropertySelectInputOption, DropdownIndicator$1 as DropdownIndicator, MultiplePropertiesSelectInputOption, SELECT_DROPDOWN_OPTION_TYPES, SearchIconDropdownIndicator$1 as SearchIconDropdownIndicator, TagRemove$1 as TagRemove, WrapperWithIcon$1 as ValueWrapperWithIcon, createSelectStyles, customComponents as customComponentsWithIcons, messages, version, warnIfMenuPortalPropsAreMissing };
