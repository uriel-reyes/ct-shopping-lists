import _Reflect$construct from '@babel/runtime-corejs3/core-js-stable/reflect/construct';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _classCallCheck from '@babel/runtime-corejs3/helpers/esm/classCallCheck';
import _createClass from '@babel/runtime-corejs3/helpers/esm/createClass';
import _inherits from '@babel/runtime-corejs3/helpers/esm/inherits';
import _possibleConstructorReturn from '@babel/runtime-corejs3/helpers/esm/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime-corejs3/helpers/esm/getPrototypeOf';
import _pt from 'prop-types';
import { forwardRef, useRef, useMemo, useState, useCallback, useEffect, useImperativeHandle, PureComponent } from 'react';
import { filterDataAttributes, warning } from '@commercetools-uikit/utils';
import { resetEditor, RichTextBody, focusEditor, toggleMark, HiddenInput, Element, Leaf, isEmpty, validSlateStateAdapter, html } from '@commercetools-uikit/rich-text-utils';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import { useIntl } from 'react-intl';
import CollapsibleMotion from '@commercetools-uikit/collapsible-motion';
import Stack from '@commercetools-uikit/spacings-stack';
import { AngleUpIcon, AngleDownIcon } from '@commercetools-uikit/icons';
import Constraints from '@commercetools-uikit/constraints';
import FlatButton from '@commercetools-uikit/flat-button';
import { messagesMultilineInput } from '@commercetools-uikit/input-utils';
import { withReact, Slate, Editable, ReactEditor } from 'slate-react';
import { createEditor } from 'slate';
import { withHistory } from 'slate-history';
import isHotkey from 'is-hotkey';
import pipe from 'lodash/fp/pipe';
import _styled from '@emotion/styled/base';
import { jsx, jsxs } from '@emotion/react/jsx-runtime';

const EditorWrapper = /*#__PURE__*/_styled("div", process.env.NODE_ENV === "production" ? {
  target: "e1d53kc50"
} : {
  target: "e1d53kc50",
  label: "EditorWrapper"
})("align-self:stretch;cursor:", props => props.isDisabled || props.isReadOnly ? 'not-allowed' : 'inherit', ";" + (process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVkaXRvci5zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBS3FEIiwiZmlsZSI6ImVkaXRvci5zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IFRFZGl0b3JQcm9wcyB9IGZyb20gJy4vZWRpdG9yJztcblxudHlwZSBURWRpdG9yV3JhcHBlclByb3BzID0gUGljazxURWRpdG9yUHJvcHMsICdpc0Rpc2FibGVkJyB8ICdpc1JlYWRPbmx5Jz47XG5cbmNvbnN0IEVkaXRvcldyYXBwZXIgPSBzdHlsZWQuZGl2PFRFZGl0b3JXcmFwcGVyUHJvcHM+YFxuICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICBjdXJzb3I6ICR7KHByb3BzKSA9PlxuICAgIHByb3BzLmlzRGlzYWJsZWQgfHwgcHJvcHMuaXNSZWFkT25seSA/ICdub3QtYWxsb3dlZCcgOiAnaW5oZXJpdCd9O1xuYDtcblxuZXhwb3J0IHsgRWRpdG9yV3JhcHBlciB9O1xuIl19 */"));

function ownKeys$1(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys$1(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys$1(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
const HOTKEYS = {
  'mod+b': 'bold',
  'mod+i': 'italic',
  'mod+u': 'underline',
  'mod+`': 'code'
};
const COLLAPSED_HEIGHT = 32;
const renderElement = props => jsx(Element, _objectSpread$1({}, props));
const renderLeaf = props => jsx(Leaf, _objectSpread$1({}, props));
const Editor = /*#__PURE__*/forwardRef((props, forwardedRef) => {
  const intl = useIntl();
  const ref = useRef(null);
  const createEditorWithPlugins = pipe(withReact, withHistory);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const editor = useMemo(() => createEditorWithPlugins(createEditor()), []);
  const _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    renderToggleButton = _useState2[0],
    setRenderToggleButton = _useState2[1];
  const updateRenderToggleButton = useCallback(() => {
    var _ref$current;
    const doesExceedCollapsedHeightLimit = Number((_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.clientHeight) > COLLAPSED_HEIGHT;
    if (doesExceedCollapsedHeightLimit && !renderToggleButton) {
      setRenderToggleButton(true);
    }
    if (!doesExceedCollapsedHeightLimit && renderToggleButton) {
      setRenderToggleButton(false);
    }
  }, [setRenderToggleButton, renderToggleButton]);
  useEffect(() => {
    updateRenderToggleButton();
  }, [editor, updateRenderToggleButton]);

  // resetting
  const resetValue = useCallback(newValue => {
    resetEditor(editor, newValue);
  }, [editor]);
  /* 
  Resetting the editor requires access to `editor` object returned from `useSlate` hook.
  Therefore, `reset` function is attached to the passed `ref` object via `useImperativeHandle` hook
  to be called from the parent component. 
  e.g. <button onMouseDown={() => ref.current?.resetValue("<p><strong>Value after reset</strong></p>")}>Reset</button>
  */
  useImperativeHandle(forwardedRef, () => {
    return {
      resetValue
    };
  });
  return jsx(CollapsibleMotion, {
    minHeight: COLLAPSED_HEIGHT,
    isDefaultClosed: !props.defaultExpandMultilineText,
    children: _ref => {
      let isOpen = _ref.isOpen,
        toggle = _ref.toggle,
        containerStyles = _ref.containerStyles,
        registerContentNode = _ref.registerContentNode;
      const refObj = {
        containerRef: ref,
        registerContentNode
      };
      return jsx(Constraints.Horizontal, {
        max: props.horizontalConstraint,
        children: jsxs(Stack, {
          scale: "xs",
          alignItems: "flex-end",
          children: [jsx(EditorWrapper, {
            isDisabled: props.isDisabled,
            isReadOnly: props.isReadOnly,
            children: jsx(Slate, {
              editor: editor,
              value: props.value,
              onChange: props.onChange,
              children: jsxs(RichTextBody
              // @ts-ignore
              , {
                ref: refObj,
                hasError: props.hasError,
                isDisabled: props.isDisabled,
                hasWarning: props.hasWarning,
                isReadOnly: Boolean(props.isReadOnly),
                showExpandIcon: Boolean(props.showExpandIcon),
                onClickExpand: props.onClickExpand,
                containerStyles: containerStyles,
                children: [jsx(Editable, _objectSpread$1(_objectSpread$1({}, filterDataAttributes(props)), {}, {
                  name: props.name,
                  renderElement: renderElement,
                  renderLeaf: renderLeaf,
                  placeholder: props.placeholder,
                  autoFocus: props.isAutofocused,
                  readOnly: props.isReadOnly,
                  disabled: props.isDisabled,
                  onBlur: props.onBlur,
                  onFocus: event => {
                    var _props$onFocus;
                    (_props$onFocus = props.onFocus) === null || _props$onFocus === void 0 ? void 0 : _props$onFocus.call(props, event);
                    // opens the input if it regains focus and it's closed
                    if (!isOpen) {
                      toggle();
                      focusEditor(editor);
                    }
                  },
                  onKeyDown: event => {
                    for (const hotkey in HOTKEYS) {
                      if (isHotkey(hotkey, event)) {
                        event.preventDefault();
                        const mark = HOTKEYS[hotkey];
                        toggleMark(editor, mark);
                        break;
                      }
                    }
                  }
                })), props.children, jsx(HiddenInput, {
                  isFocused: ReactEditor.isFocused(editor),
                  handleFocus: () => {
                    focusEditor(editor);
                  },
                  id: props.id,
                  disabled: props.isDisabled,
                  readOnly: props.isReadOnly
                })]
              })
            })
          }), renderToggleButton && jsx(FlatButton, {
            onClick: toggle,
            label: isOpen ? intl.formatMessage(messagesMultilineInput.collapse) : intl.formatMessage(messagesMultilineInput.expand),
            icon: isOpen ? jsx(AngleUpIcon, {
              size: "small"
            }) : jsx(AngleDownIcon, {
              size: "small"
            })
          })]
        })
      });
    }
  });
});
Editor.displayName = 'Editor';
var Editor$1 = Editor;

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty(_context = ownKeys(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context2 = ownKeys(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
let RichTextInput = /*#__PURE__*/function (_PureComponent) {
  _inherits(RichTextInput, _PureComponent);
  var _super = _createSuper(RichTextInput);
  function RichTextInput() {
    var _this;
    _classCallCheck(this, RichTextInput);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call(this, ...args);
    _this.serializedValue = _this.props.value;
    _this.internalSlateValue = validSlateStateAdapter(html.deserialize(_this.props.value || ''));
    _this.onValueChange = state => {
      const serializedValue = html.serialize(state);
      // because we are not using setState, we need to make sure that
      // we perform an update when the slate value changes
      // as this can contain things like cursor location
      // in this case, the internalSlateValue would change
      // but the serializedValue would NOT change.
      const hasInternalSlateValueChanged = _this.internalSlateValue !== state;
      const hasSerializedValueChanged = serializedValue !== _this.serializedValue;
      _this.internalSlateValue = validSlateStateAdapter(state);
      _this.serializedValue = serializedValue;
      // the consumer only cares about the serializedValue, so it doesn't make sense to call
      // onChange unless this value changes.
      if (hasSerializedValueChanged) {
        var _this$props$onChange, _this$props;
        (_this$props$onChange = (_this$props = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props, {
          target: {
            value: html.serialize(state)
          }
        });
      }
      if (hasInternalSlateValueChanged && !hasSerializedValueChanged) {
        // this way we force update if cursor or selection changes
        _this.forceUpdate();
      }
    };
    return _this;
  }
  _createClass(RichTextInput, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      // everytime we call `onChange`, we update `this.serializedValue`
      // to the new HTML value
      // this condition only occurs if the parent component takes `control`
      // and resets the component to a different HTML value that what
      // we expect
      // in this case, we need to parse this new value into a value slate
      // can understand, save this value to our class variable, and forceUpdate
      // this keeps the component in sync.
      if (this.props.value !== this.serializedValue) {
        const value = this.props.value || '';
        this.internalSlateValue = validSlateStateAdapter(html.deserialize(value));
        this.serializedValue = value;
        this.forceUpdate();
      }
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.props.isReadOnly) {
        process.env.NODE_ENV !== "production" ? warning(typeof this.props.onChange === 'function', 'RichTextInput: "onChange" is required when input is not read only.') : void 0;
      }
      if (this.props.showExpandIcon) {
        process.env.NODE_ENV !== "production" ? warning(typeof this.props.onClickExpand === 'function', 'RichTextInput: "onClickExpand" is required when showExpandIcon is true') : void 0;
      }
      return jsx(Editor$1, _objectSpread(_objectSpread({}, filterDataAttributes(this.props)), {}, {
        isAutofocused: this.props.isAutofocussed,
        id: this.props.id,
        name: this.props.name,
        onFocus: this.props.onFocus,
        onBlur: this.props.onBlur,
        isDisabled: this.props.isDisabled,
        isReadOnly: this.props.isReadOnly || this.props.isDisabled,
        value: this.internalSlateValue,
        onChange: this.onValueChange,
        horizontalConstraint: this.props.horizontalConstraint,
        defaultExpandMultilineText: this.props.defaultExpandMultilineText,
        hasWarning: this.props.hasWarning,
        hasError: this.props.hasError,
        placeholder: this.props.placeholder,
        showExpandIcon: this.props.showExpandIcon,
        onClickExpand: this.props.onClickExpand,
        ref: this.props.parentRef
      }));
    }
  }]);
  return RichTextInput;
}(PureComponent); // When component is using `forwardRef` only `defaultProps` and `displayName` are recognized by default as static props
RichTextInput.defaultProps = {
  defaultExpandMultilineText: false,
  horizontalConstraint: 'scale',
  placeholder: '',
  showExpandIcon: false
};
RichTextInput.displayName = 'RichTextInput';
RichTextInput.propTypes = process.env.NODE_ENV !== "production" ? {
  isAutofocussed: _pt.bool,
  defaultExpandMultilineText: _pt.bool,
  hasError: _pt.bool,
  hasWarning: _pt.bool,
  id: _pt.string,
  name: _pt.string,
  placeholder: _pt.string,
  isDisabled: _pt.bool,
  isReadOnly: _pt.bool,
  horizontalConstraint: _pt.oneOf([7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 'scale', 'auto']),
  onChange: _pt.func,
  onFocus: _pt.func,
  onBlur: _pt.func,
  value: _pt.string,
  showExpandIcon: _pt.bool,
  onClickExpand: _pt.func
} : {};
const isTouched = touched => Boolean(touched);
const RichTextInputWithRef = /*#__PURE__*/forwardRef((props, ref) => jsx(RichTextInput, _objectSpread({
  parentRef: ref
}, props)));
RichTextInputWithRef.displayName = 'RichTextInputWithRef';
RichTextInputWithRef.isEmpty = isEmpty;
RichTextInputWithRef.isTouched = isTouched;
var RichTextInputWithRef$1 = RichTextInputWithRef;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

export { RichTextInputWithRef$1 as default, version };
