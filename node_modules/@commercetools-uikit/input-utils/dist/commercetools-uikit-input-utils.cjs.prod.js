'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('@emotion/react');
var designSystem = require('@commercetools-uikit/design-system');
require('prop-types');
var react$1 = require('react');
var reactIntl = require('react-intl');
var FlatButton = require('@commercetools-uikit/flat-button');
var icons = require('@commercetools-uikit/icons');
var jsxRuntime = require('@emotion/react/jsx-runtime');
var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
var _parseInt = require('@babel/runtime-corejs3/core-js-stable/parse-int');
var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var TextareaAutosize = require('react-textarea-autosize');
var utils = require('@commercetools-uikit/utils');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var FlatButton__default = /*#__PURE__*/_interopDefault(FlatButton);
var _parseInt__default = /*#__PURE__*/_interopDefault(_parseInt);
var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var TextareaAutosize__default = /*#__PURE__*/_interopDefault(TextareaAutosize);

var messages$1 = reactIntl.defineMessages({
  missingRequiredField: {
    id: 'UIKit.LocalizedTextInput.missingRequiredField',
    description: 'Error message for missing required value',
    defaultMessage: 'This field is required. Provide at least one value.'
  },
  show: {
    id: 'UIKit.LocalizedTextInput.show',
    description: 'Label of language expansion button',
    defaultMessage: 'Show all languages ({remainingLanguages})'
  },
  hide: {
    id: 'UIKit.LocalizedTextInput.hide',
    description: 'Label of language collapse button',
    defaultMessage: 'Hide languages ({remainingLanguages})'
  }
});

const defaultProps = {
  hideMessage: messages$1.hide,
  showMessage: messages$1.show
};
var _ref = {
  name: "xyzkeb",
  styles: "align-self:flex-start"
} ;
const LocalizedInputToggle = props => {
  const intl = reactIntl.useIntl();
  const labelMessage = props.isOpen ? props.hideMessage : props.showMessage;
  const label = typeof labelMessage === 'string' ? labelMessage : intl.formatMessage(labelMessage, {
    remainingLanguages: props.remainingLocalizations
  });
  return jsxRuntime.jsx("div", {
    css: _ref,
    children: jsxRuntime.jsx(FlatButton__default["default"], {
      icon: props.icon ? props.icon : jsxRuntime.jsx(icons.WorldIcon, {}),
      label: label,
      onClick: props.onClick,
      isDisabled: props.isDisabled
    })
  });
};
LocalizedInputToggle.propTypes = {};
LocalizedInputToggle.defaultProps = defaultProps;
LocalizedInputToggle.displayName = 'LocalizedInputToggle';
var LocalizedInputToggle$1 = LocalizedInputToggle;

const getInputBorderColor = function (props) {
  let defaultBorderColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : designSystem.designTokens.borderColorForInput;
  if (props.isDisabled || props.disabled) {
    return designSystem.designTokens.borderColorForInputWhenDisabled;
  }
  if (props.hasError) {
    return designSystem.designTokens.borderColorForInputWhenError;
  }
  if (props.hasWarning) {
    return designSystem.designTokens.borderColorForInputWhenWarning;
  }
  if (props.isReadOnly || props.readOnly) {
    return designSystem.designTokens.borderColorForInputWhenReadonly;
  }
  return defaultBorderColor;
};
const getInputFontColor = props => {
  if (props.isDisabled || props.disabled) {
    return designSystem.designTokens.fontColorForInputWhenDisabled;
  }
  if (props.hasError) {
    return designSystem.designTokens.fontColorForInputWhenError;
  }
  if (props.hasWarning) {
    return designSystem.designTokens.fontColorForInputWhenWarning;
  }
  if (props.isReadOnly || props.readOnly) {
    return designSystem.designTokens.fontColorForInputWhenReadonly;
  }
  return designSystem.designTokens.fontColorForInput;
};
const getInputBorderWidth = props => {
  if (props.hasError) {
    return designSystem.designTokens.borderWidthForInputWhenError;
  }
  if (props.hasWarning) {
    return designSystem.designTokens.borderWidthForInputWhenWarning;
  }
  return designSystem.designTokens.borderWidthForInput;
};
const getInputBoxShadow = props => {
  if (props.hasError) {
    return designSystem.designTokens.shadowForInputWhenError;
  }
  if (props.hasWarning) {
    return designSystem.designTokens.shadowForInputWhenWarning;
  }
  return designSystem.designTokens.shadowForInput;
};
const getInputBackgroundColor = props => {
  if (props.isDisabled || props.disabled) {
    return designSystem.designTokens.backgroundColorForInputWhenDisabled;
  }
  if (props.isReadOnly) {
    return designSystem.designTokens.backgroundColorForInputWhenReadonly;
  }
  return designSystem.designTokens.backgroundColorForInput;
};
const getInputStyles = props => {
  return /*#__PURE__*/react.css("appearance:none;background-color:", getInputBackgroundColor(props), ";border:", getInputBorderWidth(props), " solid ", getInputBorderColor(props), ";border-radius:", designSystem.designTokens.borderRadiusForInput, ";box-sizing:border-box;box-shadow:", getInputBoxShadow(props), ";color:", getInputFontColor(props), ";cursor:", props.isDisabled ? 'not-allowed' : 'default', ";display:flex;flex:1;font-family:inherit;font-size:", designSystem.designTokens.fontSizeForInput, ";height:", designSystem.designTokens.heightForInput, ";min-height:", designSystem.designTokens.heightForInput, ";opacity:", props.isDisabled || props.disabled ? '1' : 'unset', ";outline:none;overflow:hidden;padding:0 ", designSystem.designTokens.paddingForInput, ";transition:border-color ", designSystem.designTokens.transitionStandard, ",background-color ", designSystem.designTokens.transitionStandard, ",color ", designSystem.designTokens.transitionStandard, ",box-shadow ", designSystem.designTokens.transitionStandard, ";width:100%;&::placeholder{color:", designSystem.designTokens.placeholderFontColorForInput, ";}:active:not(:disabled):not(:read-only),:hover:not(:disabled):not(:read-only):not(:focus){border-color:", getInputBorderColor(props, designSystem.designTokens.borderColorForInputWhenHovered), ";background-color:", designSystem.designTokens.backgroundColorForInputWhenHovered, ";}:focus:not(:read-only){box-shadow:", designSystem.designTokens.shadowForInputWhenFocused, ";border-color:", designSystem.designTokens.borderColorForInputWhenFocused, ";background-color:", designSystem.designTokens.backgroundColorForInputWhenFocused, ";}" + ("" ), "" );
};

/* we need this line-height to achieve 32px height when the component has only one row */
const sizeInputLineHeight = '22px';

// NOTE: order is important here
// * a disabled-field currently does not display warning/error-states so it takes precedence
// * a readonly-field cannot be changed, but it might be relevant for validation, so error and warning are checked first
// how you can interact with the field is controlled separately by the props, this only influences visuals
const getTextareaStyles = props => {
  const baseStyles = [getInputStyles(props), /*#__PURE__*/react.css("padding:", designSystem.designTokens.paddingForMultilineInput, ";line-height:", sizeInputLineHeight, ";flex:auto;word-break:break-word;white-space:pre-wrap;resize:none;" + ("" ), "" )];
  return baseStyles;
};

function ownKeys(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context, _context2; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context = ownKeys(Object(source), !0)).call(_context, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context2 = ownKeys(Object(source))).call(_context2, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const MIN_ROW_COUNT = 1;
// We cache the vertical padding of the element becuase
// it does not change over time so we don't need to
// recalculate it on every height change event.
let _elementVerticalPadding = null;
const getElementVerticalPadding = element => {
  if (_elementVerticalPadding === null) {
    const computedStyle = getComputedStyle(element);
    const paddingTop = _parseInt__default["default"](computedStyle.paddingTop, 10);
    const paddingBottom = _parseInt__default["default"](computedStyle.paddingBottom, 10);
    _elementVerticalPadding = paddingTop + paddingBottom;
  }
  return _elementVerticalPadding;
};
const MultilineInput = props => {
  const onHeightChange = props.onHeightChange;
  const ref = react$1.useRef(null);
  const handleHeightChange = react$1.useCallback((_, meta) => {
    const containerHeight = ref.current.scrollHeight;
    const textHeight = containerHeight - getElementVerticalPadding(ref.current);
    const rowCount = Math.floor(textHeight / meta.rowHeight);
    if (onHeightChange) {
      onHeightChange(containerHeight, rowCount);
    }
  }, [ref, onHeightChange]);
  if (!props.isReadOnly) ;
  return jsxRuntime.jsx(TextareaAutosize__default["default"], _objectSpread({
    ref: ref,
    name: props.name,
    onHeightChange: handleHeightChange,
    autoComplete: props.autoComplete,
    value: props.value,
    onChange: props.onChange,
    id: props.id,
    onBlur: props.onBlur,
    onFocus: props.onFocus,
    disabled: props.isDisabled,
    placeholder: props.placeholder,
    readOnly: props.isReadOnly,
    autoFocus: props.isAutofocussed,
    css: getTextareaStyles(props)
    // Allow to override the styles by passing a `className` prop.
    // Custom styles can also be passed using the `css` prop from emotion.
    // https://emotion.sh/docs/css-prop#style-precedence
    ,
    className: props.className
    /* ARIA */,
    "aria-readonly": props.isReadOnly,
    "aria-multiline": "true",
    "aria-invalid": props['aria-invalid'],
    "aria-errormessage": props['aria-errormessage'],
    role: "textbox",
    minRows: MIN_ROW_COUNT,
    maxRows: props.isOpen ? undefined : MIN_ROW_COUNT,
    cacheMeasurements: true
  }, utils.filterDataAttributes(props)));
};
MultilineInput.propTypes = {};
MultilineInput.displayName = 'MultilineInput';
var MultilineInput$1 = MultilineInput;

var messages = reactIntl.defineMessages({
  expand: {
    id: 'UIKit.MultilineTextInput.expand',
    description: 'The label for "expand" action',
    defaultMessage: 'Expand'
  },
  collapse: {
    id: 'UIKit.MultilineTextInput.collapse',
    description: 'The label for "collapse" action',
    defaultMessage: 'Collapse'
  }
});

const accessibleHiddenInputStyles = {
  name: "1rkpb8t",
  styles: "left:-9999px;position:fixed;top:0"
} ;
var accessibleHiddenInputStyles$1 = accessibleHiddenInputStyles;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

exports.LocalizedInputToggle = LocalizedInputToggle$1;
exports.MultilineInput = MultilineInput$1;
exports.accessibleHiddenInputStyles = accessibleHiddenInputStyles$1;
exports.getInputStyles = getInputStyles;
exports.messagesLocalizedInput = messages$1;
exports.messagesMultilineInput = messages;
exports.version = version;
