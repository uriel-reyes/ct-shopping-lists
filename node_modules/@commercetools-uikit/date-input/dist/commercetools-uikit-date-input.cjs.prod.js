'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _Object$keys = require('@babel/runtime-corejs3/core-js-stable/object/keys');
var _Object$getOwnPropertySymbols = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols');
var _filterInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/filter');
var _Object$getOwnPropertyDescriptor = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor');
var _forEachInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/for-each');
var _Object$getOwnPropertyDescriptors = require('@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors');
var _Object$defineProperties = require('@babel/runtime-corejs3/core-js-stable/object/define-properties');
var _Object$defineProperty = require('@babel/runtime-corejs3/core-js-stable/object/define-property');
var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
var _slicedToArray = require('@babel/runtime-corejs3/helpers/slicedToArray');
require('prop-types');
var _fillInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/fill');
var _trimInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/trim');
var _mapInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/map');
var react = require('react');
var Downshift = require('downshift');
var reactIntl = require('react-intl');
var Constraints = require('@commercetools-uikit/constraints');
var utils = require('@commercetools-uikit/utils');
var calendarUtils = require('@commercetools-uikit/calendar-utils');
var calendarTimeUtils = require('@commercetools-uikit/calendar-time-utils');
var jsxRuntime = require('@emotion/react/jsx-runtime');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _Object$keys__default = /*#__PURE__*/_interopDefault(_Object$keys);
var _Object$getOwnPropertySymbols__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertySymbols);
var _filterInstanceProperty__default = /*#__PURE__*/_interopDefault(_filterInstanceProperty);
var _Object$getOwnPropertyDescriptor__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptor);
var _forEachInstanceProperty__default = /*#__PURE__*/_interopDefault(_forEachInstanceProperty);
var _Object$getOwnPropertyDescriptors__default = /*#__PURE__*/_interopDefault(_Object$getOwnPropertyDescriptors);
var _Object$defineProperties__default = /*#__PURE__*/_interopDefault(_Object$defineProperties);
var _Object$defineProperty__default = /*#__PURE__*/_interopDefault(_Object$defineProperty);
var _fillInstanceProperty__default = /*#__PURE__*/_interopDefault(_fillInstanceProperty);
var _trimInstanceProperty__default = /*#__PURE__*/_interopDefault(_trimInstanceProperty);
var _mapInstanceProperty__default = /*#__PURE__*/_interopDefault(_mapInstanceProperty);
var Downshift__default = /*#__PURE__*/_interopDefault(Downshift);
var Constraints__default = /*#__PURE__*/_interopDefault(Constraints);

function ownKeys(object, enumerableOnly) { var keys = _Object$keys__default["default"](object); if (_Object$getOwnPropertySymbols__default["default"]) { var symbols = _Object$getOwnPropertySymbols__default["default"](object); enumerableOnly && (symbols = _filterInstanceProperty__default["default"](symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor__default["default"](object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var _context2, _context3; var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _forEachInstanceProperty__default["default"](_context2 = ownKeys(Object(source), !0)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors__default["default"] ? _Object$defineProperties__default["default"](target, _Object$getOwnPropertyDescriptors__default["default"](source)) : _forEachInstanceProperty__default["default"](_context3 = ownKeys(Object(source))).call(_context3, function (key) { _Object$defineProperty__default["default"](target, key, _Object$getOwnPropertyDescriptor__default["default"](source, key)); }); } return target; }
const preventDownshiftDefault = event => {
  event.nativeEvent.preventDownshiftDefault = true;
};
const DateInput = props => {
  const intl = reactIntl.useIntl();
  const _useState = react.useState(props.value || calendarUtils.getToday()),
    _useState2 = _slicedToArray(_useState, 2),
    calendarDate = _useState2[0],
    setCalendarDate = _useState2[1];
  const _useState3 = react.useState([]),
    _useState4 = _slicedToArray(_useState3, 2),
    suggestedItems = _useState4[0],
    setSuggestedItems = _useState4[1];
  const _useState5 = react.useState(props.value === '' ? null : calendarUtils.getDateInMonth(props.value) - 1),
    _useState6 = _slicedToArray(_useState5, 2),
    highlightedIndex = _useState6[0],
    setHighlightedIndex = _useState6[1];
  const inputRef = react.useRef(null);
  if (!props.isReadOnly) ;
  const onChange = props.onChange;
  const emit = react.useCallback(value => onChange === null || onChange === void 0 ? void 0 : onChange({
    target: {
      id: props.id,
      name: props.name,
      // when cleared the value is null, but we always want it to be an
      // empty string when there is no value.
      value: value || ''
    }
  }), [onChange, props.id, props.name]);
  const handleChange = react.useCallback(date => {
    var _inputRef$current;
    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.setSelectionRange(0, 100);
    emit(date);
  }, [inputRef, emit]);
  const onBlur = props.onBlur;
  const handleBlur = react.useCallback(() => {
    if (onBlur) onBlur({
      target: {
        id: props.id,
        name: props.name
      }
    });
  }, [onBlur, props.id, props.name]);
  const showToday = () => {
    var _inputRef$current2;
    const today = calendarUtils.getToday();
    setCalendarDate(today);
    setHighlightedIndex(suggestedItems.length + calendarUtils.getDateInMonth(today) - 1);
    (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.focus();
  };
  const jumpMonth = function (amount) {
    let dayToHighlight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const nextDate = calendarUtils.changeMonth(calendarDate, amount);
    setCalendarDate(nextDate);
    setHighlightedIndex(dayToHighlight);
  };
  return jsxRuntime.jsx(Constraints__default["default"].Horizontal, {
    max: props.horizontalConstraint,
    children: jsxRuntime.jsx(Downshift__default["default"], {
      inputId: props.id,
      itemToString: calendarUtils.createItemToString(intl.locale),
      selectedItem: props.value === '' ? null : props.value,
      highlightedIndex: highlightedIndex,
      onChange: handleChange,
      onStateChange: changes => {
        if (changes.hasOwnProperty('inputValue')) {
          // input changed because user typed
          if (changes.type === Downshift__default["default"].stateChangeTypes.changeInput) {
            const date = calendarUtils.parseInputToDate(changes.inputValue, intl.locale);
            if (date === '') {
              setSuggestedItems([]);
              setHighlightedIndex(null);
            } else {
              setSuggestedItems([date]);
              if (calendarUtils.getIsDateInRange(date, props.minValue, props.maxValue)) {
                setHighlightedIndex(calendarUtils.getDateInMonth(date) - 1);
              }
              setCalendarDate(date);
            }
          } else {
            // input changed because user selected a date
            setSuggestedItems([]);
            setHighlightedIndex(null);
          }
          /**
           * Asides the inputValue, we also have other ways to enter calendar inputs like the mouse move event to enter calender values.
           * We check the downshift changes property to be sure it has highlightedIndex That is not null before updating it,
           * otherwise it may override the initially set highlightedIndex from the inputValue and set it to null.
           */
        } else if (changes.hasOwnProperty('highlightedIndex')) {
          setHighlightedIndex(changes.highlightedIndex);
        }
      },
      children: _ref => {
        var _context;
        let getInputProps = _ref.getInputProps,
          getMenuProps = _ref.getMenuProps,
          getItemProps = _ref.getItemProps,
          getToggleButtonProps = _ref.getToggleButtonProps,
          clearSelection = _ref.clearSelection,
          downshiftHighlightedIndex = _ref.highlightedIndex,
          openMenu = _ref.openMenu,
          setDownshiftHighlightedIndex = _ref.setHighlightedIndex,
          selectedItem = _ref.selectedItem,
          isOpen = _ref.isOpen,
          inputValue = _ref.inputValue;
        const calendarItems = calendarUtils.createCalendarItems(calendarDate);
        const paddingDayCount = calendarUtils.getPaddingDayCount(calendarDate, intl.locale);
        const paddingDays = _fillInstanceProperty__default["default"](_context = Array(paddingDayCount)).call(_context, undefined);
        const weekdays = calendarUtils.getWeekdayNames(intl.locale);
        const today = calendarUtils.getToday();
        return jsxRuntime.jsxs("div", {
          onFocus: props.onFocus,
          onBlur: handleBlur,
          children: [jsxRuntime.jsx(calendarUtils.CalendarBody, {
            inputRef: inputRef,
            inputProps: getInputProps(_objectSpread({
              /* ARIA */
              'aria-invalid': props['aria-invalid'],
              'aria-errormessage': props['aria-errormessage'],
              // Unset the aria-labelledby as it interfers with the link
              // between the <label for> and the <input id>.
              'aria-labelledby': undefined,
              name: props.name,
              placeholder: typeof props.placeholder === 'string' ? props.placeholder : calendarTimeUtils.getLocalizedDateTimeFormatPattern(intl.locale),
              onMouseEnter: () => {
                // we remove the highlight so that the user can use the
                // arrow keys to move the cursor when hovering
                // @ts-ignore
                if (isOpen) setDownshiftHighlightedIndex(null);
              },
              onKeyDown: event => {
                if (props.isReadOnly) {
                  preventDownshiftDefault(event);
                  return;
                }
                if (event.key === 'Enter' && (inputValue === null || inputValue === void 0 ? void 0 : _trimInstanceProperty__default["default"](inputValue).call(inputValue)) === '') {
                  clearSelection();
                }
                // ArrowDown
                if (event.key === 'ArrowDown') {
                  const nextDayToHighlight = calendarUtils.getNextDay(calendarItems[Number(highlightedIndex)]);
                  if (!calendarUtils.getIsDateInRange(nextDayToHighlight, props.minValue, props.maxValue)) {
                    // if the date to highlight is disabled
                    // then do nothing
                    preventDownshiftDefault(event);
                    return;
                  }
                  if (Number(highlightedIndex) + 1 >= calendarItems.length) {
                    // if it's the end of the month
                    // then bypass normal arrow navigation
                    preventDownshiftDefault(event);
                    // then jump to start of next month
                    jumpMonth(1, 0);
                  }
                }
                // ArrowUp
                if (event.key === 'ArrowUp') {
                  const previousDay = calendarUtils.getPreviousDay(calendarItems[Number(highlightedIndex)]);
                  if (!calendarUtils.getIsDateInRange(previousDay, props.minValue, props.maxValue)) {
                    // if the date to highlight is disabled
                    // then do nothing
                    preventDownshiftDefault(event);
                    return;
                  }
                  if (Number(highlightedIndex) <= 0) {
                    // if it's the start of the month
                    // then bypass normal arrow navigation
                    preventDownshiftDefault(event);
                    const numberOfDaysOfPrevMonth = calendarUtils.getDaysInMonth(previousDay);
                    // then jump to the last day of the previous month
                    jumpMonth(-1, numberOfDaysOfPrevMonth - 1);
                  }
                }
              },
              // we only do this for readOnly because the input
              // doesn't ignore these events, unlike when its disabled
              onClick: props.isReadOnly ? undefined : openMenu
            }, utils.filterDataAttributes(props))),
            hasSelection: Boolean(selectedItem),
            onClear: clearSelection,
            isOpen: isOpen,
            isDisabled: props.isDisabled,
            isReadOnly: props.isReadOnly,
            toggleButtonProps: getToggleButtonProps(),
            hasError: props.hasError,
            hasWarning: props.hasWarning
          }), isOpen && !props.isDisabled && !props.isReadOnly && jsxRuntime.jsxs(calendarUtils.CalendarMenu, _objectSpread(_objectSpread({}, getMenuProps()), {}, {
            hasError: props.hasError,
            hasWarning: props.hasWarning,
            children: [jsxRuntime.jsx(calendarUtils.CalendarHeader, {
              monthLabel: calendarUtils.getMonthCalendarLabel(calendarDate, intl.locale),
              yearLabel: calendarUtils.getYearCalendarLabel(calendarDate, intl.locale),
              onPrevMonthClick: () => jumpMonth(-1),
              onTodayClick: showToday,
              onNextMonthClick: () => jumpMonth(1),
              onPrevYearClick: () => jumpMonth(-12),
              onNextYearClick: () => jumpMonth(12)
            }), jsxRuntime.jsxs(calendarUtils.CalendarContent, {
              children: [_mapInstanceProperty__default["default"](weekdays).call(weekdays, weekday => jsxRuntime.jsx(calendarUtils.CalendarDay, {
                type: "heading",
                children: weekday
              }, weekday)), _mapInstanceProperty__default["default"](paddingDays).call(paddingDays, (_, index) => jsxRuntime.jsx(calendarUtils.CalendarDay, {
                type: "spacing"
              }, index)), _mapInstanceProperty__default["default"](calendarItems).call(calendarItems, (item, index) => jsxRuntime.jsx(calendarUtils.CalendarDay, _objectSpread(_objectSpread({
                isToday: calendarUtils.isSameDay(today, item)
              }, getItemProps({
                disabled: !calendarUtils.getIsDateInRange(item, props.minValue, props.maxValue),
                item,
                onMouseOut: () => {
                  // @ts-ignore
                  setDownshiftHighlightedIndex(null);
                }
              })), {}, {
                isHighlighted: index === downshiftHighlightedIndex,
                isSelected: calendarUtils.isSameDay(item, props.value),
                children: calendarUtils.getCalendarDayLabel(item)
              }), item))]
            })]
          }))]
        });
      }
    }, intl.locale)
  });
};
DateInput.propTypes = {};
DateInput.displayName = 'DateInput';
DateInput.isEmpty = value => value === '';
var DateInput$1 = DateInput;

// NOTE: This string will be replaced on build time with the package version.
var version = "16.11.0";

exports["default"] = DateInput$1;
exports.version = version;
